// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/copilot/chat/ChatFlow.proto" (package "copilot.chat", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @api_path: /api/copilot/chat/feedbacks
 * @method: POST
 * @content-type: application/json
 * @summary: 反馈 点赞 like, 点踩 dislike, 撤销点赞 null
 *
 * @generated from protobuf message copilot.chat.ChatFeedbacksRequest
 */
export interface ChatFeedbacksRequest {
    /**
     * 回答id
     *
     * @generated from protobuf field: string messageId = 1
     */
    messageId: string;
    /**
     * 反馈类型
     *
     * @generated from protobuf field: copilot.chat.Rating rating = 2
     */
    rating: Rating;
}
/**
 * @api_path: /api/copilot/chat-messages
 * @method: POST
 * @content-type: application/json sse
 * @summary: 各种提问
 *
 * @generated from protobuf message copilot.chat.ChatMessagesRequest
 */
export interface ChatMessagesRequest {
    /**
     * 笔记id
     *
     * @generated from protobuf field: string noteId = 1
     */
    noteId: string;
    /**
     * pdfid
     *
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * 模型类型
     *
     * @generated from protobuf field: string modelType = 3
     */
    modelType: string;
    /**
     * 对话内容
     *
     * @generated from protobuf field: string content = 4
     */
    content: string;
    /**
     * 对话id 【复用dify的对话id】
     *
     * @generated from protobuf field: optional string conversationId = 6
     */
    conversationId?: string;
    /**
     * taskId, 用于重试
     *
     * @generated from protobuf field: optional string taskId = 7
     */
    taskId?: string;
    /**
     * 选区文本
     *
     * @generated from protobuf field: optional copilot.chat.SelectedText selectedText = 8
     */
    selectedText?: SelectedText;
    /**
     * 上传的文件组，目前只支持图片
     *
     * @generated from protobuf field: repeated copilot.chat.UploadFile uploadFiles = 9
     */
    uploadFiles: UploadFile[];
    /**
     * 引用信息,用于续写
     *
     * @generated from protobuf field: optional copilot.chat.QuoteInfo quoteInfo = 10
     */
    quoteInfo?: QuoteInfo;
    /**
     * 是否开启回答后的问题推荐，
     *
     * @generated from protobuf field: optional bool enableQuestionRecommend = 11
     */
    enableQuestionRecommend?: boolean;
    /**
     * 消息id
     *
     * @generated from protobuf field: optional string id = 12
     */
    id?: string;
}
/**
 * 引用信息
 *
 * @generated from protobuf message copilot.chat.QuoteInfo
 */
export interface QuoteInfo {
    /**
     * @generated from protobuf field: string messageId = 1
     */
    messageId: string;
    /**
     * 引用文本
     *
     * @generated from protobuf field: string quoteContent = 2
     */
    quoteContent: string;
}
/**
 * 选区文本
 *
 * @generated from protobuf message copilot.chat.SelectedText
 */
export interface SelectedText {
    /**
     * @generated from protobuf field: string selectedText = 1
     */
    selectedText: string;
    /**
     * @generated from protobuf field: int64 selectedPageNum = 2
     */
    selectedPageNum: bigint;
    /**
     * @generated from protobuf field: repeated copilot.chat.RectOptions selectedBoundingBox = 3
     */
    selectedBoundingBox: RectOptions[];
}
/**
 * 上传的文件
 *
 * @generated from protobuf message copilot.chat.UploadFile
 */
export interface UploadFile {
    /**
     * @generated from protobuf field: string base64 = 1
     */
    base64: string;
    /**
     * @generated from protobuf field: int64 pageNum = 2
     */
    pageNum: bigint;
}
/**
 * @api_path: /api/copilot/summary-single-paper
 * @method: POST
 * @content-type: application/json sse
 * @summary: 按照pdf进行总结
 * response: ChatMessage
 *
 * @generated from protobuf message copilot.chat.SummarySinglePaperRequest
 */
export interface SummarySinglePaperRequest {
    /**
     * 笔记id
     *
     * @generated from protobuf field: string noteId = 1
     */
    noteId: string;
    /**
     * pdfid
     *
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
}
/**
 * @api_path: /api/copilot/chat-messages/stop
 * @method: POST
 * @content-type: application/json
 * @summary: 停止回答
 *
 * @generated from protobuf message copilot.chat.StopChatMessagesRequest
 */
export interface StopChatMessagesRequest {
    /**
     * 任务id
     *
     * @generated from protobuf field: string taskId = 1
     */
    taskId: string;
}
/**
 * *
 * 	接口描述:获取对话的历史消息
 * 	接口url:/api/copilot/chat/messages
 * 	接口请求方式: GET
 * 	参数格式:application/json
 *
 * @generated from protobuf message copilot.chat.GetChatMessagesRequest
 */
export interface GetChatMessagesRequest {
    /**
     * pdfid
     *
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
    /**
     * 对话id
     *
     * @generated from protobuf field: optional string conversationId = 2
     */
    conversationId?: string;
    /**
     * firstId
     *
     * @generated from protobuf field: optional string firstId = 3
     */
    firstId?: string;
    /**
     * limit
     *
     * @generated from protobuf field: optional int32 limit = 4
     */
    limit?: number;
}
/**
 * @generated from protobuf message copilot.chat.GetChatMessagesResponse
 */
export interface GetChatMessagesResponse {
    /**
     * 是否有更多的消息
     *
     * @generated from protobuf field: bool hasMore = 1
     */
    hasMore: boolean;
    /**
     * @generated from protobuf field: repeated copilot.chat.ChatMessageObj data = 2
     */
    data: ChatMessageObj[];
    /**
     * @generated from protobuf field: int32 limit = 3
     */
    limit: number;
}
/**
 * @generated from protobuf message copilot.chat.ChatMessageObj
 */
export interface ChatMessageObj {
    /**
     * @generated from protobuf field: copilot.chat.ChatMessagesRequest chatMessageRequest = 1
     */
    chatMessageRequest?: ChatMessagesRequest;
    /**
     * @generated from protobuf field: repeated copilot.chat.ChatMessage chatMessages = 2
     */
    chatMessages: ChatMessage[];
}
/**
 * @generated from protobuf message copilot.chat.ChatMessage
 */
export interface ChatMessage {
    /**
     * 对话id
     *
     * @generated from protobuf field: string conversationId = 1
     */
    conversationId: string;
    /**
     * 任务id
     *
     * @generated from protobuf field: string taskId = 2
     */
    taskId: string;
    /**
     * 消息id
     *
     * @generated from protobuf field: string messageId = 3
     */
    messageId: string;
    /**
     * 回答内容,当ChatGPT还没返回结果时,该字段可能为空
     *
     * @generated from protobuf field: optional string answer = 4
     */
    answer?: string;
    /**
     * 创建时间
     *
     * @generated from protobuf field: int64 createAt = 5
     */
    createAt: bigint;
    /**
     * 评分
     *
     * @generated from protobuf field: optional copilot.chat.Rating rating = 6
     */
    rating?: Rating;
    /**
     * 回答的状态
     *
     * @generated from protobuf field: copilot.chat.AnswerStatus answerStatus = 7
     */
    answerStatus: AnswerStatus;
    /**
     * 是否可以重试
     *
     * @generated from protobuf field: bool canRetry = 8
     */
    canRetry: boolean;
    /**
     * 错误信息
     *
     * @generated from protobuf field: string errorMessage = 9
     */
    errorMessage: string;
    /**
     * message files
     *
     * @generated from protobuf field: repeated copilot.chat.MessageFile files = 10
     */
    files: MessageFile[];
    /**
     * retriever resources 引用和归属分段列表
     *
     * @generated from protobuf field: repeated copilot.chat.RetrieverResource retrieverResources = 11
     */
    retrieverResources: RetrieverResource[];
    /**
     * 回答内容中，是否有后处理的提问，或者上一个回答的相关提问
     *
     * @generated from protobuf field: repeated string relatedQuestions = 12
     */
    relatedQuestions: string[];
    /**
     * 模型类型
     *
     * @generated from protobuf field: string modelType = 13
     */
    modelType: string;
    /**
     * 事件类型
     *
     * @generated from protobuf field: string event = 14
     */
    event: string;
    /**
     * 提问ID
     *
     * @generated from protobuf field: string requestId = 15
     */
    requestId: string;
    /**
     * id
     *
     * @generated from protobuf field: string id = 16
     */
    id: string;
}
/**
 * 文件类型
 *
 * @generated from protobuf message copilot.chat.MessageFile
 */
export interface MessageFile {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string url = 4
     */
    url: string;
}
/**
 * retriever resource 引用和归属分段
 *
 * @generated from protobuf message copilot.chat.RetrieverResource
 */
export interface RetrieverResource {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string url = 4
     */
    url: string;
    /**
     * @generated from protobuf field: string segment = 5
     */
    segment: string;
}
/**
 * 选区
 *
 * @generated from protobuf message copilot.chat.RectOptions
 */
export interface RectOptions {
    /**
     * @generated from protobuf field: double x = 1
     */
    x: number; // 锚点横坐标
    /**
     * @generated from protobuf field: double y = 2
     */
    y: number; // 锚点纵坐标
    /**
     * @generated from protobuf field: double width = 3
     */
    width: number; // 选区宽度
    /**
     * @generated from protobuf field: double height = 4
     */
    height: number; // 选区高度
}
/**
 * @api_path: /api/copilot/chat/satisfaction/feedback
 * @method: POST
 * @content-type: application/json
 * @summary: 满意度反馈
 *
 * @generated from protobuf message copilot.chat.ChatSatisfactionFeedbackRequest
 */
export interface ChatSatisfactionFeedbackRequest {
    /**
     * 回答id
     *
     * @generated from protobuf field: string messageId = 1
     */
    messageId: string;
    /**
     * 满意度
     *
     * @generated from protobuf field: copilot.chat.Satisfaction satisfaction = 2
     */
    satisfaction: Satisfaction;
}
/**
 * *
 * 	接口描述:换个答案
 * 	接口url:/answer/change
 * 	接口请求方式: GET
 * 	参数格式:url参数
 *
 * @generated from protobuf message copilot.chat.ChangeAnswerRequest
 */
export interface ChangeAnswerRequest {
    /**
     * 字段同上
     *
     * @generated from protobuf field: string lang = 1
     */
    lang: string;
    /**
     * @generated from protobuf field: string questionId = 2
     */
    questionId: string;
    /**
     * 用于追问场景,表示针对某个答案再做提问
     *
     * @generated from protobuf field: optional string answerId = 3
     */
    answerId?: string;
    /**
     * 是否属于要优化的内容
     *
     * @generated from protobuf field: optional string optimizeId = 4
     */
    optimizeId?: string;
}
/**
 * @generated from protobuf message copilot.chat.ChangeAnswerResponse
 */
export interface ChangeAnswerResponse {
    /**
     * @generated from protobuf field: copilot.chat.AnswerInfo answer = 1
     */
    answer?: AnswerInfo;
}
/**
 * @generated from protobuf message copilot.chat.AnswerInfo
 */
export interface AnswerInfo {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: bigint;
    /**
     * 回答内容,当ChatGPT还没返回结果时,该字段可能为空
     *
     * @generated from protobuf field: optional string answer = 2
     */
    answer?: string;
    /**
     * @generated from protobuf field: int64 createDate = 3
     */
    createDate: bigint;
    /**
     * 是否点赞
     *
     * @generated from protobuf field: bool isLike = 4
     */
    isLike: boolean;
    /**
     * 是否点踩
     *
     * @generated from protobuf field: bool isDisLike = 5
     */
    isDisLike: boolean;
    /**
     * 回答的状态
     *
     * @generated from protobuf field: copilot.chat.AnswerStatus answerStatus = 6
     */
    answerStatus: AnswerStatus;
    /**
     * 是否可以重试
     *
     * @generated from protobuf field: bool canRetry = 7
     */
    canRetry: boolean;
    /**
     * @generated from protobuf field: string errorMessage = 8
     */
    errorMessage: string;
    /**
     * 回答内容中，是否有后处理的提问
     *
     * @generated from protobuf field: repeated string hanleProcessedQuestion = 9
     */
    hanleProcessedQuestion: string[];
    /**
     * @generated from protobuf field: optional bool showSatisfactionFeedback = 10
     */
    showSatisfactionFeedback?: boolean;
    /**
     * 是否是优化后的结果
     *
     * @generated from protobuf field: optional bool isOptimized = 11
     */
    isOptimized?: boolean;
    /**
     * 优化后的结果反馈
     *
     * @generated from protobuf field: optional string optimizedFeedbackResult = 12
     */
    optimizedFeedbackResult?: string;
    /**
     * 是否已退豆
     *
     * @generated from protobuf field: optional bool isRefundAiBean = 13
     */
    isRefundAiBean?: boolean;
    /**
     * 数据创建时间
     *
     * @generated from protobuf field: uint64 createTime = 14
     */
    createTime: bigint;
    /**
     * 是否需要退豆
     *
     * @generated from protobuf field: optional bool needRefundAiBean = 15
     */
    needRefundAiBean?: boolean;
}
/**
 * 反馈类型
 *
 * @generated from protobuf enum copilot.chat.Rating
 */
export enum Rating {
    /**
     * @generated from protobuf enum value: LIKE = 0;
     */
    LIKE = 0,
    /**
     * @generated from protobuf enum value: DISLIKE = 1;
     */
    DISLIKE = 1,
    /**
     * @generated from protobuf enum value: NULL = 2;
     */
    NULL = 2
}
/**
 * 回答状态
 *
 * @generated from protobuf enum copilot.chat.AnswerStatus
 */
export enum AnswerStatus {
    /**
     * @generated from protobuf enum value: PENDING = 0;
     */
    PENDING = 0,
    /**
     * @generated from protobuf enum value: SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * @generated from protobuf enum value: ERROR = 2;
     */
    ERROR = 2
}
/**
 * @generated from protobuf enum copilot.chat.Type
 */
export enum Type {
    /**
     * @generated from protobuf enum value: QUESTION = 0;
     */
    QUESTION = 0,
    /**
     * @generated from protobuf enum value: ANSWER = 1;
     */
    ANSWER = 1
}
/**
 * @generated from protobuf enum copilot.chat.QuestionType
 */
export enum QuestionType {
    /**
     * @generated from protobuf enum value: SELECT_TEXT = 0;
     */
    SELECT_TEXT = 0,
    /**
     * @generated from protobuf enum value: ASK_QUESTION = 1;
     */
    ASK_QUESTION = 1,
    /**
     * @generated from protobuf enum value: IMAGE_QUESTION = 2;
     */
    IMAGE_QUESTION = 2
}
/**
 * 满意度
 *
 * @generated from protobuf enum copilot.chat.Satisfaction
 */
export enum Satisfaction {
    /**
     * @generated from protobuf enum value: EXCELLENT = 0;
     */
    EXCELLENT = 0,
    /**
     * @generated from protobuf enum value: GOOD = 1;
     */
    GOOD = 1,
    /**
     * @generated from protobuf enum value: AVERAGE = 2;
     */
    AVERAGE = 2,
    /**
     * @generated from protobuf enum value: INFERIOR = 3;
     */
    INFERIOR = 3,
    /**
     * @generated from protobuf enum value: TERRIBLE = 4;
     */
    TERRIBLE = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class ChatFeedbacksRequest$Type extends MessageType<ChatFeedbacksRequest> {
    constructor() {
        super("copilot.chat.ChatFeedbacksRequest", [
            { no: 1, name: "messageId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "100" } } } },
            { no: 2, name: "rating", kind: "enum", T: () => ["copilot.chat.Rating", Rating], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<ChatFeedbacksRequest>): ChatFeedbacksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageId = "";
        message.rating = 0;
        if (value !== undefined)
            reflectionMergePartial<ChatFeedbacksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatFeedbacksRequest): ChatFeedbacksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string messageId */ 1:
                    message.messageId = reader.string();
                    break;
                case /* copilot.chat.Rating rating */ 2:
                    message.rating = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatFeedbacksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string messageId = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* copilot.chat.Rating rating = 2; */
        if (message.rating !== 0)
            writer.tag(2, WireType.Varint).int32(message.rating);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.ChatFeedbacksRequest
 */
export const ChatFeedbacksRequest = new ChatFeedbacksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatMessagesRequest$Type extends MessageType<ChatMessagesRequest> {
    constructor() {
        super("copilot.chat.ChatMessagesRequest", [
            { no: 1, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "modelType", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "100" } } } },
            { no: 4, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "0", maxLen: "4000" } } } },
            { no: 6, name: "conversationId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "taskId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "selectedText", kind: "message", T: () => SelectedText },
            { no: 9, name: "uploadFiles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UploadFile },
            { no: 10, name: "quoteInfo", kind: "message", T: () => QuoteInfo },
            { no: 11, name: "enableQuestionRecommend", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChatMessagesRequest>): ChatMessagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        message.pdfId = "";
        message.modelType = "";
        message.content = "";
        message.uploadFiles = [];
        if (value !== undefined)
            reflectionMergePartial<ChatMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatMessagesRequest): ChatMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string noteId */ 1:
                    message.noteId = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* string modelType */ 3:
                    message.modelType = reader.string();
                    break;
                case /* string content */ 4:
                    message.content = reader.string();
                    break;
                case /* optional string conversationId */ 6:
                    message.conversationId = reader.string();
                    break;
                case /* optional string taskId */ 7:
                    message.taskId = reader.string();
                    break;
                case /* optional copilot.chat.SelectedText selectedText */ 8:
                    message.selectedText = SelectedText.internalBinaryRead(reader, reader.uint32(), options, message.selectedText);
                    break;
                case /* repeated copilot.chat.UploadFile uploadFiles */ 9:
                    message.uploadFiles.push(UploadFile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional copilot.chat.QuoteInfo quoteInfo */ 10:
                    message.quoteInfo = QuoteInfo.internalBinaryRead(reader, reader.uint32(), options, message.quoteInfo);
                    break;
                case /* optional bool enableQuestionRecommend */ 11:
                    message.enableQuestionRecommend = reader.bool();
                    break;
                case /* optional string id */ 12:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string noteId = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* string modelType = 3; */
        if (message.modelType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.modelType);
        /* string content = 4; */
        if (message.content !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.content);
        /* optional string conversationId = 6; */
        if (message.conversationId !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.conversationId);
        /* optional string taskId = 7; */
        if (message.taskId !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.taskId);
        /* optional copilot.chat.SelectedText selectedText = 8; */
        if (message.selectedText)
            SelectedText.internalBinaryWrite(message.selectedText, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated copilot.chat.UploadFile uploadFiles = 9; */
        for (let i = 0; i < message.uploadFiles.length; i++)
            UploadFile.internalBinaryWrite(message.uploadFiles[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional copilot.chat.QuoteInfo quoteInfo = 10; */
        if (message.quoteInfo)
            QuoteInfo.internalBinaryWrite(message.quoteInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional bool enableQuestionRecommend = 11; */
        if (message.enableQuestionRecommend !== undefined)
            writer.tag(11, WireType.Varint).bool(message.enableQuestionRecommend);
        /* optional string id = 12; */
        if (message.id !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.ChatMessagesRequest
 */
export const ChatMessagesRequest = new ChatMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuoteInfo$Type extends MessageType<QuoteInfo> {
    constructor() {
        super("copilot.chat.QuoteInfo", [
            { no: 1, name: "messageId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quoteContent", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuoteInfo>): QuoteInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageId = "";
        message.quoteContent = "";
        if (value !== undefined)
            reflectionMergePartial<QuoteInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuoteInfo): QuoteInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string messageId */ 1:
                    message.messageId = reader.string();
                    break;
                case /* string quoteContent */ 2:
                    message.quoteContent = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuoteInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string messageId = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string quoteContent = 2; */
        if (message.quoteContent !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quoteContent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.QuoteInfo
 */
export const QuoteInfo = new QuoteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectedText$Type extends MessageType<SelectedText> {
    constructor() {
        super("copilot.chat.SelectedText", [
            { no: 1, name: "selectedText", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "selectedPageNum", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "selectedBoundingBox", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RectOptions }
        ]);
    }
    create(value?: PartialMessage<SelectedText>): SelectedText {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.selectedText = "";
        message.selectedPageNum = 0n;
        message.selectedBoundingBox = [];
        if (value !== undefined)
            reflectionMergePartial<SelectedText>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectedText): SelectedText {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string selectedText */ 1:
                    message.selectedText = reader.string();
                    break;
                case /* int64 selectedPageNum */ 2:
                    message.selectedPageNum = reader.int64().toBigInt();
                    break;
                case /* repeated copilot.chat.RectOptions selectedBoundingBox */ 3:
                    message.selectedBoundingBox.push(RectOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectedText, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string selectedText = 1; */
        if (message.selectedText !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.selectedText);
        /* int64 selectedPageNum = 2; */
        if (message.selectedPageNum !== 0n)
            writer.tag(2, WireType.Varint).int64(message.selectedPageNum);
        /* repeated copilot.chat.RectOptions selectedBoundingBox = 3; */
        for (let i = 0; i < message.selectedBoundingBox.length; i++)
            RectOptions.internalBinaryWrite(message.selectedBoundingBox[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.SelectedText
 */
export const SelectedText = new SelectedText$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadFile$Type extends MessageType<UploadFile> {
    constructor() {
        super("copilot.chat.UploadFile", [
            { no: 1, name: "base64", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pageNum", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UploadFile>): UploadFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.base64 = "";
        message.pageNum = 0n;
        if (value !== undefined)
            reflectionMergePartial<UploadFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadFile): UploadFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base64 */ 1:
                    message.base64 = reader.string();
                    break;
                case /* int64 pageNum */ 2:
                    message.pageNum = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base64 = 1; */
        if (message.base64 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.base64);
        /* int64 pageNum = 2; */
        if (message.pageNum !== 0n)
            writer.tag(2, WireType.Varint).int64(message.pageNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.UploadFile
 */
export const UploadFile = new UploadFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummarySinglePaperRequest$Type extends MessageType<SummarySinglePaperRequest> {
    constructor() {
        super("copilot.chat.SummarySinglePaperRequest", [
            { no: 1, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<SummarySinglePaperRequest>): SummarySinglePaperRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<SummarySinglePaperRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummarySinglePaperRequest): SummarySinglePaperRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string noteId */ 1:
                    message.noteId = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummarySinglePaperRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string noteId = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.SummarySinglePaperRequest
 */
export const SummarySinglePaperRequest = new SummarySinglePaperRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopChatMessagesRequest$Type extends MessageType<StopChatMessagesRequest> {
    constructor() {
        super("copilot.chat.StopChatMessagesRequest", [
            { no: 1, name: "taskId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "100" } } } }
        ]);
    }
    create(value?: PartialMessage<StopChatMessagesRequest>): StopChatMessagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = "";
        if (value !== undefined)
            reflectionMergePartial<StopChatMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopChatMessagesRequest): StopChatMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string taskId */ 1:
                    message.taskId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopChatMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string taskId = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.StopChatMessagesRequest
 */
export const StopChatMessagesRequest = new StopChatMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChatMessagesRequest$Type extends MessageType<GetChatMessagesRequest> {
    constructor() {
        super("copilot.chat.GetChatMessagesRequest", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "conversationId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "firstId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetChatMessagesRequest>): GetChatMessagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetChatMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChatMessagesRequest): GetChatMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                case /* optional string conversationId */ 2:
                    message.conversationId = reader.string();
                    break;
                case /* optional string firstId */ 3:
                    message.firstId = reader.string();
                    break;
                case /* optional int32 limit */ 4:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChatMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        /* optional string conversationId = 2; */
        if (message.conversationId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.conversationId);
        /* optional string firstId = 3; */
        if (message.firstId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.firstId);
        /* optional int32 limit = 4; */
        if (message.limit !== undefined)
            writer.tag(4, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.GetChatMessagesRequest
 */
export const GetChatMessagesRequest = new GetChatMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChatMessagesResponse$Type extends MessageType<GetChatMessagesResponse> {
    constructor() {
        super("copilot.chat.GetChatMessagesResponse", [
            { no: 1, name: "hasMore", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChatMessageObj },
            { no: 3, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetChatMessagesResponse>): GetChatMessagesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasMore = false;
        message.data = [];
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<GetChatMessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChatMessagesResponse): GetChatMessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool hasMore */ 1:
                    message.hasMore = reader.bool();
                    break;
                case /* repeated copilot.chat.ChatMessageObj data */ 2:
                    message.data.push(ChatMessageObj.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 limit */ 3:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChatMessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool hasMore = 1; */
        if (message.hasMore !== false)
            writer.tag(1, WireType.Varint).bool(message.hasMore);
        /* repeated copilot.chat.ChatMessageObj data = 2; */
        for (let i = 0; i < message.data.length; i++)
            ChatMessageObj.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.GetChatMessagesResponse
 */
export const GetChatMessagesResponse = new GetChatMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatMessageObj$Type extends MessageType<ChatMessageObj> {
    constructor() {
        super("copilot.chat.ChatMessageObj", [
            { no: 1, name: "chatMessageRequest", kind: "message", T: () => ChatMessagesRequest },
            { no: 2, name: "chatMessages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChatMessage }
        ]);
    }
    create(value?: PartialMessage<ChatMessageObj>): ChatMessageObj {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chatMessages = [];
        if (value !== undefined)
            reflectionMergePartial<ChatMessageObj>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatMessageObj): ChatMessageObj {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* copilot.chat.ChatMessagesRequest chatMessageRequest */ 1:
                    message.chatMessageRequest = ChatMessagesRequest.internalBinaryRead(reader, reader.uint32(), options, message.chatMessageRequest);
                    break;
                case /* repeated copilot.chat.ChatMessage chatMessages */ 2:
                    message.chatMessages.push(ChatMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatMessageObj, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* copilot.chat.ChatMessagesRequest chatMessageRequest = 1; */
        if (message.chatMessageRequest)
            ChatMessagesRequest.internalBinaryWrite(message.chatMessageRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated copilot.chat.ChatMessage chatMessages = 2; */
        for (let i = 0; i < message.chatMessages.length; i++)
            ChatMessage.internalBinaryWrite(message.chatMessages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.ChatMessageObj
 */
export const ChatMessageObj = new ChatMessageObj$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatMessage$Type extends MessageType<ChatMessage> {
    constructor() {
        super("copilot.chat.ChatMessage", [
            { no: 1, name: "conversationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "taskId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "messageId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "answer", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "createAt", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "rating", kind: "enum", opt: true, T: () => ["copilot.chat.Rating", Rating] },
            { no: 7, name: "answerStatus", kind: "enum", T: () => ["copilot.chat.AnswerStatus", AnswerStatus] },
            { no: 8, name: "canRetry", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "errorMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MessageFile },
            { no: 11, name: "retrieverResources", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RetrieverResource },
            { no: 12, name: "relatedQuestions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "modelType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "event", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "requestId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChatMessage>): ChatMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.conversationId = "";
        message.taskId = "";
        message.messageId = "";
        message.createAt = 0n;
        message.answerStatus = 0;
        message.canRetry = false;
        message.errorMessage = "";
        message.files = [];
        message.retrieverResources = [];
        message.relatedQuestions = [];
        message.modelType = "";
        message.event = "";
        message.requestId = "";
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<ChatMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatMessage): ChatMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string conversationId */ 1:
                    message.conversationId = reader.string();
                    break;
                case /* string taskId */ 2:
                    message.taskId = reader.string();
                    break;
                case /* string messageId */ 3:
                    message.messageId = reader.string();
                    break;
                case /* optional string answer */ 4:
                    message.answer = reader.string();
                    break;
                case /* int64 createAt */ 5:
                    message.createAt = reader.int64().toBigInt();
                    break;
                case /* optional copilot.chat.Rating rating */ 6:
                    message.rating = reader.int32();
                    break;
                case /* copilot.chat.AnswerStatus answerStatus */ 7:
                    message.answerStatus = reader.int32();
                    break;
                case /* bool canRetry */ 8:
                    message.canRetry = reader.bool();
                    break;
                case /* string errorMessage */ 9:
                    message.errorMessage = reader.string();
                    break;
                case /* repeated copilot.chat.MessageFile files */ 10:
                    message.files.push(MessageFile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated copilot.chat.RetrieverResource retrieverResources */ 11:
                    message.retrieverResources.push(RetrieverResource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string relatedQuestions */ 12:
                    message.relatedQuestions.push(reader.string());
                    break;
                case /* string modelType */ 13:
                    message.modelType = reader.string();
                    break;
                case /* string event */ 14:
                    message.event = reader.string();
                    break;
                case /* string requestId */ 15:
                    message.requestId = reader.string();
                    break;
                case /* string id */ 16:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string conversationId = 1; */
        if (message.conversationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.conversationId);
        /* string taskId = 2; */
        if (message.taskId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.taskId);
        /* string messageId = 3; */
        if (message.messageId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.messageId);
        /* optional string answer = 4; */
        if (message.answer !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.answer);
        /* int64 createAt = 5; */
        if (message.createAt !== 0n)
            writer.tag(5, WireType.Varint).int64(message.createAt);
        /* optional copilot.chat.Rating rating = 6; */
        if (message.rating !== undefined)
            writer.tag(6, WireType.Varint).int32(message.rating);
        /* copilot.chat.AnswerStatus answerStatus = 7; */
        if (message.answerStatus !== 0)
            writer.tag(7, WireType.Varint).int32(message.answerStatus);
        /* bool canRetry = 8; */
        if (message.canRetry !== false)
            writer.tag(8, WireType.Varint).bool(message.canRetry);
        /* string errorMessage = 9; */
        if (message.errorMessage !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.errorMessage);
        /* repeated copilot.chat.MessageFile files = 10; */
        for (let i = 0; i < message.files.length; i++)
            MessageFile.internalBinaryWrite(message.files[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated copilot.chat.RetrieverResource retrieverResources = 11; */
        for (let i = 0; i < message.retrieverResources.length; i++)
            RetrieverResource.internalBinaryWrite(message.retrieverResources[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated string relatedQuestions = 12; */
        for (let i = 0; i < message.relatedQuestions.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.relatedQuestions[i]);
        /* string modelType = 13; */
        if (message.modelType !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.modelType);
        /* string event = 14; */
        if (message.event !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.event);
        /* string requestId = 15; */
        if (message.requestId !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.requestId);
        /* string id = 16; */
        if (message.id !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.ChatMessage
 */
export const ChatMessage = new ChatMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageFile$Type extends MessageType<MessageFile> {
    constructor() {
        super("copilot.chat.MessageFile", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageFile>): MessageFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = "";
        message.name = "";
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<MessageFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageFile): MessageFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string url */ 4:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string url = 4; */
        if (message.url !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.MessageFile
 */
export const MessageFile = new MessageFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieverResource$Type extends MessageType<RetrieverResource> {
    constructor() {
        super("copilot.chat.RetrieverResource", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "segment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RetrieverResource>): RetrieverResource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = "";
        message.name = "";
        message.url = "";
        message.segment = "";
        if (value !== undefined)
            reflectionMergePartial<RetrieverResource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieverResource): RetrieverResource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string url */ 4:
                    message.url = reader.string();
                    break;
                case /* string segment */ 5:
                    message.segment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieverResource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string url = 4; */
        if (message.url !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.url);
        /* string segment = 5; */
        if (message.segment !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.segment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.RetrieverResource
 */
export const RetrieverResource = new RetrieverResource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RectOptions$Type extends MessageType<RectOptions> {
    constructor() {
        super("copilot.chat.RectOptions", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<RectOptions>): RectOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<RectOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RectOptions): RectOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                case /* double width */ 3:
                    message.width = reader.double();
                    break;
                case /* double height */ 4:
                    message.height = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RectOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        /* double width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Bit64).double(message.width);
        /* double height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Bit64).double(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.RectOptions
 */
export const RectOptions = new RectOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatSatisfactionFeedbackRequest$Type extends MessageType<ChatSatisfactionFeedbackRequest> {
    constructor() {
        super("copilot.chat.ChatSatisfactionFeedbackRequest", [
            { no: 1, name: "messageId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "100" } } } },
            { no: 2, name: "satisfaction", kind: "enum", T: () => ["copilot.chat.Satisfaction", Satisfaction] }
        ]);
    }
    create(value?: PartialMessage<ChatSatisfactionFeedbackRequest>): ChatSatisfactionFeedbackRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageId = "";
        message.satisfaction = 0;
        if (value !== undefined)
            reflectionMergePartial<ChatSatisfactionFeedbackRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatSatisfactionFeedbackRequest): ChatSatisfactionFeedbackRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string messageId */ 1:
                    message.messageId = reader.string();
                    break;
                case /* copilot.chat.Satisfaction satisfaction */ 2:
                    message.satisfaction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatSatisfactionFeedbackRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string messageId = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* copilot.chat.Satisfaction satisfaction = 2; */
        if (message.satisfaction !== 0)
            writer.tag(2, WireType.Varint).int32(message.satisfaction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.ChatSatisfactionFeedbackRequest
 */
export const ChatSatisfactionFeedbackRequest = new ChatSatisfactionFeedbackRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeAnswerRequest$Type extends MessageType<ChangeAnswerRequest> {
    constructor() {
        super("copilot.chat.ChangeAnswerRequest", [
            { no: 1, name: "lang", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "questionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "answerId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "optimizeId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<ChangeAnswerRequest>): ChangeAnswerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lang = "";
        message.questionId = "";
        if (value !== undefined)
            reflectionMergePartial<ChangeAnswerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeAnswerRequest): ChangeAnswerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string lang */ 1:
                    message.lang = reader.string();
                    break;
                case /* string questionId */ 2:
                    message.questionId = reader.string();
                    break;
                case /* optional string answerId */ 3:
                    message.answerId = reader.string();
                    break;
                case /* optional string optimizeId */ 4:
                    message.optimizeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeAnswerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string lang = 1; */
        if (message.lang !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.lang);
        /* string questionId = 2; */
        if (message.questionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.questionId);
        /* optional string answerId = 3; */
        if (message.answerId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.answerId);
        /* optional string optimizeId = 4; */
        if (message.optimizeId !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.optimizeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.ChangeAnswerRequest
 */
export const ChangeAnswerRequest = new ChangeAnswerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeAnswerResponse$Type extends MessageType<ChangeAnswerResponse> {
    constructor() {
        super("copilot.chat.ChangeAnswerResponse", [
            { no: 1, name: "answer", kind: "message", T: () => AnswerInfo }
        ]);
    }
    create(value?: PartialMessage<ChangeAnswerResponse>): ChangeAnswerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangeAnswerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeAnswerResponse): ChangeAnswerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* copilot.chat.AnswerInfo answer */ 1:
                    message.answer = AnswerInfo.internalBinaryRead(reader, reader.uint32(), options, message.answer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeAnswerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* copilot.chat.AnswerInfo answer = 1; */
        if (message.answer)
            AnswerInfo.internalBinaryWrite(message.answer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.ChangeAnswerResponse
 */
export const ChangeAnswerResponse = new ChangeAnswerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnswerInfo$Type extends MessageType<AnswerInfo> {
    constructor() {
        super("copilot.chat.AnswerInfo", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "answer", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "createDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "isLike", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "isDisLike", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "answerStatus", kind: "enum", T: () => ["copilot.chat.AnswerStatus", AnswerStatus] },
            { no: 7, name: "canRetry", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "errorMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "hanleProcessedQuestion", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "showSatisfactionFeedback", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "isOptimized", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "optimizedFeedbackResult", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "isRefundAiBean", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "createTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "needRefundAiBean", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AnswerInfo>): AnswerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.createDate = 0n;
        message.isLike = false;
        message.isDisLike = false;
        message.answerStatus = 0;
        message.canRetry = false;
        message.errorMessage = "";
        message.hanleProcessedQuestion = [];
        message.createTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<AnswerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnswerInfo): AnswerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* optional string answer */ 2:
                    message.answer = reader.string();
                    break;
                case /* int64 createDate */ 3:
                    message.createDate = reader.int64().toBigInt();
                    break;
                case /* bool isLike */ 4:
                    message.isLike = reader.bool();
                    break;
                case /* bool isDisLike */ 5:
                    message.isDisLike = reader.bool();
                    break;
                case /* copilot.chat.AnswerStatus answerStatus */ 6:
                    message.answerStatus = reader.int32();
                    break;
                case /* bool canRetry */ 7:
                    message.canRetry = reader.bool();
                    break;
                case /* string errorMessage */ 8:
                    message.errorMessage = reader.string();
                    break;
                case /* repeated string hanleProcessedQuestion */ 9:
                    message.hanleProcessedQuestion.push(reader.string());
                    break;
                case /* optional bool showSatisfactionFeedback */ 10:
                    message.showSatisfactionFeedback = reader.bool();
                    break;
                case /* optional bool isOptimized */ 11:
                    message.isOptimized = reader.bool();
                    break;
                case /* optional string optimizedFeedbackResult */ 12:
                    message.optimizedFeedbackResult = reader.string();
                    break;
                case /* optional bool isRefundAiBean */ 13:
                    message.isRefundAiBean = reader.bool();
                    break;
                case /* uint64 createTime */ 14:
                    message.createTime = reader.uint64().toBigInt();
                    break;
                case /* optional bool needRefundAiBean */ 15:
                    message.needRefundAiBean = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnswerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* optional string answer = 2; */
        if (message.answer !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.answer);
        /* int64 createDate = 3; */
        if (message.createDate !== 0n)
            writer.tag(3, WireType.Varint).int64(message.createDate);
        /* bool isLike = 4; */
        if (message.isLike !== false)
            writer.tag(4, WireType.Varint).bool(message.isLike);
        /* bool isDisLike = 5; */
        if (message.isDisLike !== false)
            writer.tag(5, WireType.Varint).bool(message.isDisLike);
        /* copilot.chat.AnswerStatus answerStatus = 6; */
        if (message.answerStatus !== 0)
            writer.tag(6, WireType.Varint).int32(message.answerStatus);
        /* bool canRetry = 7; */
        if (message.canRetry !== false)
            writer.tag(7, WireType.Varint).bool(message.canRetry);
        /* string errorMessage = 8; */
        if (message.errorMessage !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.errorMessage);
        /* repeated string hanleProcessedQuestion = 9; */
        for (let i = 0; i < message.hanleProcessedQuestion.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.hanleProcessedQuestion[i]);
        /* optional bool showSatisfactionFeedback = 10; */
        if (message.showSatisfactionFeedback !== undefined)
            writer.tag(10, WireType.Varint).bool(message.showSatisfactionFeedback);
        /* optional bool isOptimized = 11; */
        if (message.isOptimized !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isOptimized);
        /* optional string optimizedFeedbackResult = 12; */
        if (message.optimizedFeedbackResult !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.optimizedFeedbackResult);
        /* optional bool isRefundAiBean = 13; */
        if (message.isRefundAiBean !== undefined)
            writer.tag(13, WireType.Varint).bool(message.isRefundAiBean);
        /* uint64 createTime = 14; */
        if (message.createTime !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.createTime);
        /* optional bool needRefundAiBean = 15; */
        if (message.needRefundAiBean !== undefined)
            writer.tag(15, WireType.Varint).bool(message.needRefundAiBean);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.chat.AnswerInfo
 */
export const AnswerInfo = new AnswerInfo$Type();
