// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/pdf/PdfMark.proto" (package "pdf", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { WebNoteAnnotationModel } from "../note/Web";
/**
 * @old_api_path: /pdfMark/v3/web/getByNote
 * @api_path: /api/pdf/pdfMark/v3/web/getByNote
 * @method: GET
 * @content-type: application/json
 * @summary: 获取笔记标注列表
 *
 * @generated from protobuf message pdf.GetNoteAnnotationListByNoteIdRequest
 */
export interface GetNoteAnnotationListByNoteIdRequest {
    /**
     * @generated from protobuf field: string noteId = 1
     */
    noteId: string;
    /**
     * @generated from protobuf field: string groupId = 2
     */
    groupId: string;
    /**
     * @generated from protobuf field: bool handtext = 3
     */
    handtext: boolean;
}
/**
 * @generated from protobuf message pdf.GetNoteAnnotationListByNoteIdResponse
 */
export interface GetNoteAnnotationListByNoteIdResponse {
    /**
     * @generated from protobuf field: repeated note.WebNoteAnnotationModel annotations = 1
     */
    annotations: WebNoteAnnotationModel[];
}
/**
 * @old_api_path: /pdfMark/v3/web/draw/getByNote
 * @api_path: /api/pdf/pdfMark/v3/web/draw/getByNote
 * @method: GET
 * @content-type: application/json
 * @summary: 获取笔记标注列表
 *
 * @generated from protobuf message pdf.GetDrawNoteAnnotationListByNoteIdRequest
 */
export interface GetDrawNoteAnnotationListByNoteIdRequest {
    /**
     * @generated from protobuf field: string noteId = 1
     */
    noteId: string;
    /**
     * @generated from protobuf field: string groupId = 2
     */
    groupId: string;
    /**
     * @generated from protobuf field: bool fetchAll = 3
     */
    fetchAll: boolean;
    /**
     * @generated from protobuf field: bool handwrite = 4
     */
    handwrite: boolean;
}
/**
 * @generated from protobuf message pdf.GetDrawNoteAnnotationListByNoteIdResponse
 */
export interface GetDrawNoteAnnotationListByNoteIdResponse {
    /**
     * @generated from protobuf field: repeated note.WebNoteAnnotationModel annotations = 1
     */
    annotations: WebNoteAnnotationModel[];
}
/**
 * @api_path: /api/pdf/pdfMark/v2/web/hotSelect
 * @method: GET
 * @content-type: application/json
 * @summary: 获取热选笔记标注列表
 *
 * @generated from protobuf message pdf.HotSelectRequest
 */
export interface HotSelectRequest {
    /**
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
}
/**
 * @generated from protobuf message pdf.HotSelectResponse
 */
export interface HotSelectResponse {
    /**
     * @generated from protobuf field: repeated note.WebNoteAnnotationModel annotations = 1
     */
    annotations: WebNoteAnnotationModel[];
}
/**
 * *
 * @api_path: /api/pdf/pdfMark/v2/web/getMyNoteMarkList
 * @method: POST
 * @content-type: application/json
 * @summary: 查询我的笔记列表
 *
 * @generated from protobuf message pdf.GetMyNoteMarkListReq
 */
export interface GetMyNoteMarkListReq {
    /**
     * 文件夹id
     *
     * @generated from protobuf field: optional string folderId = 1
     */
    folderId?: string;
    /**
     * 标签id
     *
     * @generated from protobuf field: repeated string tagIdList = 2
     */
    tagIdList: string[];
    /**
     * 排序
     *
     * @generated from protobuf field: pdf.SortTypeEnum sortType = 3
     */
    sortType: SortTypeEnum;
    /**
     * @generated from protobuf field: int32 currentPage = 4
     */
    currentPage: number;
    /**
     * @generated from protobuf field: int32 pageSize = 5
     */
    pageSize: number;
    /**
     * 搜索内容
     *
     * @generated from protobuf field: string searchContent = 6
     */
    searchContent: string;
    /**
     * 显示规则
     *
     * @generated from protobuf field: repeated uint32 styleIdList = 7
     */
    styleIdList: number[];
    /**
     * 文献id
     *
     * @generated from protobuf field: optional string docId = 8
     */
    docId?: string;
}
/**
 * *
 * @api_path: /api/pdf/pdfMark/v2/web/getMyNoteMarkList
 * @method: POST
 * @content-type: application/json
 * @summary: 查询我的笔记列表
 *
 * @generated from protobuf message pdf.GetMyNoteMarkListResponse
 */
export interface GetMyNoteMarkListResponse {
    /**
     * 笔记内容
     *
     * @generated from protobuf field: repeated note.WebNoteAnnotationModel annotationModelList = 1
     */
    annotationModelList: WebNoteAnnotationModel[];
    /**
     * @generated from protobuf field: int32 total = 2
     */
    total: number;
}
/**
 * @api_path: /api/pdf/pdfMark/v2/web/save
 * @method post
 * @summary 保存标注笔记
 *
 * @generated from protobuf message pdf.SavePdfMarkRequest
 */
export interface SavePdfMarkRequest {
    /**
     * @generated from protobuf field: string noteId = 1
     */
    noteId: string;
    /**
     * @generated from protobuf field: string groupId = 2
     */
    groupId: string;
    /**
     * @generated from protobuf field: bool handtext = 3
     */
    handtext: boolean;
}
/**
 * @generated from protobuf message pdf.SavePdfMarkResponse
 */
export interface SavePdfMarkResponse {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
}
/**
 * @api_path: /api/pdf/pdfMark/v2/web/update
 * @method post
 * @summary 更新标注笔记
 *
 * @generated from protobuf message pdf.UpdatePdfMarkRequest
 */
export interface UpdatePdfMarkRequest {
}
/**
 * @generated from protobuf message pdf.UpdatePdfMarkResponse
 */
export interface UpdatePdfMarkResponse {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
}
/**
 * @generated from protobuf enum pdf.SortTypeEnum
 */
export enum SortTypeEnum {
    /**
     * 最新
     *
     * @generated from protobuf enum value: NEWEST = 0;
     */
    NEWEST = 0,
    /**
     * 最早
     *
     * @generated from protobuf enum value: EARLIEST = 1;
     */
    EARLIEST = 1,
    /**
     * 默认排序: 列表时：按文献最近阅读倒序，搜索时：按搜索匹配度
     *
     * 改为 SORT_DEFAULT
     *
     * @generated from protobuf enum value: SORT_DEFAULT = 2;
     */
    SORT_DEFAULT = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class GetNoteAnnotationListByNoteIdRequest$Type extends MessageType<GetNoteAnnotationListByNoteIdRequest> {
    constructor() {
        super("pdf.GetNoteAnnotationListByNoteIdRequest", [
            { no: 1, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "groupId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "handtext", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetNoteAnnotationListByNoteIdRequest>): GetNoteAnnotationListByNoteIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        message.groupId = "";
        message.handtext = false;
        if (value !== undefined)
            reflectionMergePartial<GetNoteAnnotationListByNoteIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNoteAnnotationListByNoteIdRequest): GetNoteAnnotationListByNoteIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string noteId */ 1:
                    message.noteId = reader.string();
                    break;
                case /* string groupId */ 2:
                    message.groupId = reader.string();
                    break;
                case /* bool handtext */ 3:
                    message.handtext = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNoteAnnotationListByNoteIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string noteId = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        /* string groupId = 2; */
        if (message.groupId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.groupId);
        /* bool handtext = 3; */
        if (message.handtext !== false)
            writer.tag(3, WireType.Varint).bool(message.handtext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetNoteAnnotationListByNoteIdRequest
 */
export const GetNoteAnnotationListByNoteIdRequest = new GetNoteAnnotationListByNoteIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNoteAnnotationListByNoteIdResponse$Type extends MessageType<GetNoteAnnotationListByNoteIdResponse> {
    constructor() {
        super("pdf.GetNoteAnnotationListByNoteIdResponse", [
            { no: 1, name: "annotations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WebNoteAnnotationModel }
        ]);
    }
    create(value?: PartialMessage<GetNoteAnnotationListByNoteIdResponse>): GetNoteAnnotationListByNoteIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.annotations = [];
        if (value !== undefined)
            reflectionMergePartial<GetNoteAnnotationListByNoteIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetNoteAnnotationListByNoteIdResponse): GetNoteAnnotationListByNoteIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated note.WebNoteAnnotationModel annotations */ 1:
                    message.annotations.push(WebNoteAnnotationModel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetNoteAnnotationListByNoteIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated note.WebNoteAnnotationModel annotations = 1; */
        for (let i = 0; i < message.annotations.length; i++)
            WebNoteAnnotationModel.internalBinaryWrite(message.annotations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetNoteAnnotationListByNoteIdResponse
 */
export const GetNoteAnnotationListByNoteIdResponse = new GetNoteAnnotationListByNoteIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDrawNoteAnnotationListByNoteIdRequest$Type extends MessageType<GetDrawNoteAnnotationListByNoteIdRequest> {
    constructor() {
        super("pdf.GetDrawNoteAnnotationListByNoteIdRequest", [
            { no: 1, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "groupId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fetchAll", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "handwrite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetDrawNoteAnnotationListByNoteIdRequest>): GetDrawNoteAnnotationListByNoteIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        message.groupId = "";
        message.fetchAll = false;
        message.handwrite = false;
        if (value !== undefined)
            reflectionMergePartial<GetDrawNoteAnnotationListByNoteIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDrawNoteAnnotationListByNoteIdRequest): GetDrawNoteAnnotationListByNoteIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string noteId */ 1:
                    message.noteId = reader.string();
                    break;
                case /* string groupId */ 2:
                    message.groupId = reader.string();
                    break;
                case /* bool fetchAll */ 3:
                    message.fetchAll = reader.bool();
                    break;
                case /* bool handwrite */ 4:
                    message.handwrite = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDrawNoteAnnotationListByNoteIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string noteId = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        /* string groupId = 2; */
        if (message.groupId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.groupId);
        /* bool fetchAll = 3; */
        if (message.fetchAll !== false)
            writer.tag(3, WireType.Varint).bool(message.fetchAll);
        /* bool handwrite = 4; */
        if (message.handwrite !== false)
            writer.tag(4, WireType.Varint).bool(message.handwrite);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetDrawNoteAnnotationListByNoteIdRequest
 */
export const GetDrawNoteAnnotationListByNoteIdRequest = new GetDrawNoteAnnotationListByNoteIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDrawNoteAnnotationListByNoteIdResponse$Type extends MessageType<GetDrawNoteAnnotationListByNoteIdResponse> {
    constructor() {
        super("pdf.GetDrawNoteAnnotationListByNoteIdResponse", [
            { no: 1, name: "annotations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WebNoteAnnotationModel }
        ]);
    }
    create(value?: PartialMessage<GetDrawNoteAnnotationListByNoteIdResponse>): GetDrawNoteAnnotationListByNoteIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.annotations = [];
        if (value !== undefined)
            reflectionMergePartial<GetDrawNoteAnnotationListByNoteIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDrawNoteAnnotationListByNoteIdResponse): GetDrawNoteAnnotationListByNoteIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated note.WebNoteAnnotationModel annotations */ 1:
                    message.annotations.push(WebNoteAnnotationModel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDrawNoteAnnotationListByNoteIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated note.WebNoteAnnotationModel annotations = 1; */
        for (let i = 0; i < message.annotations.length; i++)
            WebNoteAnnotationModel.internalBinaryWrite(message.annotations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetDrawNoteAnnotationListByNoteIdResponse
 */
export const GetDrawNoteAnnotationListByNoteIdResponse = new GetDrawNoteAnnotationListByNoteIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HotSelectRequest$Type extends MessageType<HotSelectRequest> {
    constructor() {
        super("pdf.HotSelectRequest", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HotSelectRequest>): HotSelectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<HotSelectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HotSelectRequest): HotSelectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HotSelectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.HotSelectRequest
 */
export const HotSelectRequest = new HotSelectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HotSelectResponse$Type extends MessageType<HotSelectResponse> {
    constructor() {
        super("pdf.HotSelectResponse", [
            { no: 1, name: "annotations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WebNoteAnnotationModel }
        ]);
    }
    create(value?: PartialMessage<HotSelectResponse>): HotSelectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.annotations = [];
        if (value !== undefined)
            reflectionMergePartial<HotSelectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HotSelectResponse): HotSelectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated note.WebNoteAnnotationModel annotations */ 1:
                    message.annotations.push(WebNoteAnnotationModel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HotSelectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated note.WebNoteAnnotationModel annotations = 1; */
        for (let i = 0; i < message.annotations.length; i++)
            WebNoteAnnotationModel.internalBinaryWrite(message.annotations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.HotSelectResponse
 */
export const HotSelectResponse = new HotSelectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMyNoteMarkListReq$Type extends MessageType<GetMyNoteMarkListReq> {
    constructor() {
        super("pdf.GetMyNoteMarkListReq", [
            { no: 1, name: "folderId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tagIdList", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sortType", kind: "enum", T: () => ["pdf.SortTypeEnum", SortTypeEnum] },
            { no: 4, name: "currentPage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "pageSize", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "searchContent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "styleIdList", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "docId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMyNoteMarkListReq>): GetMyNoteMarkListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagIdList = [];
        message.sortType = 0;
        message.currentPage = 0;
        message.pageSize = 0;
        message.searchContent = "";
        message.styleIdList = [];
        if (value !== undefined)
            reflectionMergePartial<GetMyNoteMarkListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMyNoteMarkListReq): GetMyNoteMarkListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* repeated string tagIdList */ 2:
                    message.tagIdList.push(reader.string());
                    break;
                case /* pdf.SortTypeEnum sortType */ 3:
                    message.sortType = reader.int32();
                    break;
                case /* int32 currentPage */ 4:
                    message.currentPage = reader.int32();
                    break;
                case /* int32 pageSize */ 5:
                    message.pageSize = reader.int32();
                    break;
                case /* string searchContent */ 6:
                    message.searchContent = reader.string();
                    break;
                case /* repeated uint32 styleIdList */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.styleIdList.push(reader.uint32());
                    else
                        message.styleIdList.push(reader.uint32());
                    break;
                case /* optional string docId */ 8:
                    message.docId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMyNoteMarkListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string folderId = 1; */
        if (message.folderId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* repeated string tagIdList = 2; */
        for (let i = 0; i < message.tagIdList.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.tagIdList[i]);
        /* pdf.SortTypeEnum sortType = 3; */
        if (message.sortType !== 0)
            writer.tag(3, WireType.Varint).int32(message.sortType);
        /* int32 currentPage = 4; */
        if (message.currentPage !== 0)
            writer.tag(4, WireType.Varint).int32(message.currentPage);
        /* int32 pageSize = 5; */
        if (message.pageSize !== 0)
            writer.tag(5, WireType.Varint).int32(message.pageSize);
        /* string searchContent = 6; */
        if (message.searchContent !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.searchContent);
        /* repeated uint32 styleIdList = 7; */
        if (message.styleIdList.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.styleIdList.length; i++)
                writer.uint32(message.styleIdList[i]);
            writer.join();
        }
        /* optional string docId = 8; */
        if (message.docId !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.docId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetMyNoteMarkListReq
 */
export const GetMyNoteMarkListReq = new GetMyNoteMarkListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMyNoteMarkListResponse$Type extends MessageType<GetMyNoteMarkListResponse> {
    constructor() {
        super("pdf.GetMyNoteMarkListResponse", [
            { no: 1, name: "annotationModelList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WebNoteAnnotationModel },
            { no: 2, name: "total", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetMyNoteMarkListResponse>): GetMyNoteMarkListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.annotationModelList = [];
        message.total = 0;
        if (value !== undefined)
            reflectionMergePartial<GetMyNoteMarkListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMyNoteMarkListResponse): GetMyNoteMarkListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated note.WebNoteAnnotationModel annotationModelList */ 1:
                    message.annotationModelList.push(WebNoteAnnotationModel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total */ 2:
                    message.total = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMyNoteMarkListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated note.WebNoteAnnotationModel annotationModelList = 1; */
        for (let i = 0; i < message.annotationModelList.length; i++)
            WebNoteAnnotationModel.internalBinaryWrite(message.annotationModelList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total = 2; */
        if (message.total !== 0)
            writer.tag(2, WireType.Varint).int32(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetMyNoteMarkListResponse
 */
export const GetMyNoteMarkListResponse = new GetMyNoteMarkListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SavePdfMarkRequest$Type extends MessageType<SavePdfMarkRequest> {
    constructor() {
        super("pdf.SavePdfMarkRequest", [
            { no: 1, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "groupId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "handtext", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SavePdfMarkRequest>): SavePdfMarkRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        message.groupId = "";
        message.handtext = false;
        if (value !== undefined)
            reflectionMergePartial<SavePdfMarkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SavePdfMarkRequest): SavePdfMarkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string noteId */ 1:
                    message.noteId = reader.string();
                    break;
                case /* string groupId */ 2:
                    message.groupId = reader.string();
                    break;
                case /* bool handtext */ 3:
                    message.handtext = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SavePdfMarkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string noteId = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        /* string groupId = 2; */
        if (message.groupId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.groupId);
        /* bool handtext = 3; */
        if (message.handtext !== false)
            writer.tag(3, WireType.Varint).bool(message.handtext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.SavePdfMarkRequest
 */
export const SavePdfMarkRequest = new SavePdfMarkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SavePdfMarkResponse$Type extends MessageType<SavePdfMarkResponse> {
    constructor() {
        super("pdf.SavePdfMarkResponse", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SavePdfMarkResponse>): SavePdfMarkResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<SavePdfMarkResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SavePdfMarkResponse): SavePdfMarkResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SavePdfMarkResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.SavePdfMarkResponse
 */
export const SavePdfMarkResponse = new SavePdfMarkResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePdfMarkRequest$Type extends MessageType<UpdatePdfMarkRequest> {
    constructor() {
        super("pdf.UpdatePdfMarkRequest", []);
    }
    create(value?: PartialMessage<UpdatePdfMarkRequest>): UpdatePdfMarkRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdatePdfMarkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePdfMarkRequest): UpdatePdfMarkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePdfMarkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.UpdatePdfMarkRequest
 */
export const UpdatePdfMarkRequest = new UpdatePdfMarkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePdfMarkResponse$Type extends MessageType<UpdatePdfMarkResponse> {
    constructor() {
        super("pdf.UpdatePdfMarkResponse", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePdfMarkResponse>): UpdatePdfMarkResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<UpdatePdfMarkResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePdfMarkResponse): UpdatePdfMarkResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePdfMarkResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.UpdatePdfMarkResponse
 */
export const UpdatePdfMarkResponse = new UpdatePdfMarkResponse$Type();
