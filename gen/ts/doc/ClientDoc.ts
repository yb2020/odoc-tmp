// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/doc/ClientDoc.proto" (package "doc", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UserDocParsedStatusEnum } from "./UserDocParsedStatus";
import { ChangeSortItem } from "./UserDocPublic";
/**
 * *
 * 获取用户的一级文件夹列表
 * url: /client/doc/getTopLevelFolderList
 *
 * @generated from protobuf message doc.GetTopLevelFolderListReq
 */
export interface GetTopLevelFolderListReq {
    /**
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string;
}
/**
 * @generated from protobuf message doc.GetTopLevelFolderListResponse
 */
export interface GetTopLevelFolderListResponse {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: repeated doc.SimpleFolderInfo data = 3
     */
    data: SimpleFolderInfo[];
}
/**
 * *
 * 将论文添加到文件夹
 * url: /client/doc/attachPaperToFolder
 *
 * @generated from protobuf message doc.AttachPaperToFolderReq
 */
export interface AttachPaperToFolderReq {
    /**
     * 论文id
     *
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string;
    /**
     * 文件夹id
     *
     * @generated from protobuf field: string folderId = 2
     */
    folderId: string;
}
/**
 * @generated from protobuf message doc.AttachPaperToFolderResponse
 */
export interface AttachPaperToFolderResponse {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: string docId = 3
     */
    docId: string;
}
/**
 * *
 * 将文从文件夹移除
 * url: /client/doc/removeDocFromFolder
 *
 * @generated from protobuf message doc.RemoveDocFromFolderReq
 */
export interface RemoveDocFromFolderReq {
    /**
     * @generated from protobuf field: repeated doc.RemovedDocItem removedDocItems = 1
     */
    removedDocItems: RemovedDocItem[];
    /**
     * @generated from protobuf field: bool isHierarchicallyRemove = 3
     */
    isHierarchicallyRemove: boolean;
}
/**
 * @generated from protobuf message doc.RemovedDocItem
 */
export interface RemovedDocItem {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string folderId = 2
     */
    folderId: string;
}
/**
 * *
 * 复制文献&文件夹到另外一个文件夹
 * url: /client/doc/copyDocOrFolderToAnotherFolder
 *
 * @generated from protobuf message doc.CopyDocOrFolderToAnotherFolderReq
 */
export interface CopyDocOrFolderToAnotherFolderReq {
    /**
     * @generated from protobuf field: repeated string docIds = 1
     */
    docIds: string[];
    /**
     * @generated from protobuf field: repeated string folderIds = 2
     */
    folderIds: string[];
    /**
     * @generated from protobuf field: string targetFolderId = 3
     */
    targetFolderId: string;
}
/**
 * *
 * 添加文件夹
 * url: /client/doc/attachDocToFolder
 *
 * @generated from protobuf message doc.AttachDocToFolderReq
 */
export interface AttachDocToFolderReq {
    /**
     * 文献id
     *
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * 文件夹id
     *
     * @generated from protobuf field: string folderId = 2
     */
    folderId: string;
}
/**
 * *
 * 重命名文献
 * url: /userDoc/renameUserDoc
 *
 * @generated from protobuf message doc.RenameUserDocReq
 */
export interface RenameUserDocReq {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
}
/**
 * *
 * 添加文件夹
 * url: /client/doc/addFolder
 *
 * @generated from protobuf message doc.AddFolderReq
 */
export interface AddFolderReq {
    /**
     * 父文件夹id
     *
     * @generated from protobuf field: string parentId = 1
     */
    parentId: string;
    /**
     * 文件夹名称
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * 文件夹层级,从0开始
     *
     * @generated from protobuf field: uint32 level = 3
     */
    level: number;
    /**
     * 文件夹排序
     *
     * @generated from protobuf field: uint32 sort = 4
     */
    sort: number;
    /**
     * 该层级其他文件夹的id及排序
     *
     * @generated from protobuf field: repeated doc.ChangeSortItem oldFolderItems = 5
     */
    oldFolderItems: ChangeSortItem[];
}
/**
 * @generated from protobuf message doc.AddFolderResponse
 */
export interface AddFolderResponse {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: repeated doc.FolderInfo data = 3
     */
    data: FolderInfo[];
}
/**
 * @generated from protobuf message doc.FolderInfo
 */
export interface FolderInfo {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string remark = 3
     */
    remark: string;
}
/**
 * *
 * 删除文件夹
 * url: /client/doc/deleteDoc
 *
 * @generated from protobuf message doc.DeleteDocReq
 */
export interface DeleteDocReq {
    /**
     * @generated from protobuf field: repeated string docIds = 1
     */
    docIds: string[];
}
/**
 * *
 * 删除文件夹
 * url: /client/doc/deleteFolder
 *
 * @generated from protobuf message doc.DeleteFolderReq
 */
export interface DeleteFolderReq {
    /**
     * @generated from protobuf field: repeated string folderIds = 1
     */
    folderIds: string[];
}
/**
 * *
 * 更新文件夹备注
 * url: /client/doc/updateFolderRemark
 *
 * @generated from protobuf message doc.UpdateFolderRemarkReq
 */
export interface UpdateFolderRemarkReq {
    /**
     * @generated from protobuf field: string folderId = 1
     */
    folderId: string;
    /**
     * @generated from protobuf field: string remark = 2
     */
    remark: string;
}
/**
 * *
 * 更新文件夹
 * url: /client/doc/updateFolder
 *
 * @generated from protobuf message doc.UpdateFolderReq
 */
export interface UpdateFolderReq {
    /**
     * @generated from protobuf field: string folderId = 1
     */
    folderId: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * *
 * 移动文件夹或者文献
 * url: /client/doc/moveFolderOrDoc
 *
 * @generated from protobuf message doc.MoveFolderOrDocReq
 */
export interface MoveFolderOrDocReq {
    /**
     * 类型:0=文献,1=文件夹
     *
     * @generated from protobuf field: uint32 type = 1
     */
    type: number;
    /**
     * 起始文件夹
     *
     * @generated from protobuf field: string sourceFolderId = 2
     */
    sourceFolderId: string;
    /**
     * 目标文件夹
     *
     * @generated from protobuf field: string targetFolderId = 3
     */
    targetFolderId: string;
    /**
     * 要移动的id列表,文件夹时为文件夹id,文献时则为文献id
     *
     * @generated from protobuf field: repeated string movedIds = 4
     */
    movedIds: string[];
    /**
     * 目标位置的所有(文献/文件夹)排序
     *
     * @generated from protobuf field: repeated doc.ChangeSortItem targetFolderItems = 5
     */
    targetFolderItems: ChangeSortItem[];
}
/**
 * *
 * 根据folderId获取文献列表
 * url: /client/doc/getDocListByFolderId
 *
 * @generated from protobuf message doc.GetDocListByFolderIdReq
 */
export interface GetDocListByFolderIdReq {
    /**
     * @generated from protobuf field: string folderId = 1
     */
    folderId: string;
    /**
     * 排序方式,0=最近添加,1=最近阅读,2=自定义排序
     *
     * @generated from protobuf field: uint32 sortType = 2
     */
    sortType: number;
}
/**
 * @generated from protobuf message doc.GetDocListByFolderIdResponse
 */
export interface GetDocListByFolderIdResponse {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: repeated doc.DocDetailInfo data = 3
     */
    data: DocDetailInfo[];
}
/**
 * *
 * 根据folderId获取文献列表
 * url: /client/doc/getDocListByFolderIdForPage
 *
 * @generated from protobuf message doc.GetDocListByFolderIdForPageReq
 */
export interface GetDocListByFolderIdForPageReq {
    /**
     * @generated from protobuf field: string folderId = 1
     */
    folderId: string;
    /**
     * @generated from protobuf field: uint32 currentPage = 2
     */
    currentPage: number;
    /**
     * @generated from protobuf field: uint32 pageSize = 3
     */
    pageSize: number;
    /**
     * @generated from protobuf field: optional uint32 sortType = 4
     */
    sortType?: number;
    /**
     * @generated from protobuf field: repeated string tagIds = 5
     */
    tagIds: string[];
}
/**
 * @generated from protobuf message doc.GetDocListByFolderIdForPageResponse
 */
export interface GetDocListByFolderIdForPageResponse {
    /**
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
    /**
     * @generated from protobuf field: repeated doc.DocDetailInfo listDocDetailInfo = 2
     */
    listDocDetailInfo: DocDetailInfo[];
    /**
     * @generated from protobuf field: repeated doc.DocDetailInfoForPage list = 3
     */
    list: DocDetailInfoForPage[];
}
/**
 * @generated from protobuf message doc.DocDetailInfoForPage
 */
export interface DocDetailInfoForPage {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
    /**
     * @generated from protobuf field: uint32 sort = 3
     */
    sort: number;
    /**
     * @generated from protobuf field: string paperId = 4
     */
    paperId: string;
    /**
     * @generated from protobuf field: string pdfId = 5
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string remark = 6
     */
    remark: string;
    /**
     * @generated from protobuf field: uint64 publishDate = 7
     */
    publishDate: bigint;
    /**
     * @generated from protobuf field: uint64 createDate = 8
     */
    createDate: bigint;
    /**
     * @generated from protobuf field: uint64 lastReadTime = 9
     */
    lastReadTime: bigint;
    /**
     * @generated from protobuf field: bool isLatestRead = 10
     */
    isLatestRead: boolean;
    /**
     * @generated from protobuf field: repeated doc.DocClassifyInfo classifyInfos = 14
     */
    classifyInfos: DocClassifyInfo[];
    /**
     * @generated from protobuf field: string paperRepositoryStatus = 15
     */
    paperRepositoryStatus: string;
    /**
     * 期刊会议(新)
     *
     * @generated from protobuf field: repeated string containerTitles = 16
     */
    containerTitles: string[];
    /**
     * @generated from protobuf field: optional string page = 17
     */
    page?: string;
    /**
     * @generated from protobuf field: int64 noteId = 18
     */
    noteId: bigint;
    /**
     * @generated from protobuf field: doc.DisplayVenue displayVenue = 19
     */
    displayVenue?: DisplayVenue;
    /**
     * @generated from protobuf field: doc.DisplayAuthor displayAuthor = 20
     */
    displayAuthor?: DisplayAuthor;
    /**
     * @generated from protobuf field: doc.DisplayPublishDate displayPublishDate = 21
     */
    displayPublishDate?: DisplayPublishDate;
    /**
     * @generated from protobuf field: string paperTitle = 22
     */
    paperTitle: string;
    /**
     * @generated from protobuf field: string docType = 23
     */
    docType: string;
    /**
     * @generated from protobuf field: repeated doc.AuthorInfoForPage authorList = 24
     */
    authorList: AuthorInfoForPage[];
    /**
     * @generated from protobuf field: optional string eventTitle = 25
     */
    eventTitle?: string;
    /**
     * @generated from protobuf field: optional string eventPlace = 26
     */
    eventPlace?: string;
    /**
     * @generated from protobuf field: repeated string eventDate = 27
     */
    eventDate: string[];
    /**
     * @generated from protobuf field: optional string doi = 28
     */
    doi?: string;
    /**
     * @generated from protobuf field: optional string volume = 29
     */
    volume?: string;
    /**
     * @generated from protobuf field: optional string issue = 30
     */
    issue?: string;
    /**
     * @generated from protobuf field: optional string url = 31
     */
    url?: string;
    /**
     * @generated from protobuf field: optional string language = 32
     */
    language?: string;
}
/**
 * @generated from protobuf message doc.AuthorInfoForPage
 */
export interface AuthorInfoForPage {
    /**
     * @generated from protobuf field: string given = 1
     */
    given: string;
    /**
     * @generated from protobuf field: string family = 2
     */
    family: string;
    /**
     * @generated from protobuf field: string literal = 3
     */
    literal: string;
}
/**
 * @generated from protobuf message doc.DocDetailInfo
 */
export interface DocDetailInfo {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
    /**
     * @generated from protobuf field: uint32 sort = 3
     */
    sort: number;
    /**
     * @generated from protobuf field: string paperId = 4
     */
    paperId: string;
    /**
     * @generated from protobuf field: string pdfId = 5
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string remark = 6
     */
    remark: string;
    /**
     * @generated from protobuf field: uint64 publishDate = 7
     */
    publishDate: bigint;
    /**
     * @generated from protobuf field: uint64 createDate = 8
     */
    createDate: bigint;
    /**
     * @generated from protobuf field: uint64 lastReadTime = 9
     */
    lastReadTime: bigint;
    /**
     * @generated from protobuf field: bool isLatestRead = 10
     */
    isLatestRead: boolean;
    /**
     * @generated from protobuf field: repeated string authors = 13
     */
    authors: string[];
    /**
     * @generated from protobuf field: repeated doc.DocClassifyInfo classifyInfos = 14
     */
    classifyInfos: DocClassifyInfo[];
    /**
     * @generated from protobuf field: string paperRepositoryStatus = 15
     */
    paperRepositoryStatus: string;
    /**
     * 期刊会议(新)
     *
     * @generated from protobuf field: repeated string venues = 16
     */
    venues: string[];
    /**
     * @generated from protobuf field: string primaryVenue = 17
     */
    primaryVenue: string;
    /**
     * @generated from protobuf field: int64 noteId = 18
     */
    noteId: bigint;
    /**
     * @generated from protobuf field: doc.DisplayVenue displayVenue = 19
     */
    displayVenue?: DisplayVenue;
    /**
     * @generated from protobuf field: doc.DisplayAuthor displayAuthor = 20
     */
    displayAuthor?: DisplayAuthor;
    /**
     * @generated from protobuf field: doc.DisplayPublishDate displayPublishDate = 21
     */
    displayPublishDate?: DisplayPublishDate;
    /**
     * @generated from protobuf field: optional string language = 22
     */
    language?: string;
    /**
     * @generated from protobuf field: bool newPaper = 23
     */
    newPaper: boolean;
    /**
     * 分区信息
     *
     * @generated from protobuf field: optional string partition = 24
     */
    partition?: string;
    /**
     * 状态
     *
     * @generated from protobuf field: doc.UserDocParsedStatusEnum parsedStatus = 25
     */
    parsedStatus: UserDocParsedStatusEnum;
    /**
     * Embedding状态
     *
     * @generated from protobuf field: doc.UserDocParsedStatusEnum embeddingStatus = 26
     */
    embeddingStatus: UserDocParsedStatusEnum;
}
/**
 * @generated from protobuf message doc.DocClassifyInfo
 */
export interface DocClassifyInfo {
    /**
     * @generated from protobuf field: string classifyId = 1
     */
    classifyId: string;
    /**
     * @generated from protobuf field: string classifyName = 2
     */
    classifyName: string;
}
/**
 * @generated from protobuf message doc.DisplayVenue
 */
export interface DisplayVenue {
    /**
     * @generated from protobuf field: string venue = 1
     */
    venue: string;
    /**
     * @generated from protobuf field: bool rollbackEnable = 2
     */
    rollbackEnable: boolean;
    /**
     * @generated from protobuf field: string originVenue = 3
     */
    originVenue: string;
}
/**
 * @generated from protobuf message doc.DisplayAuthor
 */
export interface DisplayAuthor {
    /**
     * @generated from protobuf field: repeated string authors = 1
     */
    authors: string[];
    /**
     * @generated from protobuf field: bool rollbackEnable = 2
     */
    rollbackEnable: boolean;
    /**
     * @generated from protobuf field: repeated string originAuthors = 3
     */
    originAuthors: string[];
}
/**
 * @generated from protobuf message doc.DisplayPublishDate
 */
export interface DisplayPublishDate {
    /**
     * @generated from protobuf field: string publishDate = 1
     */
    publishDate: string;
    /**
     * @generated from protobuf field: bool rollbackEnable = 2
     */
    rollbackEnable: boolean;
    /**
     * @generated from protobuf field: string originPublishDate = 3
     */
    originPublishDate: string;
}
/**
 * *
 * 客户端文献首页-获取文件夹列表和文献列表
 * url: /client/doc/getFolderTreeAndSimpleDocInfoList
 *
 * @generated from protobuf message doc.GetFolderTreeAndSimpleDocInfoListReq
 */
export interface GetFolderTreeAndSimpleDocInfoListReq {
}
/**
 * @generated from protobuf message doc.GetFolderTreeAndSimpleDocInfoListResponse
 */
export interface GetFolderTreeAndSimpleDocInfoListResponse {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: doc.IndexFolderAndDocContent data = 3
     */
    data?: IndexFolderAndDocContent;
}
/**
 * @generated from protobuf message doc.IndexFolderAndDocContent
 */
export interface IndexFolderAndDocContent {
    /**
     * @generated from protobuf field: uint32 totalDocCount = 1
     */
    totalDocCount: number;
    /**
     * @generated from protobuf field: repeated doc.SimpleFolderInfo folderInfos = 2
     */
    folderInfos: SimpleFolderInfo[];
    /**
     * @generated from protobuf field: repeated doc.SimpleDocInfo unclassifiedDocInfos = 3
     */
    unclassifiedDocInfos: SimpleDocInfo[];
}
/**
 * @generated from protobuf message doc.SimpleFolderInfo
 */
export interface SimpleFolderInfo {
    /**
     * 文件夹名
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * 文献数
     *
     * @generated from protobuf field: uint32 docCount = 2
     */
    docCount: number;
    /**
     * 父文件夹id
     *
     * @generated from protobuf field: string parentId = 3
     */
    parentId: string;
    /**
     * 文件夹id
     *
     * @generated from protobuf field: string folderId = 4
     */
    folderId: string;
    /**
     * 文件夹层级
     *
     * @generated from protobuf field: uint32 level = 5
     */
    level: number;
    /**
     * 文件夹排序
     *
     * @generated from protobuf field: uint32 sort = 6
     */
    sort: number;
    /**
     * 子文件夹
     *
     * @generated from protobuf field: repeated doc.SimpleFolderInfo childrenFolders = 7
     */
    childrenFolders: SimpleFolderInfo[];
    /**
     * 文献信息
     *
     * @generated from protobuf field: repeated doc.SimpleDocInfo docInfos = 8
     */
    docInfos: SimpleDocInfo[];
    /**
     * @generated from protobuf field: bool isContainCurrentPaper = 9
     */
    isContainCurrentPaper: boolean;
    /**
     * @generated from protobuf field: string docId = 10
     */
    docId: string;
}
/**
 * @generated from protobuf message doc.SimpleDocInfo
 */
export interface SimpleDocInfo {
    /**
     * 排序
     *
     * @generated from protobuf field: uint32 sort = 1
     */
    sort: number;
    /**
     * 文献名
     *
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
    /**
     * 文献id
     *
     * @generated from protobuf field: string docId = 3
     */
    docId: string;
    /**
     * @generated from protobuf field: string pdfId = 4
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string paperId = 5
     */
    paperId: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetTopLevelFolderListReq$Type extends MessageType<GetTopLevelFolderListReq> {
    constructor() {
        super("doc.GetTopLevelFolderListReq", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTopLevelFolderListReq>): GetTopLevelFolderListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        if (value !== undefined)
            reflectionMergePartial<GetTopLevelFolderListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTopLevelFolderListReq): GetTopLevelFolderListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTopLevelFolderListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetTopLevelFolderListReq
 */
export const GetTopLevelFolderListReq = new GetTopLevelFolderListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTopLevelFolderListResponse$Type extends MessageType<GetTopLevelFolderListResponse> {
    constructor() {
        super("doc.GetTopLevelFolderListResponse", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SimpleFolderInfo }
        ]);
    }
    create(value?: PartialMessage<GetTopLevelFolderListResponse>): GetTopLevelFolderListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.message = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetTopLevelFolderListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTopLevelFolderListResponse): GetTopLevelFolderListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* repeated doc.SimpleFolderInfo data */ 3:
                    message.data.push(SimpleFolderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTopLevelFolderListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated doc.SimpleFolderInfo data = 3; */
        for (let i = 0; i < message.data.length; i++)
            SimpleFolderInfo.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetTopLevelFolderListResponse
 */
export const GetTopLevelFolderListResponse = new GetTopLevelFolderListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachPaperToFolderReq$Type extends MessageType<AttachPaperToFolderReq> {
    constructor() {
        super("doc.AttachPaperToFolderReq", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttachPaperToFolderReq>): AttachPaperToFolderReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        message.folderId = "";
        if (value !== undefined)
            reflectionMergePartial<AttachPaperToFolderReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachPaperToFolderReq): AttachPaperToFolderReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string folderId */ 2:
                    message.folderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachPaperToFolderReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string folderId = 2; */
        if (message.folderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.folderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AttachPaperToFolderReq
 */
export const AttachPaperToFolderReq = new AttachPaperToFolderReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachPaperToFolderResponse$Type extends MessageType<AttachPaperToFolderResponse> {
    constructor() {
        super("doc.AttachPaperToFolderResponse", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttachPaperToFolderResponse>): AttachPaperToFolderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.message = "";
        message.docId = "";
        if (value !== undefined)
            reflectionMergePartial<AttachPaperToFolderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachPaperToFolderResponse): AttachPaperToFolderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* string docId */ 3:
                    message.docId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachPaperToFolderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* string docId = 3; */
        if (message.docId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.docId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AttachPaperToFolderResponse
 */
export const AttachPaperToFolderResponse = new AttachPaperToFolderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveDocFromFolderReq$Type extends MessageType<RemoveDocFromFolderReq> {
    constructor() {
        super("doc.RemoveDocFromFolderReq", [
            { no: 1, name: "removedDocItems", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RemovedDocItem },
            { no: 3, name: "isHierarchicallyRemove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveDocFromFolderReq>): RemoveDocFromFolderReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.removedDocItems = [];
        message.isHierarchicallyRemove = false;
        if (value !== undefined)
            reflectionMergePartial<RemoveDocFromFolderReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveDocFromFolderReq): RemoveDocFromFolderReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated doc.RemovedDocItem removedDocItems */ 1:
                    message.removedDocItems.push(RemovedDocItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool isHierarchicallyRemove */ 3:
                    message.isHierarchicallyRemove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveDocFromFolderReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated doc.RemovedDocItem removedDocItems = 1; */
        for (let i = 0; i < message.removedDocItems.length; i++)
            RemovedDocItem.internalBinaryWrite(message.removedDocItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool isHierarchicallyRemove = 3; */
        if (message.isHierarchicallyRemove !== false)
            writer.tag(3, WireType.Varint).bool(message.isHierarchicallyRemove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.RemoveDocFromFolderReq
 */
export const RemoveDocFromFolderReq = new RemoveDocFromFolderReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemovedDocItem$Type extends MessageType<RemovedDocItem> {
    constructor() {
        super("doc.RemovedDocItem", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemovedDocItem>): RemovedDocItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.folderId = "";
        if (value !== undefined)
            reflectionMergePartial<RemovedDocItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemovedDocItem): RemovedDocItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string folderId */ 2:
                    message.folderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemovedDocItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string folderId = 2; */
        if (message.folderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.folderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.RemovedDocItem
 */
export const RemovedDocItem = new RemovedDocItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyDocOrFolderToAnotherFolderReq$Type extends MessageType<CopyDocOrFolderToAnotherFolderReq> {
    constructor() {
        super("doc.CopyDocOrFolderToAnotherFolderReq", [
            { no: 1, name: "docIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "folderIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "targetFolderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CopyDocOrFolderToAnotherFolderReq>): CopyDocOrFolderToAnotherFolderReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docIds = [];
        message.folderIds = [];
        message.targetFolderId = "";
        if (value !== undefined)
            reflectionMergePartial<CopyDocOrFolderToAnotherFolderReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyDocOrFolderToAnotherFolderReq): CopyDocOrFolderToAnotherFolderReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string docIds */ 1:
                    message.docIds.push(reader.string());
                    break;
                case /* repeated string folderIds */ 2:
                    message.folderIds.push(reader.string());
                    break;
                case /* string targetFolderId */ 3:
                    message.targetFolderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyDocOrFolderToAnotherFolderReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string docIds = 1; */
        for (let i = 0; i < message.docIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.docIds[i]);
        /* repeated string folderIds = 2; */
        for (let i = 0; i < message.folderIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.folderIds[i]);
        /* string targetFolderId = 3; */
        if (message.targetFolderId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetFolderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.CopyDocOrFolderToAnotherFolderReq
 */
export const CopyDocOrFolderToAnotherFolderReq = new CopyDocOrFolderToAnotherFolderReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachDocToFolderReq$Type extends MessageType<AttachDocToFolderReq> {
    constructor() {
        super("doc.AttachDocToFolderReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttachDocToFolderReq>): AttachDocToFolderReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.folderId = "";
        if (value !== undefined)
            reflectionMergePartial<AttachDocToFolderReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachDocToFolderReq): AttachDocToFolderReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string folderId */ 2:
                    message.folderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachDocToFolderReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string folderId = 2; */
        if (message.folderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.folderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AttachDocToFolderReq
 */
export const AttachDocToFolderReq = new AttachDocToFolderReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenameUserDocReq$Type extends MessageType<RenameUserDocReq> {
    constructor() {
        super("doc.RenameUserDocReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RenameUserDocReq>): RenameUserDocReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.docName = "";
        if (value !== undefined)
            reflectionMergePartial<RenameUserDocReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenameUserDocReq): RenameUserDocReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenameUserDocReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.RenameUserDocReq
 */
export const RenameUserDocReq = new RenameUserDocReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddFolderReq$Type extends MessageType<AddFolderReq> {
    constructor() {
        super("doc.AddFolderReq", [
            { no: 1, name: "parentId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "oldFolderItems", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChangeSortItem }
        ]);
    }
    create(value?: PartialMessage<AddFolderReq>): AddFolderReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parentId = "";
        message.name = "";
        message.level = 0;
        message.sort = 0;
        message.oldFolderItems = [];
        if (value !== undefined)
            reflectionMergePartial<AddFolderReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddFolderReq): AddFolderReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parentId */ 1:
                    message.parentId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* uint32 level */ 3:
                    message.level = reader.uint32();
                    break;
                case /* uint32 sort */ 4:
                    message.sort = reader.uint32();
                    break;
                case /* repeated doc.ChangeSortItem oldFolderItems */ 5:
                    message.oldFolderItems.push(ChangeSortItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddFolderReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parentId = 1; */
        if (message.parentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parentId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* uint32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).uint32(message.level);
        /* uint32 sort = 4; */
        if (message.sort !== 0)
            writer.tag(4, WireType.Varint).uint32(message.sort);
        /* repeated doc.ChangeSortItem oldFolderItems = 5; */
        for (let i = 0; i < message.oldFolderItems.length; i++)
            ChangeSortItem.internalBinaryWrite(message.oldFolderItems[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AddFolderReq
 */
export const AddFolderReq = new AddFolderReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddFolderResponse$Type extends MessageType<AddFolderResponse> {
    constructor() {
        super("doc.AddFolderResponse", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FolderInfo }
        ]);
    }
    create(value?: PartialMessage<AddFolderResponse>): AddFolderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.message = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<AddFolderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddFolderResponse): AddFolderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* repeated doc.FolderInfo data */ 3:
                    message.data.push(FolderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddFolderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated doc.FolderInfo data = 3; */
        for (let i = 0; i < message.data.length; i++)
            FolderInfo.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AddFolderResponse
 */
export const AddFolderResponse = new AddFolderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FolderInfo$Type extends MessageType<FolderInfo> {
    constructor() {
        super("doc.FolderInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FolderInfo>): FolderInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.remark = "";
        if (value !== undefined)
            reflectionMergePartial<FolderInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FolderInfo): FolderInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string remark */ 3:
                    message.remark = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FolderInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string remark = 3; */
        if (message.remark !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.remark);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.FolderInfo
 */
export const FolderInfo = new FolderInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocReq$Type extends MessageType<DeleteDocReq> {
    constructor() {
        super("doc.DeleteDocReq", [
            { no: 1, name: "docIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDocReq>): DeleteDocReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docIds = [];
        if (value !== undefined)
            reflectionMergePartial<DeleteDocReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocReq): DeleteDocReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string docIds */ 1:
                    message.docIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDocReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string docIds = 1; */
        for (let i = 0; i < message.docIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.docIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DeleteDocReq
 */
export const DeleteDocReq = new DeleteDocReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFolderReq$Type extends MessageType<DeleteFolderReq> {
    constructor() {
        super("doc.DeleteFolderReq", [
            { no: 1, name: "folderIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteFolderReq>): DeleteFolderReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.folderIds = [];
        if (value !== undefined)
            reflectionMergePartial<DeleteFolderReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteFolderReq): DeleteFolderReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string folderIds */ 1:
                    message.folderIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteFolderReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string folderIds = 1; */
        for (let i = 0; i < message.folderIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.folderIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DeleteFolderReq
 */
export const DeleteFolderReq = new DeleteFolderReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFolderRemarkReq$Type extends MessageType<UpdateFolderRemarkReq> {
    constructor() {
        super("doc.UpdateFolderRemarkReq", [
            { no: 1, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateFolderRemarkReq>): UpdateFolderRemarkReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.folderId = "";
        message.remark = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateFolderRemarkReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateFolderRemarkReq): UpdateFolderRemarkReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* string remark */ 2:
                    message.remark = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateFolderRemarkReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string folderId = 1; */
        if (message.folderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* string remark = 2; */
        if (message.remark !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remark);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateFolderRemarkReq
 */
export const UpdateFolderRemarkReq = new UpdateFolderRemarkReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFolderReq$Type extends MessageType<UpdateFolderReq> {
    constructor() {
        super("doc.UpdateFolderReq", [
            { no: 1, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateFolderReq>): UpdateFolderReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.folderId = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateFolderReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateFolderReq): UpdateFolderReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateFolderReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string folderId = 1; */
        if (message.folderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateFolderReq
 */
export const UpdateFolderReq = new UpdateFolderReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveFolderOrDocReq$Type extends MessageType<MoveFolderOrDocReq> {
    constructor() {
        super("doc.MoveFolderOrDocReq", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "sourceFolderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "targetFolderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "movedIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "targetFolderItems", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChangeSortItem }
        ]);
    }
    create(value?: PartialMessage<MoveFolderOrDocReq>): MoveFolderOrDocReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.sourceFolderId = "";
        message.targetFolderId = "";
        message.movedIds = [];
        message.targetFolderItems = [];
        if (value !== undefined)
            reflectionMergePartial<MoveFolderOrDocReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveFolderOrDocReq): MoveFolderOrDocReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* string sourceFolderId */ 2:
                    message.sourceFolderId = reader.string();
                    break;
                case /* string targetFolderId */ 3:
                    message.targetFolderId = reader.string();
                    break;
                case /* repeated string movedIds */ 4:
                    message.movedIds.push(reader.string());
                    break;
                case /* repeated doc.ChangeSortItem targetFolderItems */ 5:
                    message.targetFolderItems.push(ChangeSortItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveFolderOrDocReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* string sourceFolderId = 2; */
        if (message.sourceFolderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceFolderId);
        /* string targetFolderId = 3; */
        if (message.targetFolderId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetFolderId);
        /* repeated string movedIds = 4; */
        for (let i = 0; i < message.movedIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.movedIds[i]);
        /* repeated doc.ChangeSortItem targetFolderItems = 5; */
        for (let i = 0; i < message.targetFolderItems.length; i++)
            ChangeSortItem.internalBinaryWrite(message.targetFolderItems[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.MoveFolderOrDocReq
 */
export const MoveFolderOrDocReq = new MoveFolderOrDocReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocListByFolderIdReq$Type extends MessageType<GetDocListByFolderIdReq> {
    constructor() {
        super("doc.GetDocListByFolderIdReq", [
            { no: 1, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sortType", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocListByFolderIdReq>): GetDocListByFolderIdReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.folderId = "";
        message.sortType = 0;
        if (value !== undefined)
            reflectionMergePartial<GetDocListByFolderIdReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocListByFolderIdReq): GetDocListByFolderIdReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* uint32 sortType */ 2:
                    message.sortType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocListByFolderIdReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string folderId = 1; */
        if (message.folderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* uint32 sortType = 2; */
        if (message.sortType !== 0)
            writer.tag(2, WireType.Varint).uint32(message.sortType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocListByFolderIdReq
 */
export const GetDocListByFolderIdReq = new GetDocListByFolderIdReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocListByFolderIdResponse$Type extends MessageType<GetDocListByFolderIdResponse> {
    constructor() {
        super("doc.GetDocListByFolderIdResponse", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocDetailInfo }
        ]);
    }
    create(value?: PartialMessage<GetDocListByFolderIdResponse>): GetDocListByFolderIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.message = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocListByFolderIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocListByFolderIdResponse): GetDocListByFolderIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* repeated doc.DocDetailInfo data */ 3:
                    message.data.push(DocDetailInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocListByFolderIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated doc.DocDetailInfo data = 3; */
        for (let i = 0; i < message.data.length; i++)
            DocDetailInfo.internalBinaryWrite(message.data[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocListByFolderIdResponse
 */
export const GetDocListByFolderIdResponse = new GetDocListByFolderIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocListByFolderIdForPageReq$Type extends MessageType<GetDocListByFolderIdForPageReq> {
    constructor() {
        super("doc.GetDocListByFolderIdForPageReq", [
            { no: 1, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "currentPage", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "pageSize", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sortType", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "tagIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocListByFolderIdForPageReq>): GetDocListByFolderIdForPageReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.folderId = "";
        message.currentPage = 0;
        message.pageSize = 0;
        message.tagIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocListByFolderIdForPageReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocListByFolderIdForPageReq): GetDocListByFolderIdForPageReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* uint32 currentPage */ 2:
                    message.currentPage = reader.uint32();
                    break;
                case /* uint32 pageSize */ 3:
                    message.pageSize = reader.uint32();
                    break;
                case /* optional uint32 sortType */ 4:
                    message.sortType = reader.uint32();
                    break;
                case /* repeated string tagIds */ 5:
                    message.tagIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocListByFolderIdForPageReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string folderId = 1; */
        if (message.folderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* uint32 currentPage = 2; */
        if (message.currentPage !== 0)
            writer.tag(2, WireType.Varint).uint32(message.currentPage);
        /* uint32 pageSize = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).uint32(message.pageSize);
        /* optional uint32 sortType = 4; */
        if (message.sortType !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.sortType);
        /* repeated string tagIds = 5; */
        for (let i = 0; i < message.tagIds.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.tagIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocListByFolderIdForPageReq
 */
export const GetDocListByFolderIdForPageReq = new GetDocListByFolderIdForPageReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocListByFolderIdForPageResponse$Type extends MessageType<GetDocListByFolderIdForPageResponse> {
    constructor() {
        super("doc.GetDocListByFolderIdForPageResponse", [
            { no: 1, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "listDocDetailInfo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocDetailInfo },
            { no: 3, name: "list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocDetailInfoForPage }
        ]);
    }
    create(value?: PartialMessage<GetDocListByFolderIdForPageResponse>): GetDocListByFolderIdForPageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0;
        message.listDocDetailInfo = [];
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocListByFolderIdForPageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocListByFolderIdForPageResponse): GetDocListByFolderIdForPageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                case /* repeated doc.DocDetailInfo listDocDetailInfo */ 2:
                    message.listDocDetailInfo.push(DocDetailInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated doc.DocDetailInfoForPage list */ 3:
                    message.list.push(DocDetailInfoForPage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocListByFolderIdForPageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total = 1; */
        if (message.total !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total);
        /* repeated doc.DocDetailInfo listDocDetailInfo = 2; */
        for (let i = 0; i < message.listDocDetailInfo.length; i++)
            DocDetailInfo.internalBinaryWrite(message.listDocDetailInfo[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated doc.DocDetailInfoForPage list = 3; */
        for (let i = 0; i < message.list.length; i++)
            DocDetailInfoForPage.internalBinaryWrite(message.list[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocListByFolderIdForPageResponse
 */
export const GetDocListByFolderIdForPageResponse = new GetDocListByFolderIdForPageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocDetailInfoForPage$Type extends MessageType<DocDetailInfoForPage> {
    constructor() {
        super("doc.DocDetailInfoForPage", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "publishDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "createDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "lastReadTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "isLatestRead", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "classifyInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocClassifyInfo },
            { no: 15, name: "paperRepositoryStatus", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "containerTitles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "page", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "noteId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "displayVenue", kind: "message", T: () => DisplayVenue },
            { no: 20, name: "displayAuthor", kind: "message", T: () => DisplayAuthor },
            { no: 21, name: "displayPublishDate", kind: "message", T: () => DisplayPublishDate },
            { no: 22, name: "paperTitle", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "docType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "authorList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AuthorInfoForPage },
            { no: 25, name: "eventTitle", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "eventPlace", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "eventDate", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "doi", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 29, name: "volume", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "issue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocDetailInfoForPage>): DocDetailInfoForPage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.docName = "";
        message.sort = 0;
        message.paperId = "";
        message.pdfId = "";
        message.remark = "";
        message.publishDate = 0n;
        message.createDate = 0n;
        message.lastReadTime = 0n;
        message.isLatestRead = false;
        message.classifyInfos = [];
        message.paperRepositoryStatus = "";
        message.containerTitles = [];
        message.noteId = 0n;
        message.paperTitle = "";
        message.docType = "";
        message.authorList = [];
        message.eventDate = [];
        if (value !== undefined)
            reflectionMergePartial<DocDetailInfoForPage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocDetailInfoForPage): DocDetailInfoForPage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                case /* uint32 sort */ 3:
                    message.sort = reader.uint32();
                    break;
                case /* string paperId */ 4:
                    message.paperId = reader.string();
                    break;
                case /* string pdfId */ 5:
                    message.pdfId = reader.string();
                    break;
                case /* string remark */ 6:
                    message.remark = reader.string();
                    break;
                case /* uint64 publishDate */ 7:
                    message.publishDate = reader.uint64().toBigInt();
                    break;
                case /* uint64 createDate */ 8:
                    message.createDate = reader.uint64().toBigInt();
                    break;
                case /* uint64 lastReadTime */ 9:
                    message.lastReadTime = reader.uint64().toBigInt();
                    break;
                case /* bool isLatestRead */ 10:
                    message.isLatestRead = reader.bool();
                    break;
                case /* repeated doc.DocClassifyInfo classifyInfos */ 14:
                    message.classifyInfos.push(DocClassifyInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string paperRepositoryStatus */ 15:
                    message.paperRepositoryStatus = reader.string();
                    break;
                case /* repeated string containerTitles */ 16:
                    message.containerTitles.push(reader.string());
                    break;
                case /* optional string page */ 17:
                    message.page = reader.string();
                    break;
                case /* int64 noteId */ 18:
                    message.noteId = reader.int64().toBigInt();
                    break;
                case /* doc.DisplayVenue displayVenue */ 19:
                    message.displayVenue = DisplayVenue.internalBinaryRead(reader, reader.uint32(), options, message.displayVenue);
                    break;
                case /* doc.DisplayAuthor displayAuthor */ 20:
                    message.displayAuthor = DisplayAuthor.internalBinaryRead(reader, reader.uint32(), options, message.displayAuthor);
                    break;
                case /* doc.DisplayPublishDate displayPublishDate */ 21:
                    message.displayPublishDate = DisplayPublishDate.internalBinaryRead(reader, reader.uint32(), options, message.displayPublishDate);
                    break;
                case /* string paperTitle */ 22:
                    message.paperTitle = reader.string();
                    break;
                case /* string docType */ 23:
                    message.docType = reader.string();
                    break;
                case /* repeated doc.AuthorInfoForPage authorList */ 24:
                    message.authorList.push(AuthorInfoForPage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string eventTitle */ 25:
                    message.eventTitle = reader.string();
                    break;
                case /* optional string eventPlace */ 26:
                    message.eventPlace = reader.string();
                    break;
                case /* repeated string eventDate */ 27:
                    message.eventDate.push(reader.string());
                    break;
                case /* optional string doi */ 28:
                    message.doi = reader.string();
                    break;
                case /* optional string volume */ 29:
                    message.volume = reader.string();
                    break;
                case /* optional string issue */ 30:
                    message.issue = reader.string();
                    break;
                case /* optional string url */ 31:
                    message.url = reader.string();
                    break;
                case /* optional string language */ 32:
                    message.language = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocDetailInfoForPage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        /* uint32 sort = 3; */
        if (message.sort !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sort);
        /* string paperId = 4; */
        if (message.paperId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.paperId);
        /* string pdfId = 5; */
        if (message.pdfId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pdfId);
        /* string remark = 6; */
        if (message.remark !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.remark);
        /* uint64 publishDate = 7; */
        if (message.publishDate !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.publishDate);
        /* uint64 createDate = 8; */
        if (message.createDate !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.createDate);
        /* uint64 lastReadTime = 9; */
        if (message.lastReadTime !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.lastReadTime);
        /* bool isLatestRead = 10; */
        if (message.isLatestRead !== false)
            writer.tag(10, WireType.Varint).bool(message.isLatestRead);
        /* repeated doc.DocClassifyInfo classifyInfos = 14; */
        for (let i = 0; i < message.classifyInfos.length; i++)
            DocClassifyInfo.internalBinaryWrite(message.classifyInfos[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string paperRepositoryStatus = 15; */
        if (message.paperRepositoryStatus !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.paperRepositoryStatus);
        /* repeated string containerTitles = 16; */
        for (let i = 0; i < message.containerTitles.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.containerTitles[i]);
        /* optional string page = 17; */
        if (message.page !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.page);
        /* int64 noteId = 18; */
        if (message.noteId !== 0n)
            writer.tag(18, WireType.Varint).int64(message.noteId);
        /* doc.DisplayVenue displayVenue = 19; */
        if (message.displayVenue)
            DisplayVenue.internalBinaryWrite(message.displayVenue, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* doc.DisplayAuthor displayAuthor = 20; */
        if (message.displayAuthor)
            DisplayAuthor.internalBinaryWrite(message.displayAuthor, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* doc.DisplayPublishDate displayPublishDate = 21; */
        if (message.displayPublishDate)
            DisplayPublishDate.internalBinaryWrite(message.displayPublishDate, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* string paperTitle = 22; */
        if (message.paperTitle !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.paperTitle);
        /* string docType = 23; */
        if (message.docType !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.docType);
        /* repeated doc.AuthorInfoForPage authorList = 24; */
        for (let i = 0; i < message.authorList.length; i++)
            AuthorInfoForPage.internalBinaryWrite(message.authorList[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* optional string eventTitle = 25; */
        if (message.eventTitle !== undefined)
            writer.tag(25, WireType.LengthDelimited).string(message.eventTitle);
        /* optional string eventPlace = 26; */
        if (message.eventPlace !== undefined)
            writer.tag(26, WireType.LengthDelimited).string(message.eventPlace);
        /* repeated string eventDate = 27; */
        for (let i = 0; i < message.eventDate.length; i++)
            writer.tag(27, WireType.LengthDelimited).string(message.eventDate[i]);
        /* optional string doi = 28; */
        if (message.doi !== undefined)
            writer.tag(28, WireType.LengthDelimited).string(message.doi);
        /* optional string volume = 29; */
        if (message.volume !== undefined)
            writer.tag(29, WireType.LengthDelimited).string(message.volume);
        /* optional string issue = 30; */
        if (message.issue !== undefined)
            writer.tag(30, WireType.LengthDelimited).string(message.issue);
        /* optional string url = 31; */
        if (message.url !== undefined)
            writer.tag(31, WireType.LengthDelimited).string(message.url);
        /* optional string language = 32; */
        if (message.language !== undefined)
            writer.tag(32, WireType.LengthDelimited).string(message.language);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DocDetailInfoForPage
 */
export const DocDetailInfoForPage = new DocDetailInfoForPage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorInfoForPage$Type extends MessageType<AuthorInfoForPage> {
    constructor() {
        super("doc.AuthorInfoForPage", [
            { no: 1, name: "given", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "family", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "literal", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthorInfoForPage>): AuthorInfoForPage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.given = "";
        message.family = "";
        message.literal = "";
        if (value !== undefined)
            reflectionMergePartial<AuthorInfoForPage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorInfoForPage): AuthorInfoForPage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string given */ 1:
                    message.given = reader.string();
                    break;
                case /* string family */ 2:
                    message.family = reader.string();
                    break;
                case /* string literal */ 3:
                    message.literal = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorInfoForPage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string given = 1; */
        if (message.given !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.given);
        /* string family = 2; */
        if (message.family !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.family);
        /* string literal = 3; */
        if (message.literal !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.literal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AuthorInfoForPage
 */
export const AuthorInfoForPage = new AuthorInfoForPage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocDetailInfo$Type extends MessageType<DocDetailInfo> {
    constructor() {
        super("doc.DocDetailInfo", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "publishDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "createDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "lastReadTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "isLatestRead", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "authors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "classifyInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocClassifyInfo },
            { no: 15, name: "paperRepositoryStatus", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "venues", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "primaryVenue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "noteId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "displayVenue", kind: "message", T: () => DisplayVenue },
            { no: 20, name: "displayAuthor", kind: "message", T: () => DisplayAuthor },
            { no: 21, name: "displayPublishDate", kind: "message", T: () => DisplayPublishDate },
            { no: 22, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "newPaper", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "partition", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "parsedStatus", kind: "enum", T: () => ["doc.UserDocParsedStatusEnum", UserDocParsedStatusEnum] },
            { no: 26, name: "embeddingStatus", kind: "enum", T: () => ["doc.UserDocParsedStatusEnum", UserDocParsedStatusEnum] }
        ]);
    }
    create(value?: PartialMessage<DocDetailInfo>): DocDetailInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.docName = "";
        message.sort = 0;
        message.paperId = "";
        message.pdfId = "";
        message.remark = "";
        message.publishDate = 0n;
        message.createDate = 0n;
        message.lastReadTime = 0n;
        message.isLatestRead = false;
        message.authors = [];
        message.classifyInfos = [];
        message.paperRepositoryStatus = "";
        message.venues = [];
        message.primaryVenue = "";
        message.noteId = 0n;
        message.newPaper = false;
        message.parsedStatus = 0;
        message.embeddingStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<DocDetailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocDetailInfo): DocDetailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                case /* uint32 sort */ 3:
                    message.sort = reader.uint32();
                    break;
                case /* string paperId */ 4:
                    message.paperId = reader.string();
                    break;
                case /* string pdfId */ 5:
                    message.pdfId = reader.string();
                    break;
                case /* string remark */ 6:
                    message.remark = reader.string();
                    break;
                case /* uint64 publishDate */ 7:
                    message.publishDate = reader.uint64().toBigInt();
                    break;
                case /* uint64 createDate */ 8:
                    message.createDate = reader.uint64().toBigInt();
                    break;
                case /* uint64 lastReadTime */ 9:
                    message.lastReadTime = reader.uint64().toBigInt();
                    break;
                case /* bool isLatestRead */ 10:
                    message.isLatestRead = reader.bool();
                    break;
                case /* repeated string authors */ 13:
                    message.authors.push(reader.string());
                    break;
                case /* repeated doc.DocClassifyInfo classifyInfos */ 14:
                    message.classifyInfos.push(DocClassifyInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string paperRepositoryStatus */ 15:
                    message.paperRepositoryStatus = reader.string();
                    break;
                case /* repeated string venues */ 16:
                    message.venues.push(reader.string());
                    break;
                case /* string primaryVenue */ 17:
                    message.primaryVenue = reader.string();
                    break;
                case /* int64 noteId */ 18:
                    message.noteId = reader.int64().toBigInt();
                    break;
                case /* doc.DisplayVenue displayVenue */ 19:
                    message.displayVenue = DisplayVenue.internalBinaryRead(reader, reader.uint32(), options, message.displayVenue);
                    break;
                case /* doc.DisplayAuthor displayAuthor */ 20:
                    message.displayAuthor = DisplayAuthor.internalBinaryRead(reader, reader.uint32(), options, message.displayAuthor);
                    break;
                case /* doc.DisplayPublishDate displayPublishDate */ 21:
                    message.displayPublishDate = DisplayPublishDate.internalBinaryRead(reader, reader.uint32(), options, message.displayPublishDate);
                    break;
                case /* optional string language */ 22:
                    message.language = reader.string();
                    break;
                case /* bool newPaper */ 23:
                    message.newPaper = reader.bool();
                    break;
                case /* optional string partition */ 24:
                    message.partition = reader.string();
                    break;
                case /* doc.UserDocParsedStatusEnum parsedStatus */ 25:
                    message.parsedStatus = reader.int32();
                    break;
                case /* doc.UserDocParsedStatusEnum embeddingStatus */ 26:
                    message.embeddingStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocDetailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        /* uint32 sort = 3; */
        if (message.sort !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sort);
        /* string paperId = 4; */
        if (message.paperId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.paperId);
        /* string pdfId = 5; */
        if (message.pdfId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pdfId);
        /* string remark = 6; */
        if (message.remark !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.remark);
        /* uint64 publishDate = 7; */
        if (message.publishDate !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.publishDate);
        /* uint64 createDate = 8; */
        if (message.createDate !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.createDate);
        /* uint64 lastReadTime = 9; */
        if (message.lastReadTime !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.lastReadTime);
        /* bool isLatestRead = 10; */
        if (message.isLatestRead !== false)
            writer.tag(10, WireType.Varint).bool(message.isLatestRead);
        /* repeated string authors = 13; */
        for (let i = 0; i < message.authors.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.authors[i]);
        /* repeated doc.DocClassifyInfo classifyInfos = 14; */
        for (let i = 0; i < message.classifyInfos.length; i++)
            DocClassifyInfo.internalBinaryWrite(message.classifyInfos[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string paperRepositoryStatus = 15; */
        if (message.paperRepositoryStatus !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.paperRepositoryStatus);
        /* repeated string venues = 16; */
        for (let i = 0; i < message.venues.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.venues[i]);
        /* string primaryVenue = 17; */
        if (message.primaryVenue !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.primaryVenue);
        /* int64 noteId = 18; */
        if (message.noteId !== 0n)
            writer.tag(18, WireType.Varint).int64(message.noteId);
        /* doc.DisplayVenue displayVenue = 19; */
        if (message.displayVenue)
            DisplayVenue.internalBinaryWrite(message.displayVenue, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* doc.DisplayAuthor displayAuthor = 20; */
        if (message.displayAuthor)
            DisplayAuthor.internalBinaryWrite(message.displayAuthor, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* doc.DisplayPublishDate displayPublishDate = 21; */
        if (message.displayPublishDate)
            DisplayPublishDate.internalBinaryWrite(message.displayPublishDate, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* optional string language = 22; */
        if (message.language !== undefined)
            writer.tag(22, WireType.LengthDelimited).string(message.language);
        /* bool newPaper = 23; */
        if (message.newPaper !== false)
            writer.tag(23, WireType.Varint).bool(message.newPaper);
        /* optional string partition = 24; */
        if (message.partition !== undefined)
            writer.tag(24, WireType.LengthDelimited).string(message.partition);
        /* doc.UserDocParsedStatusEnum parsedStatus = 25; */
        if (message.parsedStatus !== 0)
            writer.tag(25, WireType.Varint).int32(message.parsedStatus);
        /* doc.UserDocParsedStatusEnum embeddingStatus = 26; */
        if (message.embeddingStatus !== 0)
            writer.tag(26, WireType.Varint).int32(message.embeddingStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DocDetailInfo
 */
export const DocDetailInfo = new DocDetailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocClassifyInfo$Type extends MessageType<DocClassifyInfo> {
    constructor() {
        super("doc.DocClassifyInfo", [
            { no: 1, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocClassifyInfo>): DocClassifyInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classifyId = "";
        message.classifyName = "";
        if (value !== undefined)
            reflectionMergePartial<DocClassifyInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocClassifyInfo): DocClassifyInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string classifyId */ 1:
                    message.classifyId = reader.string();
                    break;
                case /* string classifyName */ 2:
                    message.classifyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocClassifyInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string classifyId = 1; */
        if (message.classifyId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.classifyId);
        /* string classifyName = 2; */
        if (message.classifyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classifyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DocClassifyInfo
 */
export const DocClassifyInfo = new DocClassifyInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplayVenue$Type extends MessageType<DisplayVenue> {
    constructor() {
        super("doc.DisplayVenue", [
            { no: 1, name: "venue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rollbackEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originVenue", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DisplayVenue>): DisplayVenue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.venue = "";
        message.rollbackEnable = false;
        message.originVenue = "";
        if (value !== undefined)
            reflectionMergePartial<DisplayVenue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplayVenue): DisplayVenue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string venue */ 1:
                    message.venue = reader.string();
                    break;
                case /* bool rollbackEnable */ 2:
                    message.rollbackEnable = reader.bool();
                    break;
                case /* string originVenue */ 3:
                    message.originVenue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplayVenue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string venue = 1; */
        if (message.venue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.venue);
        /* bool rollbackEnable = 2; */
        if (message.rollbackEnable !== false)
            writer.tag(2, WireType.Varint).bool(message.rollbackEnable);
        /* string originVenue = 3; */
        if (message.originVenue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originVenue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DisplayVenue
 */
export const DisplayVenue = new DisplayVenue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplayAuthor$Type extends MessageType<DisplayAuthor> {
    constructor() {
        super("doc.DisplayAuthor", [
            { no: 1, name: "authors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rollbackEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originAuthors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DisplayAuthor>): DisplayAuthor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authors = [];
        message.rollbackEnable = false;
        message.originAuthors = [];
        if (value !== undefined)
            reflectionMergePartial<DisplayAuthor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplayAuthor): DisplayAuthor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string authors */ 1:
                    message.authors.push(reader.string());
                    break;
                case /* bool rollbackEnable */ 2:
                    message.rollbackEnable = reader.bool();
                    break;
                case /* repeated string originAuthors */ 3:
                    message.originAuthors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplayAuthor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string authors = 1; */
        for (let i = 0; i < message.authors.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.authors[i]);
        /* bool rollbackEnable = 2; */
        if (message.rollbackEnable !== false)
            writer.tag(2, WireType.Varint).bool(message.rollbackEnable);
        /* repeated string originAuthors = 3; */
        for (let i = 0; i < message.originAuthors.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.originAuthors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DisplayAuthor
 */
export const DisplayAuthor = new DisplayAuthor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplayPublishDate$Type extends MessageType<DisplayPublishDate> {
    constructor() {
        super("doc.DisplayPublishDate", [
            { no: 1, name: "publishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rollbackEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originPublishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DisplayPublishDate>): DisplayPublishDate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishDate = "";
        message.rollbackEnable = false;
        message.originPublishDate = "";
        if (value !== undefined)
            reflectionMergePartial<DisplayPublishDate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplayPublishDate): DisplayPublishDate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string publishDate */ 1:
                    message.publishDate = reader.string();
                    break;
                case /* bool rollbackEnable */ 2:
                    message.rollbackEnable = reader.bool();
                    break;
                case /* string originPublishDate */ 3:
                    message.originPublishDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplayPublishDate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string publishDate = 1; */
        if (message.publishDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.publishDate);
        /* bool rollbackEnable = 2; */
        if (message.rollbackEnable !== false)
            writer.tag(2, WireType.Varint).bool(message.rollbackEnable);
        /* string originPublishDate = 3; */
        if (message.originPublishDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originPublishDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DisplayPublishDate
 */
export const DisplayPublishDate = new DisplayPublishDate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFolderTreeAndSimpleDocInfoListReq$Type extends MessageType<GetFolderTreeAndSimpleDocInfoListReq> {
    constructor() {
        super("doc.GetFolderTreeAndSimpleDocInfoListReq", []);
    }
    create(value?: PartialMessage<GetFolderTreeAndSimpleDocInfoListReq>): GetFolderTreeAndSimpleDocInfoListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFolderTreeAndSimpleDocInfoListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFolderTreeAndSimpleDocInfoListReq): GetFolderTreeAndSimpleDocInfoListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFolderTreeAndSimpleDocInfoListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetFolderTreeAndSimpleDocInfoListReq
 */
export const GetFolderTreeAndSimpleDocInfoListReq = new GetFolderTreeAndSimpleDocInfoListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFolderTreeAndSimpleDocInfoListResponse$Type extends MessageType<GetFolderTreeAndSimpleDocInfoListResponse> {
    constructor() {
        super("doc.GetFolderTreeAndSimpleDocInfoListResponse", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", T: () => IndexFolderAndDocContent }
        ]);
    }
    create(value?: PartialMessage<GetFolderTreeAndSimpleDocInfoListResponse>): GetFolderTreeAndSimpleDocInfoListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<GetFolderTreeAndSimpleDocInfoListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFolderTreeAndSimpleDocInfoListResponse): GetFolderTreeAndSimpleDocInfoListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* doc.IndexFolderAndDocContent data */ 3:
                    message.data = IndexFolderAndDocContent.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFolderTreeAndSimpleDocInfoListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* doc.IndexFolderAndDocContent data = 3; */
        if (message.data)
            IndexFolderAndDocContent.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetFolderTreeAndSimpleDocInfoListResponse
 */
export const GetFolderTreeAndSimpleDocInfoListResponse = new GetFolderTreeAndSimpleDocInfoListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexFolderAndDocContent$Type extends MessageType<IndexFolderAndDocContent> {
    constructor() {
        super("doc.IndexFolderAndDocContent", [
            { no: 1, name: "totalDocCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "folderInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SimpleFolderInfo },
            { no: 3, name: "unclassifiedDocInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SimpleDocInfo }
        ]);
    }
    create(value?: PartialMessage<IndexFolderAndDocContent>): IndexFolderAndDocContent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalDocCount = 0;
        message.folderInfos = [];
        message.unclassifiedDocInfos = [];
        if (value !== undefined)
            reflectionMergePartial<IndexFolderAndDocContent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexFolderAndDocContent): IndexFolderAndDocContent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 totalDocCount */ 1:
                    message.totalDocCount = reader.uint32();
                    break;
                case /* repeated doc.SimpleFolderInfo folderInfos */ 2:
                    message.folderInfos.push(SimpleFolderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated doc.SimpleDocInfo unclassifiedDocInfos */ 3:
                    message.unclassifiedDocInfos.push(SimpleDocInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexFolderAndDocContent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 totalDocCount = 1; */
        if (message.totalDocCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.totalDocCount);
        /* repeated doc.SimpleFolderInfo folderInfos = 2; */
        for (let i = 0; i < message.folderInfos.length; i++)
            SimpleFolderInfo.internalBinaryWrite(message.folderInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated doc.SimpleDocInfo unclassifiedDocInfos = 3; */
        for (let i = 0; i < message.unclassifiedDocInfos.length; i++)
            SimpleDocInfo.internalBinaryWrite(message.unclassifiedDocInfos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.IndexFolderAndDocContent
 */
export const IndexFolderAndDocContent = new IndexFolderAndDocContent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleFolderInfo$Type extends MessageType<SimpleFolderInfo> {
    constructor() {
        super("doc.SimpleFolderInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "docCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "parentId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "childrenFolders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SimpleFolderInfo },
            { no: 8, name: "docInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SimpleDocInfo },
            { no: 9, name: "isContainCurrentPaper", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleFolderInfo>): SimpleFolderInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.docCount = 0;
        message.parentId = "";
        message.folderId = "";
        message.level = 0;
        message.sort = 0;
        message.childrenFolders = [];
        message.docInfos = [];
        message.isContainCurrentPaper = false;
        message.docId = "";
        if (value !== undefined)
            reflectionMergePartial<SimpleFolderInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleFolderInfo): SimpleFolderInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 docCount */ 2:
                    message.docCount = reader.uint32();
                    break;
                case /* string parentId */ 3:
                    message.parentId = reader.string();
                    break;
                case /* string folderId */ 4:
                    message.folderId = reader.string();
                    break;
                case /* uint32 level */ 5:
                    message.level = reader.uint32();
                    break;
                case /* uint32 sort */ 6:
                    message.sort = reader.uint32();
                    break;
                case /* repeated doc.SimpleFolderInfo childrenFolders */ 7:
                    message.childrenFolders.push(SimpleFolderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated doc.SimpleDocInfo docInfos */ 8:
                    message.docInfos.push(SimpleDocInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool isContainCurrentPaper */ 9:
                    message.isContainCurrentPaper = reader.bool();
                    break;
                case /* string docId */ 10:
                    message.docId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleFolderInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 docCount = 2; */
        if (message.docCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.docCount);
        /* string parentId = 3; */
        if (message.parentId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.parentId);
        /* string folderId = 4; */
        if (message.folderId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.folderId);
        /* uint32 level = 5; */
        if (message.level !== 0)
            writer.tag(5, WireType.Varint).uint32(message.level);
        /* uint32 sort = 6; */
        if (message.sort !== 0)
            writer.tag(6, WireType.Varint).uint32(message.sort);
        /* repeated doc.SimpleFolderInfo childrenFolders = 7; */
        for (let i = 0; i < message.childrenFolders.length; i++)
            SimpleFolderInfo.internalBinaryWrite(message.childrenFolders[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated doc.SimpleDocInfo docInfos = 8; */
        for (let i = 0; i < message.docInfos.length; i++)
            SimpleDocInfo.internalBinaryWrite(message.docInfos[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool isContainCurrentPaper = 9; */
        if (message.isContainCurrentPaper !== false)
            writer.tag(9, WireType.Varint).bool(message.isContainCurrentPaper);
        /* string docId = 10; */
        if (message.docId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.docId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.SimpleFolderInfo
 */
export const SimpleFolderInfo = new SimpleFolderInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleDocInfo$Type extends MessageType<SimpleDocInfo> {
    constructor() {
        super("doc.SimpleDocInfo", [
            { no: 1, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleDocInfo>): SimpleDocInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sort = 0;
        message.docName = "";
        message.docId = "";
        message.pdfId = "";
        message.paperId = "";
        if (value !== undefined)
            reflectionMergePartial<SimpleDocInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleDocInfo): SimpleDocInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 sort */ 1:
                    message.sort = reader.uint32();
                    break;
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                case /* string docId */ 3:
                    message.docId = reader.string();
                    break;
                case /* string pdfId */ 4:
                    message.pdfId = reader.string();
                    break;
                case /* string paperId */ 5:
                    message.paperId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleDocInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 sort = 1; */
        if (message.sort !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sort);
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        /* string docId = 3; */
        if (message.docId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.docId);
        /* string pdfId = 4; */
        if (message.pdfId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pdfId);
        /* string paperId = 5; */
        if (message.paperId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paperId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.SimpleDocInfo
 */
export const SimpleDocInfo = new SimpleDocInfo$Type();
