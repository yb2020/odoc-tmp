// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/note/PaperNote.proto" (package "note", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * 论文笔记模型
 *
 * @generated from protobuf message note.PaperNote
 */
export interface PaperNote {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string paper_id = 2
     */
    paper_id: string;
    /**
     * @generated from protobuf field: string pdf_id = 3
     */
    pdf_id: string;
    /**
     * @generated from protobuf field: uint32 note_count = 4
     */
    note_count: number;
    /**
     * @generated from protobuf field: string annotation_pdf_id = 5
     */
    annotation_pdf_id: string;
}
/**
 * @api_path: /api/note/paper
 * @method: POST
 * @content-type: application/json
 * @summary: 创建论文笔记
 *
 * @generated from protobuf message note.CreatePaperNoteRequest
 */
export interface CreatePaperNoteRequest {
    /**
     * @generated from protobuf field: string paper_id = 1
     */
    paper_id: string;
    /**
     * @generated from protobuf field: string pdf_id = 2
     */
    pdf_id: string;
    /**
     * @generated from protobuf field: uint32 note_count = 3
     */
    note_count: number;
    /**
     * @generated from protobuf field: string annotation_pdf_id = 4
     */
    annotation_pdf_id: string;
}
/**
 * @generated from protobuf message note.CreatePaperNoteResponse
 */
export interface CreatePaperNoteResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/note/paper
 * @method: GET
 * @content-type: application/json
 * @summary: 获取论文笔记
 *
 * @generated from protobuf message note.GetPaperNoteRequest
 */
export interface GetPaperNoteRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message note.GetPaperNoteResponse
 */
export interface GetPaperNoteResponse {
    /**
     * @generated from protobuf field: note.PaperNote note = 1
     */
    note?: PaperNote;
}
/**
 * @api_path: /api/note/paper
 * @method: PUT
 * @content-type: application/json
 * @summary: 更新论文笔记
 *
 * @generated from protobuf message note.UpdatePaperNoteRequest
 */
export interface UpdatePaperNoteRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: uint32 note_count = 2
     */
    note_count: number;
}
/**
 * @generated from protobuf message note.UpdatePaperNoteResponse
 */
export interface UpdatePaperNoteResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/note/paper
 * @method: DELETE
 * @content-type: application/json
 * @summary: 删除论文笔记
 *
 * @generated from protobuf message note.DeletePaperNoteRequest
 */
export interface DeletePaperNoteRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message note.DeletePaperNoteResponse
 */
export interface DeletePaperNoteResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/note/papers
 * @method: GET
 * @content-type: application/json
 * @summary: 列出论文笔记
 *
 * @generated from protobuf message note.ListPaperNotesRequest
 */
export interface ListPaperNotesRequest {
    /**
     * @generated from protobuf field: uint32 limit = 1
     */
    limit: number;
    /**
     * @generated from protobuf field: uint32 offset = 2
     */
    offset: number;
}
/**
 * @generated from protobuf message note.ListPaperNotesResponse
 */
export interface ListPaperNotesResponse {
    /**
     * @generated from protobuf field: repeated note.PaperNote notes = 1
     */
    notes: PaperNote[];
}
/**
 * @api_path: /api/note/papers/count
 * @method: GET
 * @content-type: application/json
 * @summary: 获取论文笔记总数
 *
 * @generated from protobuf message note.CountPaperNotesRequest
 */
export interface CountPaperNotesRequest {
}
/**
 * @generated from protobuf message note.CountPaperNotesResponse
 */
export interface CountPaperNotesResponse {
    /**
     * @generated from protobuf field: uint64 count = 1
     */
    count: bigint;
}
// ------ 旧接口翻译扩展 ------//

/**
 * @generated from protobuf message note.UserInfoBean
 */
export interface UserInfoBean {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string nickName = 2
     */
    nickName: string;
    /**
     * @generated from protobuf field: bool self = 3
     */
    self: boolean;
    /**
     * @generated from protobuf field: string showName = 4
     */
    showName: string;
    /**
     * @generated from protobuf field: string avatarUrl = 5
     */
    avatarUrl: string;
    /**
     * @generated from protobuf field: string tags = 6
     */
    tags: string;
    /**
     * @generated from protobuf field: string description = 7
     */
    description: string;
    /**
     * @generated from protobuf field: string authorId = 8
     */
    authorId: string;
    /**
     * @generated from protobuf field: string authorName = 9
     */
    authorName: string;
    /**
     * @generated from protobuf field: bool isAuthentication = 10
     */
    isAuthentication: boolean;
    /**
     * @generated from protobuf field: bool isPaperAuthor = 11
     */
    isPaperAuthor: boolean;
}
/**
 * @api_path: /api/note/paperNote/getPaperNoteBaseInfoById
 * @method: POST
 * @content-type: application/json
 * @summary: 获取论文笔记基础信息By ID
 *
 * @generated from protobuf message note.GetPaperNoteBaseInfoByIdReq
 */
export interface GetPaperNoteBaseInfoByIdReq {
    /**
     * @generated from protobuf field: string noteId = 1
     */
    noteId: string;
}
/**
 * @api_path: /api/note/paperNote/getOwnerPaperNoteBaseInfo
 * @method: POST
 * @content-type: application/json
 * @summary: 获取自己的笔记基础信息
 *
 * @generated from protobuf message note.GetOwnerPaperNoteBaseInfoReq
 */
export interface GetOwnerPaperNoteBaseInfoReq {
    /**
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
    /**
     * @generated from protobuf field: optional string groupId = 2
     */
    groupId?: string;
}
/**
 * @generated from protobuf message note.PaperNoteBaseInfoResponse
 */
export interface PaperNoteBaseInfoResponse {
    /**
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string noteId = 2
     */
    noteId: string;
    /**
     * @generated from protobuf field: string paperId = 3
     */
    paperId: string;
    /**
     * @generated from protobuf field: string pdfContributor = 4
     */
    pdfContributor: string;
    /**
     * @generated from protobuf field: uint32 paperNoteCount = 5
     */
    paperNoteCount: number;
    /**
     * @generated from protobuf field: bool isCollected = 6
     */
    isCollected: boolean;
    /**
     * @generated from protobuf field: bool isUserUpload = 7
     */
    isUserUpload: boolean;
    /**
     * @generated from protobuf field: bool isPrivatePaper = 8
     */
    isPrivatePaper: boolean;
    /**
     * @generated from protobuf field: bool showAnnotation = 9
     */
    showAnnotation: boolean;
    /**
     * @generated from protobuf field: string paperTitle = 10
     */
    paperTitle: string;
    /**
     * @generated from protobuf field: string sourceMark = 11
     */
    sourceMark: string;
    /**
     * @generated from protobuf field: string crawlUrl = 12
     */
    crawlUrl: string;
    /**
     * @generated from protobuf field: string uploadUserId = 13
     */
    uploadUserId: string;
    /**
     * @generated from protobuf field: string licenceType = 14
     */
    licenceType: string;
    /**
     * @generated from protobuf field: string docName = 15
     */
    docName: string;
    /**
     * @generated from protobuf field: string noteSummary = 16
     */
    noteSummary: string;
    /**
     * @generated from protobuf field: string pdfUrl = 17
     */
    pdfUrl: string;
    /**
     * @generated from protobuf field: string modifyDate = 18
     */
    modifyDate: string;
    /**
     * @generated from protobuf field: note.UserInfoBean userInfo = 19
     */
    userInfo?: UserInfoBean;
    /**
     * @generated from protobuf field: bool isPaperCollected = 20
     */
    isPaperCollected: boolean;
    /**
     * @generated from protobuf field: bool isLike = 21
     */
    isLike: boolean;
    /**
     * @generated from protobuf field: uint32 likeCount = 22
     */
    likeCount: number;
    /**
     * @generated from protobuf field: bool isGptWhite = 23
     */
    isGptWhite: boolean;
    /**
     * @generated from protobuf field: string gptGrayTip = 24
     */
    gptGrayTip: string;
    /**
     * @generated from protobuf field: string userDocId = 25
     */
    userDocId: string;
    /**
     * @generated from protobuf field: bool accessToAiAssistantReading = 26
     */
    accessToAiAssistantReading: boolean;
}
/**
 * 论文笔记访问记录模型
 *
 * @generated from protobuf message note.PaperNoteAccess
 */
export interface PaperNoteAccess {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string note_id = 2
     */
    note_id: string;
    /**
     * @generated from protobuf field: bool open_status = 3
     */
    open_status: boolean;
}
/**
 * @api_path: /api/note/paper/access
 * @method: POST
 * @content-type: application/json
 * @summary: 创建论文笔记访问记录
 *
 * @generated from protobuf message note.CreatePaperNoteAccessRequest
 */
export interface CreatePaperNoteAccessRequest {
    /**
     * @generated from protobuf field: string note_id = 1
     */
    note_id: string;
    /**
     * @generated from protobuf field: bool open_status = 2
     */
    open_status: boolean;
}
/**
 * @generated from protobuf message note.CreatePaperNoteAccessResponse
 */
export interface CreatePaperNoteAccessResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/note/paper/access
 * @method: GET
 * @content-type: application/json
 * @summary: 获取论文笔记访问记录
 *
 * @generated from protobuf message note.GetPaperNoteAccessRequest
 */
export interface GetPaperNoteAccessRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message note.GetPaperNoteAccessResponse
 */
export interface GetPaperNoteAccessResponse {
    /**
     * @generated from protobuf field: note.PaperNoteAccess access = 1
     */
    access?: PaperNoteAccess;
}
/**
 * @api_path: /api/note/paper/access/by-note
 * @method: GET
 * @content-type: application/json
 * @summary: 根据笔记ID获取论文笔记访问记录
 *
 * @generated from protobuf message note.GetPaperNoteAccessByNoteIdRequest
 */
export interface GetPaperNoteAccessByNoteIdRequest {
    /**
     * @generated from protobuf field: string note_id = 1
     */
    note_id: string;
}
/**
 * @generated from protobuf message note.GetPaperNoteAccessByNoteIdResponse
 */
export interface GetPaperNoteAccessByNoteIdResponse {
    /**
     * @generated from protobuf field: note.PaperNoteAccess access = 1
     */
    access?: PaperNoteAccess;
}
/**
 * @api_path: /api/note/paper/access
 * @method: PUT
 * @content-type: application/json
 * @summary: 更新论文笔记访问记录
 *
 * @generated from protobuf message note.UpdatePaperNoteAccessRequest
 */
export interface UpdatePaperNoteAccessRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: bool open_status = 2
     */
    open_status: boolean;
}
/**
 * @generated from protobuf message note.UpdatePaperNoteAccessResponse
 */
export interface UpdatePaperNoteAccessResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
}
/**
 * @api_path: /api/note/paper/access
 * @method: DELETE
 * @content-type: application/json
 * @summary: 删除论文笔记访问记录
 *
 * @generated from protobuf message note.DeletePaperNoteAccessRequest
 */
export interface DeletePaperNoteAccessRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message note.DeletePaperNoteAccessResponse
 */
export interface DeletePaperNoteAccessResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
}
/**
 * @api_path: /api/note/paperNote/downloadNotePdf
 * @method: GET
 * @content-type: application/json
 * @summary: 下载笔记PDF
 *
 * @generated from protobuf message note.DownloadNotePdfRequest
 */
export interface DownloadNotePdfRequest {
    /**
     * @generated from protobuf field: string note_id = 1
     */
    note_id: string;
}
/**
 * @api_path: /api/note/paperNote/downloadNoteMarkdown
 * @method: GET
 * @content-type: application/json
 * @summary: 下载笔记Markdown
 *
 * @generated from protobuf message note.DownloadNoteMarkdownRequest
 */
export interface DownloadNoteMarkdownRequest {
    /**
     * @generated from protobuf field: string note_id = 1
     */
    note_id: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class PaperNote$Type extends MessageType<PaperNote> {
    constructor() {
        super("note.PaperNote", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "paper_id", kind: "scalar", localName: "paper_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "pdf_id", kind: "scalar", localName: "pdf_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "note_count", kind: "scalar", localName: "note_count", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 5, name: "annotation_pdf_id", kind: "scalar", localName: "annotation_pdf_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<PaperNote>): PaperNote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.paper_id = "";
        message.pdf_id = "";
        message.note_count = 0;
        message.annotation_pdf_id = "";
        if (value !== undefined)
            reflectionMergePartial<PaperNote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperNote): PaperNote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string paper_id */ 2:
                    message.paper_id = reader.string();
                    break;
                case /* string pdf_id */ 3:
                    message.pdf_id = reader.string();
                    break;
                case /* uint32 note_count */ 4:
                    message.note_count = reader.uint32();
                    break;
                case /* string annotation_pdf_id */ 5:
                    message.annotation_pdf_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperNote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string paper_id = 2; */
        if (message.paper_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paper_id);
        /* string pdf_id = 3; */
        if (message.pdf_id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pdf_id);
        /* uint32 note_count = 4; */
        if (message.note_count !== 0)
            writer.tag(4, WireType.Varint).uint32(message.note_count);
        /* string annotation_pdf_id = 5; */
        if (message.annotation_pdf_id !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.annotation_pdf_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.PaperNote
 */
export const PaperNote = new PaperNote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePaperNoteRequest$Type extends MessageType<CreatePaperNoteRequest> {
    constructor() {
        super("note.CreatePaperNoteRequest", [
            { no: 1, name: "paper_id", kind: "scalar", localName: "paper_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "pdf_id", kind: "scalar", localName: "pdf_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "note_count", kind: "scalar", localName: "note_count", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 4, name: "annotation_pdf_id", kind: "scalar", localName: "annotation_pdf_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<CreatePaperNoteRequest>): CreatePaperNoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paper_id = "";
        message.pdf_id = "";
        message.note_count = 0;
        message.annotation_pdf_id = "";
        if (value !== undefined)
            reflectionMergePartial<CreatePaperNoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePaperNoteRequest): CreatePaperNoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paper_id */ 1:
                    message.paper_id = reader.string();
                    break;
                case /* string pdf_id */ 2:
                    message.pdf_id = reader.string();
                    break;
                case /* uint32 note_count */ 3:
                    message.note_count = reader.uint32();
                    break;
                case /* string annotation_pdf_id */ 4:
                    message.annotation_pdf_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePaperNoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paper_id = 1; */
        if (message.paper_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paper_id);
        /* string pdf_id = 2; */
        if (message.pdf_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdf_id);
        /* uint32 note_count = 3; */
        if (message.note_count !== 0)
            writer.tag(3, WireType.Varint).uint32(message.note_count);
        /* string annotation_pdf_id = 4; */
        if (message.annotation_pdf_id !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.annotation_pdf_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.CreatePaperNoteRequest
 */
export const CreatePaperNoteRequest = new CreatePaperNoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePaperNoteResponse$Type extends MessageType<CreatePaperNoteResponse> {
    constructor() {
        super("note.CreatePaperNoteResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePaperNoteResponse>): CreatePaperNoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<CreatePaperNoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePaperNoteResponse): CreatePaperNoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePaperNoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.CreatePaperNoteResponse
 */
export const CreatePaperNoteResponse = new CreatePaperNoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperNoteRequest$Type extends MessageType<GetPaperNoteRequest> {
    constructor() {
        super("note.GetPaperNoteRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperNoteRequest>): GetPaperNoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperNoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperNoteRequest): GetPaperNoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperNoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetPaperNoteRequest
 */
export const GetPaperNoteRequest = new GetPaperNoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperNoteResponse$Type extends MessageType<GetPaperNoteResponse> {
    constructor() {
        super("note.GetPaperNoteResponse", [
            { no: 1, name: "note", kind: "message", T: () => PaperNote }
        ]);
    }
    create(value?: PartialMessage<GetPaperNoteResponse>): GetPaperNoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaperNoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperNoteResponse): GetPaperNoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* note.PaperNote note */ 1:
                    message.note = PaperNote.internalBinaryRead(reader, reader.uint32(), options, message.note);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperNoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* note.PaperNote note = 1; */
        if (message.note)
            PaperNote.internalBinaryWrite(message.note, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetPaperNoteResponse
 */
export const GetPaperNoteResponse = new GetPaperNoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaperNoteRequest$Type extends MessageType<UpdatePaperNoteRequest> {
    constructor() {
        super("note.UpdatePaperNoteRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "note_count", kind: "scalar", localName: "note_count", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<UpdatePaperNoteRequest>): UpdatePaperNoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.note_count = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdatePaperNoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaperNoteRequest): UpdatePaperNoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* uint32 note_count */ 2:
                    message.note_count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaperNoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* uint32 note_count = 2; */
        if (message.note_count !== 0)
            writer.tag(2, WireType.Varint).uint32(message.note_count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.UpdatePaperNoteRequest
 */
export const UpdatePaperNoteRequest = new UpdatePaperNoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaperNoteResponse$Type extends MessageType<UpdatePaperNoteResponse> {
    constructor() {
        super("note.UpdatePaperNoteResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePaperNoteResponse>): UpdatePaperNoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<UpdatePaperNoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaperNoteResponse): UpdatePaperNoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaperNoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.UpdatePaperNoteResponse
 */
export const UpdatePaperNoteResponse = new UpdatePaperNoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaperNoteRequest$Type extends MessageType<DeletePaperNoteRequest> {
    constructor() {
        super("note.DeletePaperNoteRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<DeletePaperNoteRequest>): DeletePaperNoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeletePaperNoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaperNoteRequest): DeletePaperNoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePaperNoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.DeletePaperNoteRequest
 */
export const DeletePaperNoteRequest = new DeletePaperNoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaperNoteResponse$Type extends MessageType<DeletePaperNoteResponse> {
    constructor() {
        super("note.DeletePaperNoteResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePaperNoteResponse>): DeletePaperNoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeletePaperNoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaperNoteResponse): DeletePaperNoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePaperNoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.DeletePaperNoteResponse
 */
export const DeletePaperNoteResponse = new DeletePaperNoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPaperNotesRequest$Type extends MessageType<ListPaperNotesRequest> {
    constructor() {
        super("note.ListPaperNotesRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gt: 0 } } } },
            { no: 2, name: "offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<ListPaperNotesRequest>): ListPaperNotesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.offset = 0;
        if (value !== undefined)
            reflectionMergePartial<ListPaperNotesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaperNotesRequest): ListPaperNotesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* uint32 offset */ 2:
                    message.offset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPaperNotesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* uint32 offset = 2; */
        if (message.offset !== 0)
            writer.tag(2, WireType.Varint).uint32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.ListPaperNotesRequest
 */
export const ListPaperNotesRequest = new ListPaperNotesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPaperNotesResponse$Type extends MessageType<ListPaperNotesResponse> {
    constructor() {
        super("note.ListPaperNotesResponse", [
            { no: 1, name: "notes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaperNote }
        ]);
    }
    create(value?: PartialMessage<ListPaperNotesResponse>): ListPaperNotesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.notes = [];
        if (value !== undefined)
            reflectionMergePartial<ListPaperNotesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaperNotesResponse): ListPaperNotesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated note.PaperNote notes */ 1:
                    message.notes.push(PaperNote.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPaperNotesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated note.PaperNote notes = 1; */
        for (let i = 0; i < message.notes.length; i++)
            PaperNote.internalBinaryWrite(message.notes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.ListPaperNotesResponse
 */
export const ListPaperNotesResponse = new ListPaperNotesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountPaperNotesRequest$Type extends MessageType<CountPaperNotesRequest> {
    constructor() {
        super("note.CountPaperNotesRequest", []);
    }
    create(value?: PartialMessage<CountPaperNotesRequest>): CountPaperNotesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CountPaperNotesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountPaperNotesRequest): CountPaperNotesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountPaperNotesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.CountPaperNotesRequest
 */
export const CountPaperNotesRequest = new CountPaperNotesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountPaperNotesResponse$Type extends MessageType<CountPaperNotesResponse> {
    constructor() {
        super("note.CountPaperNotesResponse", [
            { no: 1, name: "count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CountPaperNotesResponse>): CountPaperNotesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<CountPaperNotesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountPaperNotesResponse): CountPaperNotesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 count */ 1:
                    message.count = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountPaperNotesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 count = 1; */
        if (message.count !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.CountPaperNotesResponse
 */
export const CountPaperNotesResponse = new CountPaperNotesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserInfoBean$Type extends MessageType<UserInfoBean> {
    constructor() {
        super("note.UserInfoBean", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "nickName", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "self", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "showName", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 5, name: "avatarUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 6, name: "tags", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "authorId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 9, name: "authorName", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 10, name: "isAuthentication", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "isPaperAuthor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UserInfoBean>): UserInfoBean {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.nickName = "";
        message.self = false;
        message.showName = "";
        message.avatarUrl = "";
        message.tags = "";
        message.description = "";
        message.authorId = "";
        message.authorName = "";
        message.isAuthentication = false;
        message.isPaperAuthor = false;
        if (value !== undefined)
            reflectionMergePartial<UserInfoBean>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserInfoBean): UserInfoBean {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string nickName */ 2:
                    message.nickName = reader.string();
                    break;
                case /* bool self */ 3:
                    message.self = reader.bool();
                    break;
                case /* string showName */ 4:
                    message.showName = reader.string();
                    break;
                case /* string avatarUrl */ 5:
                    message.avatarUrl = reader.string();
                    break;
                case /* string tags */ 6:
                    message.tags = reader.string();
                    break;
                case /* string description */ 7:
                    message.description = reader.string();
                    break;
                case /* string authorId */ 8:
                    message.authorId = reader.string();
                    break;
                case /* string authorName */ 9:
                    message.authorName = reader.string();
                    break;
                case /* bool isAuthentication */ 10:
                    message.isAuthentication = reader.bool();
                    break;
                case /* bool isPaperAuthor */ 11:
                    message.isPaperAuthor = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserInfoBean, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string nickName = 2; */
        if (message.nickName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nickName);
        /* bool self = 3; */
        if (message.self !== false)
            writer.tag(3, WireType.Varint).bool(message.self);
        /* string showName = 4; */
        if (message.showName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.showName);
        /* string avatarUrl = 5; */
        if (message.avatarUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.avatarUrl);
        /* string tags = 6; */
        if (message.tags !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.tags);
        /* string description = 7; */
        if (message.description !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.description);
        /* string authorId = 8; */
        if (message.authorId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.authorId);
        /* string authorName = 9; */
        if (message.authorName !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.authorName);
        /* bool isAuthentication = 10; */
        if (message.isAuthentication !== false)
            writer.tag(10, WireType.Varint).bool(message.isAuthentication);
        /* bool isPaperAuthor = 11; */
        if (message.isPaperAuthor !== false)
            writer.tag(11, WireType.Varint).bool(message.isPaperAuthor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.UserInfoBean
 */
export const UserInfoBean = new UserInfoBean$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperNoteBaseInfoByIdReq$Type extends MessageType<GetPaperNoteBaseInfoByIdReq> {
    constructor() {
        super("note.GetPaperNoteBaseInfoByIdReq", [
            { no: 1, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperNoteBaseInfoByIdReq>): GetPaperNoteBaseInfoByIdReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperNoteBaseInfoByIdReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperNoteBaseInfoByIdReq): GetPaperNoteBaseInfoByIdReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string noteId */ 1:
                    message.noteId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperNoteBaseInfoByIdReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string noteId = 1; */
        if (message.noteId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.noteId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetPaperNoteBaseInfoByIdReq
 */
export const GetPaperNoteBaseInfoByIdReq = new GetPaperNoteBaseInfoByIdReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOwnerPaperNoteBaseInfoReq$Type extends MessageType<GetOwnerPaperNoteBaseInfoReq> {
    constructor() {
        super("note.GetOwnerPaperNoteBaseInfoReq", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "groupId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOwnerPaperNoteBaseInfoReq>): GetOwnerPaperNoteBaseInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetOwnerPaperNoteBaseInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOwnerPaperNoteBaseInfoReq): GetOwnerPaperNoteBaseInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                case /* optional string groupId */ 2:
                    message.groupId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOwnerPaperNoteBaseInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        /* optional string groupId = 2; */
        if (message.groupId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetOwnerPaperNoteBaseInfoReq
 */
export const GetOwnerPaperNoteBaseInfoReq = new GetOwnerPaperNoteBaseInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaperNoteBaseInfoResponse$Type extends MessageType<PaperNoteBaseInfoResponse> {
    constructor() {
        super("note.PaperNoteBaseInfoResponse", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "pdfContributor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 5, name: "paperNoteCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 6, name: "isCollected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "isUserUpload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "isPrivatePaper", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "showAnnotation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "paperTitle", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 11, name: "sourceMark", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 12, name: "crawlUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 13, name: "uploadUserId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 14, name: "licenceType", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 15, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 16, name: "noteSummary", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 17, name: "pdfUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 18, name: "modifyDate", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 19, name: "userInfo", kind: "message", T: () => UserInfoBean },
            { no: 20, name: "isPaperCollected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "isLike", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "likeCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } },
            { no: 23, name: "isGptWhite", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "gptGrayTip", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 25, name: "userDocId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 26, name: "accessToAiAssistantReading", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PaperNoteBaseInfoResponse>): PaperNoteBaseInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        message.noteId = "";
        message.paperId = "";
        message.pdfContributor = "";
        message.paperNoteCount = 0;
        message.isCollected = false;
        message.isUserUpload = false;
        message.isPrivatePaper = false;
        message.showAnnotation = false;
        message.paperTitle = "";
        message.sourceMark = "";
        message.crawlUrl = "";
        message.uploadUserId = "";
        message.licenceType = "";
        message.docName = "";
        message.noteSummary = "";
        message.pdfUrl = "";
        message.modifyDate = "";
        message.isPaperCollected = false;
        message.isLike = false;
        message.likeCount = 0;
        message.isGptWhite = false;
        message.gptGrayTip = "";
        message.userDocId = "";
        message.accessToAiAssistantReading = false;
        if (value !== undefined)
            reflectionMergePartial<PaperNoteBaseInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperNoteBaseInfoResponse): PaperNoteBaseInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                case /* string noteId */ 2:
                    message.noteId = reader.string();
                    break;
                case /* string paperId */ 3:
                    message.paperId = reader.string();
                    break;
                case /* string pdfContributor */ 4:
                    message.pdfContributor = reader.string();
                    break;
                case /* uint32 paperNoteCount */ 5:
                    message.paperNoteCount = reader.uint32();
                    break;
                case /* bool isCollected */ 6:
                    message.isCollected = reader.bool();
                    break;
                case /* bool isUserUpload */ 7:
                    message.isUserUpload = reader.bool();
                    break;
                case /* bool isPrivatePaper */ 8:
                    message.isPrivatePaper = reader.bool();
                    break;
                case /* bool showAnnotation */ 9:
                    message.showAnnotation = reader.bool();
                    break;
                case /* string paperTitle */ 10:
                    message.paperTitle = reader.string();
                    break;
                case /* string sourceMark */ 11:
                    message.sourceMark = reader.string();
                    break;
                case /* string crawlUrl */ 12:
                    message.crawlUrl = reader.string();
                    break;
                case /* string uploadUserId */ 13:
                    message.uploadUserId = reader.string();
                    break;
                case /* string licenceType */ 14:
                    message.licenceType = reader.string();
                    break;
                case /* string docName */ 15:
                    message.docName = reader.string();
                    break;
                case /* string noteSummary */ 16:
                    message.noteSummary = reader.string();
                    break;
                case /* string pdfUrl */ 17:
                    message.pdfUrl = reader.string();
                    break;
                case /* string modifyDate */ 18:
                    message.modifyDate = reader.string();
                    break;
                case /* note.UserInfoBean userInfo */ 19:
                    message.userInfo = UserInfoBean.internalBinaryRead(reader, reader.uint32(), options, message.userInfo);
                    break;
                case /* bool isPaperCollected */ 20:
                    message.isPaperCollected = reader.bool();
                    break;
                case /* bool isLike */ 21:
                    message.isLike = reader.bool();
                    break;
                case /* uint32 likeCount */ 22:
                    message.likeCount = reader.uint32();
                    break;
                case /* bool isGptWhite */ 23:
                    message.isGptWhite = reader.bool();
                    break;
                case /* string gptGrayTip */ 24:
                    message.gptGrayTip = reader.string();
                    break;
                case /* string userDocId */ 25:
                    message.userDocId = reader.string();
                    break;
                case /* bool accessToAiAssistantReading */ 26:
                    message.accessToAiAssistantReading = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperNoteBaseInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        /* string noteId = 2; */
        if (message.noteId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.noteId);
        /* string paperId = 3; */
        if (message.paperId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.paperId);
        /* string pdfContributor = 4; */
        if (message.pdfContributor !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pdfContributor);
        /* uint32 paperNoteCount = 5; */
        if (message.paperNoteCount !== 0)
            writer.tag(5, WireType.Varint).uint32(message.paperNoteCount);
        /* bool isCollected = 6; */
        if (message.isCollected !== false)
            writer.tag(6, WireType.Varint).bool(message.isCollected);
        /* bool isUserUpload = 7; */
        if (message.isUserUpload !== false)
            writer.tag(7, WireType.Varint).bool(message.isUserUpload);
        /* bool isPrivatePaper = 8; */
        if (message.isPrivatePaper !== false)
            writer.tag(8, WireType.Varint).bool(message.isPrivatePaper);
        /* bool showAnnotation = 9; */
        if (message.showAnnotation !== false)
            writer.tag(9, WireType.Varint).bool(message.showAnnotation);
        /* string paperTitle = 10; */
        if (message.paperTitle !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.paperTitle);
        /* string sourceMark = 11; */
        if (message.sourceMark !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.sourceMark);
        /* string crawlUrl = 12; */
        if (message.crawlUrl !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.crawlUrl);
        /* string uploadUserId = 13; */
        if (message.uploadUserId !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.uploadUserId);
        /* string licenceType = 14; */
        if (message.licenceType !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.licenceType);
        /* string docName = 15; */
        if (message.docName !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.docName);
        /* string noteSummary = 16; */
        if (message.noteSummary !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.noteSummary);
        /* string pdfUrl = 17; */
        if (message.pdfUrl !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.pdfUrl);
        /* string modifyDate = 18; */
        if (message.modifyDate !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.modifyDate);
        /* note.UserInfoBean userInfo = 19; */
        if (message.userInfo)
            UserInfoBean.internalBinaryWrite(message.userInfo, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* bool isPaperCollected = 20; */
        if (message.isPaperCollected !== false)
            writer.tag(20, WireType.Varint).bool(message.isPaperCollected);
        /* bool isLike = 21; */
        if (message.isLike !== false)
            writer.tag(21, WireType.Varint).bool(message.isLike);
        /* uint32 likeCount = 22; */
        if (message.likeCount !== 0)
            writer.tag(22, WireType.Varint).uint32(message.likeCount);
        /* bool isGptWhite = 23; */
        if (message.isGptWhite !== false)
            writer.tag(23, WireType.Varint).bool(message.isGptWhite);
        /* string gptGrayTip = 24; */
        if (message.gptGrayTip !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.gptGrayTip);
        /* string userDocId = 25; */
        if (message.userDocId !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.userDocId);
        /* bool accessToAiAssistantReading = 26; */
        if (message.accessToAiAssistantReading !== false)
            writer.tag(26, WireType.Varint).bool(message.accessToAiAssistantReading);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.PaperNoteBaseInfoResponse
 */
export const PaperNoteBaseInfoResponse = new PaperNoteBaseInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaperNoteAccess$Type extends MessageType<PaperNoteAccess> {
    constructor() {
        super("note.PaperNoteAccess", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "note_id", kind: "scalar", localName: "note_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "open_status", kind: "scalar", localName: "open_status", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PaperNoteAccess>): PaperNoteAccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.note_id = "";
        message.open_status = false;
        if (value !== undefined)
            reflectionMergePartial<PaperNoteAccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperNoteAccess): PaperNoteAccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string note_id */ 2:
                    message.note_id = reader.string();
                    break;
                case /* bool open_status */ 3:
                    message.open_status = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperNoteAccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string note_id = 2; */
        if (message.note_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.note_id);
        /* bool open_status = 3; */
        if (message.open_status !== false)
            writer.tag(3, WireType.Varint).bool(message.open_status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.PaperNoteAccess
 */
export const PaperNoteAccess = new PaperNoteAccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePaperNoteAccessRequest$Type extends MessageType<CreatePaperNoteAccessRequest> {
    constructor() {
        super("note.CreatePaperNoteAccessRequest", [
            { no: 1, name: "note_id", kind: "scalar", localName: "note_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "open_status", kind: "scalar", localName: "open_status", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePaperNoteAccessRequest>): CreatePaperNoteAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.note_id = "";
        message.open_status = false;
        if (value !== undefined)
            reflectionMergePartial<CreatePaperNoteAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePaperNoteAccessRequest): CreatePaperNoteAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string note_id */ 1:
                    message.note_id = reader.string();
                    break;
                case /* bool open_status */ 2:
                    message.open_status = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePaperNoteAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string note_id = 1; */
        if (message.note_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.note_id);
        /* bool open_status = 2; */
        if (message.open_status !== false)
            writer.tag(2, WireType.Varint).bool(message.open_status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.CreatePaperNoteAccessRequest
 */
export const CreatePaperNoteAccessRequest = new CreatePaperNoteAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePaperNoteAccessResponse$Type extends MessageType<CreatePaperNoteAccessResponse> {
    constructor() {
        super("note.CreatePaperNoteAccessResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePaperNoteAccessResponse>): CreatePaperNoteAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<CreatePaperNoteAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePaperNoteAccessResponse): CreatePaperNoteAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePaperNoteAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.CreatePaperNoteAccessResponse
 */
export const CreatePaperNoteAccessResponse = new CreatePaperNoteAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperNoteAccessRequest$Type extends MessageType<GetPaperNoteAccessRequest> {
    constructor() {
        super("note.GetPaperNoteAccessRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperNoteAccessRequest>): GetPaperNoteAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperNoteAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperNoteAccessRequest): GetPaperNoteAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperNoteAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetPaperNoteAccessRequest
 */
export const GetPaperNoteAccessRequest = new GetPaperNoteAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperNoteAccessResponse$Type extends MessageType<GetPaperNoteAccessResponse> {
    constructor() {
        super("note.GetPaperNoteAccessResponse", [
            { no: 1, name: "access", kind: "message", T: () => PaperNoteAccess }
        ]);
    }
    create(value?: PartialMessage<GetPaperNoteAccessResponse>): GetPaperNoteAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaperNoteAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperNoteAccessResponse): GetPaperNoteAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* note.PaperNoteAccess access */ 1:
                    message.access = PaperNoteAccess.internalBinaryRead(reader, reader.uint32(), options, message.access);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperNoteAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* note.PaperNoteAccess access = 1; */
        if (message.access)
            PaperNoteAccess.internalBinaryWrite(message.access, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetPaperNoteAccessResponse
 */
export const GetPaperNoteAccessResponse = new GetPaperNoteAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperNoteAccessByNoteIdRequest$Type extends MessageType<GetPaperNoteAccessByNoteIdRequest> {
    constructor() {
        super("note.GetPaperNoteAccessByNoteIdRequest", [
            { no: 1, name: "note_id", kind: "scalar", localName: "note_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperNoteAccessByNoteIdRequest>): GetPaperNoteAccessByNoteIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.note_id = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperNoteAccessByNoteIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperNoteAccessByNoteIdRequest): GetPaperNoteAccessByNoteIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string note_id */ 1:
                    message.note_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperNoteAccessByNoteIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string note_id = 1; */
        if (message.note_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.note_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetPaperNoteAccessByNoteIdRequest
 */
export const GetPaperNoteAccessByNoteIdRequest = new GetPaperNoteAccessByNoteIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperNoteAccessByNoteIdResponse$Type extends MessageType<GetPaperNoteAccessByNoteIdResponse> {
    constructor() {
        super("note.GetPaperNoteAccessByNoteIdResponse", [
            { no: 1, name: "access", kind: "message", T: () => PaperNoteAccess }
        ]);
    }
    create(value?: PartialMessage<GetPaperNoteAccessByNoteIdResponse>): GetPaperNoteAccessByNoteIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaperNoteAccessByNoteIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperNoteAccessByNoteIdResponse): GetPaperNoteAccessByNoteIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* note.PaperNoteAccess access */ 1:
                    message.access = PaperNoteAccess.internalBinaryRead(reader, reader.uint32(), options, message.access);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperNoteAccessByNoteIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* note.PaperNoteAccess access = 1; */
        if (message.access)
            PaperNoteAccess.internalBinaryWrite(message.access, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.GetPaperNoteAccessByNoteIdResponse
 */
export const GetPaperNoteAccessByNoteIdResponse = new GetPaperNoteAccessByNoteIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaperNoteAccessRequest$Type extends MessageType<UpdatePaperNoteAccessRequest> {
    constructor() {
        super("note.UpdatePaperNoteAccessRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "open_status", kind: "scalar", localName: "open_status", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePaperNoteAccessRequest>): UpdatePaperNoteAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.open_status = false;
        if (value !== undefined)
            reflectionMergePartial<UpdatePaperNoteAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaperNoteAccessRequest): UpdatePaperNoteAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bool open_status */ 2:
                    message.open_status = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaperNoteAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bool open_status = 2; */
        if (message.open_status !== false)
            writer.tag(2, WireType.Varint).bool(message.open_status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.UpdatePaperNoteAccessRequest
 */
export const UpdatePaperNoteAccessRequest = new UpdatePaperNoteAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaperNoteAccessResponse$Type extends MessageType<UpdatePaperNoteAccessResponse> {
    constructor() {
        super("note.UpdatePaperNoteAccessResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePaperNoteAccessResponse>): UpdatePaperNoteAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<UpdatePaperNoteAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaperNoteAccessResponse): UpdatePaperNoteAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaperNoteAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.UpdatePaperNoteAccessResponse
 */
export const UpdatePaperNoteAccessResponse = new UpdatePaperNoteAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaperNoteAccessRequest$Type extends MessageType<DeletePaperNoteAccessRequest> {
    constructor() {
        super("note.DeletePaperNoteAccessRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<DeletePaperNoteAccessRequest>): DeletePaperNoteAccessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeletePaperNoteAccessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaperNoteAccessRequest): DeletePaperNoteAccessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePaperNoteAccessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.DeletePaperNoteAccessRequest
 */
export const DeletePaperNoteAccessRequest = new DeletePaperNoteAccessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaperNoteAccessResponse$Type extends MessageType<DeletePaperNoteAccessResponse> {
    constructor() {
        super("note.DeletePaperNoteAccessResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePaperNoteAccessResponse>): DeletePaperNoteAccessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<DeletePaperNoteAccessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaperNoteAccessResponse): DeletePaperNoteAccessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePaperNoteAccessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.DeletePaperNoteAccessResponse
 */
export const DeletePaperNoteAccessResponse = new DeletePaperNoteAccessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadNotePdfRequest$Type extends MessageType<DownloadNotePdfRequest> {
    constructor() {
        super("note.DownloadNotePdfRequest", [
            { no: 1, name: "note_id", kind: "scalar", localName: "note_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<DownloadNotePdfRequest>): DownloadNotePdfRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.note_id = "";
        if (value !== undefined)
            reflectionMergePartial<DownloadNotePdfRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadNotePdfRequest): DownloadNotePdfRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string note_id */ 1:
                    message.note_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadNotePdfRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string note_id = 1; */
        if (message.note_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.note_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.DownloadNotePdfRequest
 */
export const DownloadNotePdfRequest = new DownloadNotePdfRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadNoteMarkdownRequest$Type extends MessageType<DownloadNoteMarkdownRequest> {
    constructor() {
        super("note.DownloadNoteMarkdownRequest", [
            { no: 1, name: "note_id", kind: "scalar", localName: "note_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<DownloadNoteMarkdownRequest>): DownloadNoteMarkdownRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.note_id = "";
        if (value !== undefined)
            reflectionMergePartial<DownloadNoteMarkdownRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadNoteMarkdownRequest): DownloadNoteMarkdownRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string note_id */ 1:
                    message.note_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadNoteMarkdownRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string note_id = 1; */
        if (message.note_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.note_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message note.DownloadNoteMarkdownRequest
 */
export const DownloadNoteMarkdownRequest = new DownloadNoteMarkdownRequest$Type();
