// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/oss/OSS.proto" (package "oss", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @api_path: /userDoc/GetUploadToken
 * @method: GET
 * @content-type: application/json
 * @summary: 获取minio上传token【需要使用服务token才能访问】
 *
 * @generated from protobuf message oss.GetUploadTokenRequest
 */
export interface GetUploadTokenRequest {
    /**
     * @generated from protobuf field: oss.UploadFileType fileType = 1
     */
    fileType: UploadFileType;
    /**
     * @generated from protobuf field: string fileSHA256 = 2
     */
    fileSHA256: string; // 文件fileSHA256
    /**
     * @generated from protobuf field: uint64 fileSize = 3
     */
    fileSize: bigint;
    /**
     * @generated from protobuf field: string fileName = 4
     */
    fileName: string; // 文件名
    /**
     * @generated from protobuf field: uint64 filePage = 5
     */
    filePage: bigint; // 文件页数
    /**
     * @generated from protobuf field: string folderId = 6
     */
    folderId: string; // 文件夹ID
    /**
     * @generated from protobuf field: oss.OSSBucketEnum bucketEnum = 7
     */
    bucketEnum: OSSBucketEnum; // bucket
    /**
     * @generated from protobuf field: map<string, string> bizMetadata = 8
     */
    bizMetadata: {
        [key: string]: string;
    }; // 业务元数据
    /**
     * @generated from protobuf field: optional string callbackTopic = 9
     */
    callbackTopic?: string; // 回调主题
    /**
     * @generated from protobuf field: oss.OSSKeyPolicyEnum keyPolicy = 10
     */
    keyPolicy: OSSKeyPolicyEnum; // key策略
    /**
     * 如果是本地文件上传，则需要提供本地文件路径
     *
     * @generated from protobuf field: string localFilePath = 11
     */
    localFilePath: string; // 本地文件路径
}
/**
 * @generated from protobuf message oss.GetUploadTokenResponse
 */
export interface GetUploadTokenResponse {
    /**
     * 是否需要上传
     *
     * @generated from protobuf field: bool needUpload = 1
     */
    needUpload: boolean;
    /**
     * 上传信息
     *
     * @generated from protobuf field: oss.UploadS3Info uploadInfo = 2
     */
    uploadInfo?: UploadS3Info;
    /**
     * oss记录
     *
     * @generated from protobuf field: oss.OSSS3Info ossInfo = 3
     */
    ossInfo?: OSSS3Info;
    /**
     * @generated from protobuf field: string publicUrl = 4
     */
    publicUrl: string;
    /**
     * 上传文件的类型
     *
     * @generated from protobuf field: oss.UploadFileType fileType = 5
     */
    fileType: UploadFileType;
}
/**
 * @generated from protobuf message oss.UploadS3Info
 */
export interface UploadS3Info {
    /**
     * 上传URL
     *
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * HTTP方法
     *
     * @generated from protobuf field: string method = 2
     */
    method: string;
    /**
     * HTTP头
     *
     * @generated from protobuf field: map<string, string> headers = 3
     */
    headers: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message oss.OSSS3Info
 */
export interface OSSS3Info {
    /**
     * 存储桶名称
     *
     * @generated from protobuf field: string bucketName = 1
     */
    bucketName: string;
    /**
     * 对象键（文件路径）
     *
     * @generated from protobuf field: string objectKey = 2
     */
    objectKey: string;
    /**
     * 原始文件名
     *
     * @generated from protobuf field: string fileName = 3
     */
    fileName: string;
    /**
     * 文件大小（字节）
     *
     * @generated from protobuf field: string fileSize = 4
     */
    fileSize: string;
    /**
     * 文件hash值（sha256）
     *
     * @generated from protobuf field: string fileSHA256 = 5
     */
    fileSHA256: string;
}
/**
 * @api_path: /services/oss/s3/getDownloadTeamUrl
 * @method: GET
 * @content-type: application/json
 * @summary: 获取minio解析文件的下载地址
 *
 * @generated from protobuf message oss.GetS3DownloadTempUrlReq
 */
export interface GetS3DownloadTempUrlReq {
    /**
     * 文件fileSHA256
     *
     * @generated from protobuf field: string fileSHA256 = 1
     */
    fileSHA256: string;
    /**
     * pdf文件Id
     *
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * 文献id
     *
     * @generated from protobuf field: string userDocId = 3
     */
    userDocId: string;
    /**
     * 文件id
     *
     * @generated from protobuf field: string paperId = 4
     */
    paperId: string;
    /**
     * 数据类型
     *
     * @generated from protobuf field: oss.ParsedDataEnum dataType = 5
     */
    dataType: ParsedDataEnum;
    /**
     * version
     *
     * @generated from protobuf field: string version = 6
     */
    version: string;
}
/**
 * @generated from protobuf message oss.GetS3DownloadTempUrlResp
 */
export interface GetS3DownloadTempUrlResp {
    /**
     * 文件fileSHA256
     *
     * @generated from protobuf field: string fileSHA256 = 1
     */
    fileSHA256: string;
    /**
     * 文件临时访问或者下载地址
     *
     * @generated from protobuf field: string downloadTempUrl = 2
     */
    downloadTempUrl: string;
}
/**
 * OSS存储桶枚举
 *
 * @generated from protobuf enum oss.OSSBucketEnum
 */
export enum OSSBucketEnum {
    /**
     * @generated from protobuf enum value: PDF = 0;
     */
    PDF = 0,
    /**
     * @generated from protobuf enum value: FULL_TRANSLATE_PDF = 1;
     */
    FULL_TRANSLATE_PDF = 1,
    /**
     * @generated from protobuf enum value: PUBLIC = 2;
     */
    PUBLIC = 2,
    /**
     * @generated from protobuf enum value: TEMP = 3;
     */
    TEMP = 3
}
/**
 * OSS存储桶key策略
 *
 * @generated from protobuf enum oss.OSSKeyPolicyEnum
 */
export enum OSSKeyPolicyEnum {
    /**
     * 默认策略
     *
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * 上传pdf策略
     *
     * @generated from protobuf enum value: UPLOAD_PDF = 1;
     */
    UPLOAD_PDF = 1,
    /**
     * 上传公共桶的短链接策略
     *
     * @generated from protobuf enum value: UPLOAD_PUBLIC_SHORT = 2;
     */
    UPLOAD_PUBLIC_SHORT = 2
}
/**
 * 上传文件的类型
 *
 * @generated from protobuf enum oss.UploadFileType
 */
export enum UploadFileType {
    /**
     * 文件流上传
     *
     * @generated from protobuf enum value: FILE_STREAM = 0;
     */
    FILE_STREAM = 0,
    /**
     * 本地文件上传
     *
     * @generated from protobuf enum value: LOCAL_FILE = 1;
     */
    LOCAL_FILE = 1
}
/**
 * 解析数据存储类型
 *
 * @generated from protobuf enum oss.ParsedDataEnum
 */
export enum ParsedDataEnum {
    /**
     * 元数据文件类型
     *
     * @generated from protobuf enum value: METADATA = 0;
     */
    METADATA = 0,
    /**
     * 段落文件类型
     *
     * @generated from protobuf enum value: PARAGRAPHS = 1;
     */
    PARAGRAPHS = 1,
    /**
     * 全文文件类型
     *
     * @generated from protobuf enum value: FULLTEXT = 2;
     */
    FULLTEXT = 2,
    /**
     * 图片和表格文件类型
     *
     * @generated from protobuf enum value: FIGURE_AND_TABLE = 3;
     */
    FIGURE_AND_TABLE = 3,
    /**
     * markdown文件类型
     *
     * @generated from protobuf enum value: MARKDOWN = 4;
     */
    MARKDOWN = 4,
    /**
     * 页面块文件类型
     *
     * @generated from protobuf enum value: PAGE_BLOCK = 5;
     */
    PAGE_BLOCK = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class GetUploadTokenRequest$Type extends MessageType<GetUploadTokenRequest> {
    constructor() {
        super("oss.GetUploadTokenRequest", [
            { no: 1, name: "fileType", kind: "enum", T: () => ["oss.UploadFileType", UploadFileType] },
            { no: 2, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fileSize", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fileName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "filePage", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "bucketEnum", kind: "enum", T: () => ["oss.OSSBucketEnum", OSSBucketEnum] },
            { no: 8, name: "bizMetadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 9, name: "callbackTopic", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "keyPolicy", kind: "enum", T: () => ["oss.OSSKeyPolicyEnum", OSSKeyPolicyEnum] },
            { no: 11, name: "localFilePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUploadTokenRequest>): GetUploadTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileType = 0;
        message.fileSHA256 = "";
        message.fileSize = 0n;
        message.fileName = "";
        message.filePage = 0n;
        message.folderId = "";
        message.bucketEnum = 0;
        message.bizMetadata = {};
        message.keyPolicy = 0;
        message.localFilePath = "";
        if (value !== undefined)
            reflectionMergePartial<GetUploadTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUploadTokenRequest): GetUploadTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* oss.UploadFileType fileType */ 1:
                    message.fileType = reader.int32();
                    break;
                case /* string fileSHA256 */ 2:
                    message.fileSHA256 = reader.string();
                    break;
                case /* uint64 fileSize */ 3:
                    message.fileSize = reader.uint64().toBigInt();
                    break;
                case /* string fileName */ 4:
                    message.fileName = reader.string();
                    break;
                case /* uint64 filePage */ 5:
                    message.filePage = reader.uint64().toBigInt();
                    break;
                case /* string folderId */ 6:
                    message.folderId = reader.string();
                    break;
                case /* oss.OSSBucketEnum bucketEnum */ 7:
                    message.bucketEnum = reader.int32();
                    break;
                case /* map<string, string> bizMetadata */ 8:
                    this.binaryReadMap8(message.bizMetadata, reader, options);
                    break;
                case /* optional string callbackTopic */ 9:
                    message.callbackTopic = reader.string();
                    break;
                case /* oss.OSSKeyPolicyEnum keyPolicy */ 10:
                    message.keyPolicy = reader.int32();
                    break;
                case /* string localFilePath */ 11:
                    message.localFilePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: GetUploadTokenRequest["bizMetadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetUploadTokenRequest["bizMetadata"] | undefined, val: GetUploadTokenRequest["bizMetadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for oss.GetUploadTokenRequest.bizMetadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetUploadTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* oss.UploadFileType fileType = 1; */
        if (message.fileType !== 0)
            writer.tag(1, WireType.Varint).int32(message.fileType);
        /* string fileSHA256 = 2; */
        if (message.fileSHA256 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fileSHA256);
        /* uint64 fileSize = 3; */
        if (message.fileSize !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.fileSize);
        /* string fileName = 4; */
        if (message.fileName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fileName);
        /* uint64 filePage = 5; */
        if (message.filePage !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.filePage);
        /* string folderId = 6; */
        if (message.folderId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.folderId);
        /* oss.OSSBucketEnum bucketEnum = 7; */
        if (message.bucketEnum !== 0)
            writer.tag(7, WireType.Varint).int32(message.bucketEnum);
        /* map<string, string> bizMetadata = 8; */
        for (let k of globalThis.Object.keys(message.bizMetadata))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.bizMetadata[k]).join();
        /* optional string callbackTopic = 9; */
        if (message.callbackTopic !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.callbackTopic);
        /* oss.OSSKeyPolicyEnum keyPolicy = 10; */
        if (message.keyPolicy !== 0)
            writer.tag(10, WireType.Varint).int32(message.keyPolicy);
        /* string localFilePath = 11; */
        if (message.localFilePath !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.localFilePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oss.GetUploadTokenRequest
 */
export const GetUploadTokenRequest = new GetUploadTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUploadTokenResponse$Type extends MessageType<GetUploadTokenResponse> {
    constructor() {
        super("oss.GetUploadTokenResponse", [
            { no: 1, name: "needUpload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "uploadInfo", kind: "message", T: () => UploadS3Info },
            { no: 3, name: "ossInfo", kind: "message", T: () => OSSS3Info },
            { no: 4, name: "publicUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "fileType", kind: "enum", T: () => ["oss.UploadFileType", UploadFileType] }
        ]);
    }
    create(value?: PartialMessage<GetUploadTokenResponse>): GetUploadTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needUpload = false;
        message.publicUrl = "";
        message.fileType = 0;
        if (value !== undefined)
            reflectionMergePartial<GetUploadTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUploadTokenResponse): GetUploadTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool needUpload */ 1:
                    message.needUpload = reader.bool();
                    break;
                case /* oss.UploadS3Info uploadInfo */ 2:
                    message.uploadInfo = UploadS3Info.internalBinaryRead(reader, reader.uint32(), options, message.uploadInfo);
                    break;
                case /* oss.OSSS3Info ossInfo */ 3:
                    message.ossInfo = OSSS3Info.internalBinaryRead(reader, reader.uint32(), options, message.ossInfo);
                    break;
                case /* string publicUrl */ 4:
                    message.publicUrl = reader.string();
                    break;
                case /* oss.UploadFileType fileType */ 5:
                    message.fileType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUploadTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool needUpload = 1; */
        if (message.needUpload !== false)
            writer.tag(1, WireType.Varint).bool(message.needUpload);
        /* oss.UploadS3Info uploadInfo = 2; */
        if (message.uploadInfo)
            UploadS3Info.internalBinaryWrite(message.uploadInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* oss.OSSS3Info ossInfo = 3; */
        if (message.ossInfo)
            OSSS3Info.internalBinaryWrite(message.ossInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string publicUrl = 4; */
        if (message.publicUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.publicUrl);
        /* oss.UploadFileType fileType = 5; */
        if (message.fileType !== 0)
            writer.tag(5, WireType.Varint).int32(message.fileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oss.GetUploadTokenResponse
 */
export const GetUploadTokenResponse = new GetUploadTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadS3Info$Type extends MessageType<UploadS3Info> {
    constructor() {
        super("oss.UploadS3Info", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "method", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<UploadS3Info>): UploadS3Info {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.method = "";
        message.headers = {};
        if (value !== undefined)
            reflectionMergePartial<UploadS3Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadS3Info): UploadS3Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string method */ 2:
                    message.method = reader.string();
                    break;
                case /* map<string, string> headers */ 3:
                    this.binaryReadMap3(message.headers, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: UploadS3Info["headers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UploadS3Info["headers"] | undefined, val: UploadS3Info["headers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for oss.UploadS3Info.headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: UploadS3Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string method = 2; */
        if (message.method !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.method);
        /* map<string, string> headers = 3; */
        for (let k of globalThis.Object.keys(message.headers))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.headers[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oss.UploadS3Info
 */
export const UploadS3Info = new UploadS3Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OSSS3Info$Type extends MessageType<OSSS3Info> {
    constructor() {
        super("oss.OSSS3Info", [
            { no: 1, name: "bucketName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "objectKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fileName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "fileSize", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OSSS3Info>): OSSS3Info {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketName = "";
        message.objectKey = "";
        message.fileName = "";
        message.fileSize = "";
        message.fileSHA256 = "";
        if (value !== undefined)
            reflectionMergePartial<OSSS3Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OSSS3Info): OSSS3Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bucketName */ 1:
                    message.bucketName = reader.string();
                    break;
                case /* string objectKey */ 2:
                    message.objectKey = reader.string();
                    break;
                case /* string fileName */ 3:
                    message.fileName = reader.string();
                    break;
                case /* string fileSize */ 4:
                    message.fileSize = reader.string();
                    break;
                case /* string fileSHA256 */ 5:
                    message.fileSHA256 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OSSS3Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bucketName = 1; */
        if (message.bucketName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bucketName);
        /* string objectKey = 2; */
        if (message.objectKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.objectKey);
        /* string fileName = 3; */
        if (message.fileName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileName);
        /* string fileSize = 4; */
        if (message.fileSize !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fileSize);
        /* string fileSHA256 = 5; */
        if (message.fileSHA256 !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.fileSHA256);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oss.OSSS3Info
 */
export const OSSS3Info = new OSSS3Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetS3DownloadTempUrlReq$Type extends MessageType<GetS3DownloadTempUrlReq> {
    constructor() {
        super("oss.GetS3DownloadTempUrlReq", [
            { no: 1, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "userDocId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dataType", kind: "enum", T: () => ["oss.ParsedDataEnum", ParsedDataEnum] },
            { no: 6, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetS3DownloadTempUrlReq>): GetS3DownloadTempUrlReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileSHA256 = "";
        message.pdfId = "";
        message.userDocId = "";
        message.paperId = "";
        message.dataType = 0;
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<GetS3DownloadTempUrlReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetS3DownloadTempUrlReq): GetS3DownloadTempUrlReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fileSHA256 */ 1:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* string userDocId */ 3:
                    message.userDocId = reader.string();
                    break;
                case /* string paperId */ 4:
                    message.paperId = reader.string();
                    break;
                case /* oss.ParsedDataEnum dataType */ 5:
                    message.dataType = reader.int32();
                    break;
                case /* string version */ 6:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetS3DownloadTempUrlReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fileSHA256 = 1; */
        if (message.fileSHA256 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileSHA256);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* string userDocId = 3; */
        if (message.userDocId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userDocId);
        /* string paperId = 4; */
        if (message.paperId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.paperId);
        /* oss.ParsedDataEnum dataType = 5; */
        if (message.dataType !== 0)
            writer.tag(5, WireType.Varint).int32(message.dataType);
        /* string version = 6; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oss.GetS3DownloadTempUrlReq
 */
export const GetS3DownloadTempUrlReq = new GetS3DownloadTempUrlReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetS3DownloadTempUrlResp$Type extends MessageType<GetS3DownloadTempUrlResp> {
    constructor() {
        super("oss.GetS3DownloadTempUrlResp", [
            { no: 1, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "downloadTempUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetS3DownloadTempUrlResp>): GetS3DownloadTempUrlResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileSHA256 = "";
        message.downloadTempUrl = "";
        if (value !== undefined)
            reflectionMergePartial<GetS3DownloadTempUrlResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetS3DownloadTempUrlResp): GetS3DownloadTempUrlResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fileSHA256 */ 1:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string downloadTempUrl */ 2:
                    message.downloadTempUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetS3DownloadTempUrlResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fileSHA256 = 1; */
        if (message.fileSHA256 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileSHA256);
        /* string downloadTempUrl = 2; */
        if (message.downloadTempUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.downloadTempUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oss.GetS3DownloadTempUrlResp
 */
export const GetS3DownloadTempUrlResp = new GetS3DownloadTempUrlResp$Type();
