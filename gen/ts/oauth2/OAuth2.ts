// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/oauth2/OAuth2.proto" (package "oauth2", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @api_path: /api/oauth2/RSAKey
 * @method: GET
 * @content-type: application/json
 * @summary: 获取RSA公钥
 *
 * @generated from protobuf message oauth2.GetRSAKeyRequest
 */
export interface GetRSAKeyRequest {
}
/**
 * @generated from protobuf message oauth2.GetRSAKeyResponse
 */
export interface GetRSAKeyResponse {
    /**
     * @generated from protobuf field: string publicKey = 1
     */
    publicKey: string;
}
/**
 * @api_path: /api/oauth2/authorize/code
 * @method: GET
 * @content-type: application/json
 * @summary: 获取授权码
 *
 * @generated from protobuf message oauth2.GetAuthCodeRequest
 */
export interface GetAuthCodeRequest {
    /**
     * @generated from protobuf field: string clientId = 1
     */
    clientId: string;
    /**
     * @generated from protobuf field: string userId = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string redirectUri = 3
     */
    redirectUri: string;
    /**
     * @generated from protobuf field: string scope = 4
     */
    scope: string;
}
/**
 * @generated from protobuf message oauth2.GetAuthCodeResponse
 */
export interface GetAuthCodeResponse {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
}
/**
 * @api_path: /api/oauth2/authorize/sign_in
 * @method: POST
 * @content-type: application/json
 * @summary: 登录/获取访问令牌
 *
 * @generated from protobuf message oauth2.SignInAuthCodeRequest
 */
export interface SignInAuthCodeRequest {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string; // 用户名
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string; // 密码
}
/**
 * @generated from protobuf message oauth2.SignInAuthCodeResponse
 */
export interface SignInAuthCodeResponse {
    /**
     * @generated from protobuf field: string accessToken = 1
     */
    accessToken: string; // 访问令牌
    /**
     * @generated from protobuf field: string refreshToken = 2
     */
    refreshToken: string; // 刷新令牌
    /**
     * @generated from protobuf field: uint64 expiresAt = 3
     */
    expiresAt: bigint; // 过期时间
    /**
     * @generated from protobuf field: uint64 expiresIn = 4
     */
    expiresIn: bigint; // 过期时间（秒）
}
/**
 * @api_path: /api/oauth2/authorize/refresh
 * @method: GET
 * @content-type: application/json
 * @summary: 刷新令牌请求
 *
 * @generated from protobuf message oauth2.RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * @generated from protobuf field: string refresh_token = 1
     */
    refresh_token: string; // 刷新令牌
    /**
     * @generated from protobuf field: string scope = 2
     */
    scope: string; // 设备信息
}
/**
 * @generated from protobuf message oauth2.RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * @generated from protobuf field: string accessToken = 1
     */
    accessToken: string; // 访问令牌
    /**
     * @generated from protobuf field: string refreshToken = 2
     */
    refreshToken: string; // 刷新令牌
    /**
     * @generated from protobuf field: uint64 expiresAt = 3
     */
    expiresAt: bigint; // 过期时间
    /**
     * @generated from protobuf field: uint64 expiresIn = 4
     */
    expiresIn: bigint; // 过期时间（秒）
}
/**
 * @api_path: /api/oauth2/authorize/validate
 * @method: POST
 * @content-type: application/json
 * @summary: 验证令牌
 *
 * @generated from protobuf message oauth2.ValidateRequest
 */
export interface ValidateRequest {
    /**
     * @generated from protobuf field: string accessToken = 1
     */
    accessToken: string; // 访问令牌
}
/**
 * @generated from protobuf message oauth2.ValidateResponse
 */
export interface ValidateResponse {
    /**
     * @generated from protobuf field: bool valid = 1
     */
    valid: boolean; // 是否有效
}
/**
 * @api_path: /api/oauth2/authorize/sign_out
 * @method: POST
 * @content-type: application/json
 * @summary: 登出/撤销访问令牌
 *
 * @generated from protobuf message oauth2.SignOutRequest
 */
export interface SignOutRequest {
}
/**
 * @generated from protobuf message oauth2.SignOutResponse
 */
export interface SignOutResponse {
}
/**
 * @api_path: /services/oauth2/authorize/token
 * @method: POST
 * @content-type: application/json
 * @summary: 服务令牌请求
 *
 * @generated from protobuf message oauth2.ServiceTokenRequest
 */
export interface ServiceTokenRequest {
    /**
     * @generated from protobuf field: string serviceId = 1
     */
    serviceId: string;
    /**
     * @generated from protobuf field: string serviceName = 2
     */
    serviceName: string;
    /**
     * @generated from protobuf field: string secret = 3
     */
    secret: string;
}
/**
 * @generated from protobuf message oauth2.ServiceTokenResponse
 */
export interface ServiceTokenResponse {
    /**
     * @generated from protobuf field: string accessToken = 1
     */
    accessToken: string;
    /**
     * @generated from protobuf field: string refreshToken = 2
     */
    refreshToken: string;
    /**
     * @generated from protobuf field: uint64 expiresAt = 3
     */
    expiresAt: bigint; // 过期时间
    /**
     * @generated from protobuf field: uint64 expiresIn = 4
     */
    expiresIn: bigint; // 过期时间（秒）
}
// @generated message type with reflection information, may provide speed optimized methods
class GetRSAKeyRequest$Type extends MessageType<GetRSAKeyRequest> {
    constructor() {
        super("oauth2.GetRSAKeyRequest", []);
    }
    create(value?: PartialMessage<GetRSAKeyRequest>): GetRSAKeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRSAKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRSAKeyRequest): GetRSAKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRSAKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.GetRSAKeyRequest
 */
export const GetRSAKeyRequest = new GetRSAKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRSAKeyResponse$Type extends MessageType<GetRSAKeyResponse> {
    constructor() {
        super("oauth2.GetRSAKeyResponse", [
            { no: 1, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetRSAKeyResponse>): GetRSAKeyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKey = "";
        if (value !== undefined)
            reflectionMergePartial<GetRSAKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRSAKeyResponse): GetRSAKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string publicKey */ 1:
                    message.publicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRSAKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string publicKey = 1; */
        if (message.publicKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.GetRSAKeyResponse
 */
export const GetRSAKeyResponse = new GetRSAKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthCodeRequest$Type extends MessageType<GetAuthCodeRequest> {
    constructor() {
        super("oauth2.GetAuthCodeRequest", [
            { no: 1, name: "clientId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "redirectUri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "scope", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAuthCodeRequest>): GetAuthCodeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = "";
        message.userId = "";
        message.redirectUri = "";
        message.scope = "";
        if (value !== undefined)
            reflectionMergePartial<GetAuthCodeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthCodeRequest): GetAuthCodeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string clientId */ 1:
                    message.clientId = reader.string();
                    break;
                case /* string userId */ 2:
                    message.userId = reader.string();
                    break;
                case /* string redirectUri */ 3:
                    message.redirectUri = reader.string();
                    break;
                case /* string scope */ 4:
                    message.scope = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthCodeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string clientId = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string userId = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string redirectUri = 3; */
        if (message.redirectUri !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.redirectUri);
        /* string scope = 4; */
        if (message.scope !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.scope);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.GetAuthCodeRequest
 */
export const GetAuthCodeRequest = new GetAuthCodeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthCodeResponse$Type extends MessageType<GetAuthCodeResponse> {
    constructor() {
        super("oauth2.GetAuthCodeResponse", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAuthCodeResponse>): GetAuthCodeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        if (value !== undefined)
            reflectionMergePartial<GetAuthCodeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthCodeResponse): GetAuthCodeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthCodeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.GetAuthCodeResponse
 */
export const GetAuthCodeResponse = new GetAuthCodeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignInAuthCodeRequest$Type extends MessageType<SignInAuthCodeRequest> {
    constructor() {
        super("oauth2.SignInAuthCodeRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<SignInAuthCodeRequest>): SignInAuthCodeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<SignInAuthCodeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignInAuthCodeRequest): SignInAuthCodeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignInAuthCodeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.SignInAuthCodeRequest
 */
export const SignInAuthCodeRequest = new SignInAuthCodeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignInAuthCodeResponse$Type extends MessageType<SignInAuthCodeResponse> {
    constructor() {
        super("oauth2.SignInAuthCodeResponse", [
            { no: 1, name: "accessToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refreshToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expiresAt", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "expiresIn", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SignInAuthCodeResponse>): SignInAuthCodeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.refreshToken = "";
        message.expiresAt = 0n;
        message.expiresIn = 0n;
        if (value !== undefined)
            reflectionMergePartial<SignInAuthCodeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignInAuthCodeResponse): SignInAuthCodeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string accessToken */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* string refreshToken */ 2:
                    message.refreshToken = reader.string();
                    break;
                case /* uint64 expiresAt */ 3:
                    message.expiresAt = reader.uint64().toBigInt();
                    break;
                case /* uint64 expiresIn */ 4:
                    message.expiresIn = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignInAuthCodeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string accessToken = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* string refreshToken = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        /* uint64 expiresAt = 3; */
        if (message.expiresAt !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.expiresAt);
        /* uint64 expiresIn = 4; */
        if (message.expiresIn !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.expiresIn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.SignInAuthCodeResponse
 */
export const SignInAuthCodeResponse = new SignInAuthCodeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshTokenRequest$Type extends MessageType<RefreshTokenRequest> {
    constructor() {
        super("oauth2.RefreshTokenRequest", [
            { no: 1, name: "refresh_token", kind: "scalar", localName: "refresh_token", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "scope", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshTokenRequest>): RefreshTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.refresh_token = "";
        message.scope = "";
        if (value !== undefined)
            reflectionMergePartial<RefreshTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshTokenRequest): RefreshTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refresh_token */ 1:
                    message.refresh_token = reader.string();
                    break;
                case /* string scope */ 2:
                    message.scope = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refresh_token = 1; */
        if (message.refresh_token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refresh_token);
        /* string scope = 2; */
        if (message.scope !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.scope);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.RefreshTokenRequest
 */
export const RefreshTokenRequest = new RefreshTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshTokenResponse$Type extends MessageType<RefreshTokenResponse> {
    constructor() {
        super("oauth2.RefreshTokenResponse", [
            { no: 1, name: "accessToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refreshToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expiresAt", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "expiresIn", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshTokenResponse>): RefreshTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.refreshToken = "";
        message.expiresAt = 0n;
        message.expiresIn = 0n;
        if (value !== undefined)
            reflectionMergePartial<RefreshTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshTokenResponse): RefreshTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string accessToken */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* string refreshToken */ 2:
                    message.refreshToken = reader.string();
                    break;
                case /* uint64 expiresAt */ 3:
                    message.expiresAt = reader.uint64().toBigInt();
                    break;
                case /* uint64 expiresIn */ 4:
                    message.expiresIn = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string accessToken = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* string refreshToken = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        /* uint64 expiresAt = 3; */
        if (message.expiresAt !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.expiresAt);
        /* uint64 expiresIn = 4; */
        if (message.expiresIn !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.expiresIn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.RefreshTokenResponse
 */
export const RefreshTokenResponse = new RefreshTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateRequest$Type extends MessageType<ValidateRequest> {
    constructor() {
        super("oauth2.ValidateRequest", [
            { no: 1, name: "accessToken", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<ValidateRequest>): ValidateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateRequest): ValidateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string accessToken */ 1:
                    message.accessToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string accessToken = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.ValidateRequest
 */
export const ValidateRequest = new ValidateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateResponse$Type extends MessageType<ValidateResponse> {
    constructor() {
        super("oauth2.ValidateResponse", [
            { no: 1, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateResponse>): ValidateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valid = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateResponse): ValidateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool valid */ 1:
                    message.valid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool valid = 1; */
        if (message.valid !== false)
            writer.tag(1, WireType.Varint).bool(message.valid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.ValidateResponse
 */
export const ValidateResponse = new ValidateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignOutRequest$Type extends MessageType<SignOutRequest> {
    constructor() {
        super("oauth2.SignOutRequest", []);
    }
    create(value?: PartialMessage<SignOutRequest>): SignOutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SignOutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignOutRequest): SignOutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignOutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.SignOutRequest
 */
export const SignOutRequest = new SignOutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignOutResponse$Type extends MessageType<SignOutResponse> {
    constructor() {
        super("oauth2.SignOutResponse", []);
    }
    create(value?: PartialMessage<SignOutResponse>): SignOutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SignOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignOutResponse): SignOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.SignOutResponse
 */
export const SignOutResponse = new SignOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceTokenRequest$Type extends MessageType<ServiceTokenRequest> {
    constructor() {
        super("oauth2.ServiceTokenRequest", [
            { no: 1, name: "serviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "serviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<ServiceTokenRequest>): ServiceTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceId = "";
        message.serviceName = "";
        message.secret = "";
        if (value !== undefined)
            reflectionMergePartial<ServiceTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceTokenRequest): ServiceTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string serviceId */ 1:
                    message.serviceId = reader.string();
                    break;
                case /* string serviceName */ 2:
                    message.serviceName = reader.string();
                    break;
                case /* string secret */ 3:
                    message.secret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string serviceId = 1; */
        if (message.serviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceId);
        /* string serviceName = 2; */
        if (message.serviceName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceName);
        /* string secret = 3; */
        if (message.secret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.ServiceTokenRequest
 */
export const ServiceTokenRequest = new ServiceTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceTokenResponse$Type extends MessageType<ServiceTokenResponse> {
    constructor() {
        super("oauth2.ServiceTokenResponse", [
            { no: 1, name: "accessToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refreshToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expiresAt", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "expiresIn", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceTokenResponse>): ServiceTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.refreshToken = "";
        message.expiresAt = 0n;
        message.expiresIn = 0n;
        if (value !== undefined)
            reflectionMergePartial<ServiceTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceTokenResponse): ServiceTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string accessToken */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* string refreshToken */ 2:
                    message.refreshToken = reader.string();
                    break;
                case /* uint64 expiresAt */ 3:
                    message.expiresAt = reader.uint64().toBigInt();
                    break;
                case /* uint64 expiresIn */ 4:
                    message.expiresIn = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string accessToken = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* string refreshToken = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        /* uint64 expiresAt = 3; */
        if (message.expiresAt !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.expiresAt);
        /* uint64 expiresIn = 4; */
        if (message.expiresIn !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.expiresIn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message oauth2.ServiceTokenResponse
 */
export const ServiceTokenResponse = new ServiceTokenResponse$Type();
