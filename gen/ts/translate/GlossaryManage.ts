// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/translate/GlossaryManage.proto" (package "translate", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @api_path: /api/glossary/add
 * @method: POST
 * @content-type: application/json
 * @summary: 添加术语
 *
 * @generated from protobuf message translate.AddGlossaryReq
 */
export interface AddGlossaryReq {
    /**
     * 原文
     *
     * @generated from protobuf field: string originalText = 1
     */
    originalText: string;
    /**
     * 译文
     *
     * @generated from protobuf field: string translationText = 2
     */
    translationText: string;
    /**
     * 是否区分大小写
     *
     * @generated from protobuf field: bool matchCase = 3
     */
    matchCase: boolean;
    /**
     * 是否不翻译该术语
     *
     * @generated from protobuf field: bool ignored = 4
     */
    ignored: boolean;
}
/**
 * @generated from protobuf message translate.AddGlossaryResponse
 */
export interface AddGlossaryResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/glossary/update
 * @method: POST
 * @content-type: application/json
 * @summary: 编辑术语
 *
 * @generated from protobuf message translate.UpdateGlossaryReq
 */
export interface UpdateGlossaryReq {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 原文
     *
     * @generated from protobuf field: string originalText = 2
     */
    originalText: string;
    /**
     * 译文
     *
     * @generated from protobuf field: string translationText = 3
     */
    translationText: string;
    /**
     * 是否区分大小写
     *
     * @generated from protobuf field: bool matchCase = 4
     */
    matchCase: boolean;
    /**
     * 是否不翻译该术语
     *
     * @generated from protobuf field: bool ignored = 5
     */
    ignored: boolean;
}
/**
 * @api_path: /api/glossary/delete
 * @method: POST
 * @content-type: application/json
 * @summary: 删除术语
 *
 * @generated from protobuf message translate.DeleteGlossaryReq
 */
export interface DeleteGlossaryReq {
    /**
     * @generated from protobuf field: repeated string ids = 1
     */
    ids: string[];
}
/**
 * @api_path: /api/glossary/list
 * @method: POST
 * @content-type: application/json
 * @summary: 术语列表
 *
 * @generated from protobuf message translate.GetGlossaryListReq
 */
export interface GetGlossaryListReq {
    /**
     * 搜索术语
     *
     * @generated from protobuf field: optional string searchText = 1
     */
    searchText?: string;
    /**
     * @generated from protobuf field: int32 currentPage = 2
     */
    currentPage: number;
    /**
     * @generated from protobuf field: int32 pageSize = 3
     */
    pageSize: number;
}
/**
 * @generated from protobuf message translate.GetGlossaryListResponse
 */
export interface GetGlossaryListResponse {
    /**
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
    /**
     * @generated from protobuf field: repeated translate.GlossaryItem items = 2
     */
    items: GlossaryItem[];
}
/**
 * @generated from protobuf message translate.GlossaryItem
 */
export interface GlossaryItem {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 原文
     *
     * @generated from protobuf field: string originalText = 2
     */
    originalText: string;
    /**
     * 译文
     *
     * @generated from protobuf field: string translationText = 3
     */
    translationText: string;
    /**
     * 是否区分大小写
     *
     * @generated from protobuf field: bool matchCase = 4
     */
    matchCase: boolean;
    /**
     * 是否不翻译该术语
     *
     * @generated from protobuf field: bool ignored = 5
     */
    ignored: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class AddGlossaryReq$Type extends MessageType<AddGlossaryReq> {
    constructor() {
        super("translate.AddGlossaryReq", [
            { no: 1, name: "originalText", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "translationText", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "matchCase", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "ignored", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AddGlossaryReq>): AddGlossaryReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.originalText = "";
        message.translationText = "";
        message.matchCase = false;
        message.ignored = false;
        if (value !== undefined)
            reflectionMergePartial<AddGlossaryReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddGlossaryReq): AddGlossaryReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string originalText */ 1:
                    message.originalText = reader.string();
                    break;
                case /* string translationText */ 2:
                    message.translationText = reader.string();
                    break;
                case /* bool matchCase */ 3:
                    message.matchCase = reader.bool();
                    break;
                case /* bool ignored */ 4:
                    message.ignored = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddGlossaryReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string originalText = 1; */
        if (message.originalText !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.originalText);
        /* string translationText = 2; */
        if (message.translationText !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.translationText);
        /* bool matchCase = 3; */
        if (message.matchCase !== false)
            writer.tag(3, WireType.Varint).bool(message.matchCase);
        /* bool ignored = 4; */
        if (message.ignored !== false)
            writer.tag(4, WireType.Varint).bool(message.ignored);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.AddGlossaryReq
 */
export const AddGlossaryReq = new AddGlossaryReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddGlossaryResponse$Type extends MessageType<AddGlossaryResponse> {
    constructor() {
        super("translate.AddGlossaryResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddGlossaryResponse>): AddGlossaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<AddGlossaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddGlossaryResponse): AddGlossaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddGlossaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.AddGlossaryResponse
 */
export const AddGlossaryResponse = new AddGlossaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateGlossaryReq$Type extends MessageType<UpdateGlossaryReq> {
    constructor() {
        super("translate.UpdateGlossaryReq", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "originalText", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "translationText", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "matchCase", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "ignored", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateGlossaryReq>): UpdateGlossaryReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.originalText = "";
        message.translationText = "";
        message.matchCase = false;
        message.ignored = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateGlossaryReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateGlossaryReq): UpdateGlossaryReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string originalText */ 2:
                    message.originalText = reader.string();
                    break;
                case /* string translationText */ 3:
                    message.translationText = reader.string();
                    break;
                case /* bool matchCase */ 4:
                    message.matchCase = reader.bool();
                    break;
                case /* bool ignored */ 5:
                    message.ignored = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateGlossaryReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string originalText = 2; */
        if (message.originalText !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.originalText);
        /* string translationText = 3; */
        if (message.translationText !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.translationText);
        /* bool matchCase = 4; */
        if (message.matchCase !== false)
            writer.tag(4, WireType.Varint).bool(message.matchCase);
        /* bool ignored = 5; */
        if (message.ignored !== false)
            writer.tag(5, WireType.Varint).bool(message.ignored);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.UpdateGlossaryReq
 */
export const UpdateGlossaryReq = new UpdateGlossaryReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteGlossaryReq$Type extends MessageType<DeleteGlossaryReq> {
    constructor() {
        super("translate.DeleteGlossaryReq", [
            { no: 1, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteGlossaryReq>): DeleteGlossaryReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<DeleteGlossaryReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteGlossaryReq): DeleteGlossaryReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string ids */ 1:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteGlossaryReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.DeleteGlossaryReq
 */
export const DeleteGlossaryReq = new DeleteGlossaryReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGlossaryListReq$Type extends MessageType<GetGlossaryListReq> {
    constructor() {
        super("translate.GetGlossaryListReq", [
            { no: 1, name: "searchText", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "currentPage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "pageSize", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetGlossaryListReq>): GetGlossaryListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentPage = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetGlossaryListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGlossaryListReq): GetGlossaryListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string searchText */ 1:
                    message.searchText = reader.string();
                    break;
                case /* int32 currentPage */ 2:
                    message.currentPage = reader.int32();
                    break;
                case /* int32 pageSize */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGlossaryListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string searchText = 1; */
        if (message.searchText !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.searchText);
        /* int32 currentPage = 2; */
        if (message.currentPage !== 0)
            writer.tag(2, WireType.Varint).int32(message.currentPage);
        /* int32 pageSize = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetGlossaryListReq
 */
export const GetGlossaryListReq = new GetGlossaryListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGlossaryListResponse$Type extends MessageType<GetGlossaryListResponse> {
    constructor() {
        super("translate.GetGlossaryListResponse", [
            { no: 1, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GlossaryItem }
        ]);
    }
    create(value?: PartialMessage<GetGlossaryListResponse>): GetGlossaryListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0;
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<GetGlossaryListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGlossaryListResponse): GetGlossaryListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                case /* repeated translate.GlossaryItem items */ 2:
                    message.items.push(GlossaryItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGlossaryListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total = 1; */
        if (message.total !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total);
        /* repeated translate.GlossaryItem items = 2; */
        for (let i = 0; i < message.items.length; i++)
            GlossaryItem.internalBinaryWrite(message.items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetGlossaryListResponse
 */
export const GetGlossaryListResponse = new GetGlossaryListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlossaryItem$Type extends MessageType<GlossaryItem> {
    constructor() {
        super("translate.GlossaryItem", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "originalText", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "translationText", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "matchCase", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "ignored", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GlossaryItem>): GlossaryItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.originalText = "";
        message.translationText = "";
        message.matchCase = false;
        message.ignored = false;
        if (value !== undefined)
            reflectionMergePartial<GlossaryItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlossaryItem): GlossaryItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string originalText */ 2:
                    message.originalText = reader.string();
                    break;
                case /* string translationText */ 3:
                    message.translationText = reader.string();
                    break;
                case /* bool matchCase */ 4:
                    message.matchCase = reader.bool();
                    break;
                case /* bool ignored */ 5:
                    message.ignored = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GlossaryItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string originalText = 2; */
        if (message.originalText !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.originalText);
        /* string translationText = 3; */
        if (message.translationText !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.translationText);
        /* bool matchCase = 4; */
        if (message.matchCase !== false)
            writer.tag(4, WireType.Varint).bool(message.matchCase);
        /* bool ignored = 5; */
        if (message.ignored !== false)
            writer.tag(5, WireType.Varint).bool(message.ignored);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GlossaryItem
 */
export const GlossaryItem = new GlossaryItem$Type();
