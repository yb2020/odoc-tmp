// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/paper/Paper.proto" (package "paper", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AuthorBean } from "../user/AuthorBean";
/**
 * @generated from protobuf message paper.PaperVersionInfo
 */
export interface PaperVersionInfo {
    /**
     * @generated from protobuf field: paper.PaperVersionType type = 1
     */
    type: PaperVersionType;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string pdfId = 3
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string jumpUrl = 4
     */
    jumpUrl: string;
    /**
     * @generated from protobuf field: bool curVersion = 5
     */
    curVersion: boolean;
    /**
     * @generated from protobuf field: bool lastVersion = 6
     */
    lastVersion: boolean;
    /**
     * @generated from protobuf field: string datePrefix = 7
     */
    datePrefix: string;
}
/**
 * @api_path: /api/paper/versions
 * @method: GET
 * @content-type: application/json
 * @summary: 获取论文版本列表
 *
 * @generated from protobuf message paper.GetPaperVersionsRequest
 */
export interface GetPaperVersionsRequest {
    /**
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string;
}
/**
 * @generated from protobuf message paper.GetPaperVersionsResponse
 */
export interface GetPaperVersionsResponse {
    /**
     * @generated from protobuf field: repeated paper.PaperVersionInfo publicVersions = 1
     */
    publicVersions: PaperVersionInfo[];
    /**
     * @generated from protobuf field: repeated paper.PaperVersionInfo privateVersions = 2
     */
    privateVersions: PaperVersionInfo[];
}
/**
 * *
 * @api_path: /api/paper/getPaperDetailInfo
 * @method: GET
 * @content-type: application/json
 * @summary: 获取论文详情
 *
 * @generated from protobuf message paper.GetPaperDetailInfoRequest
 */
export interface GetPaperDetailInfoRequest {
    /**
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string;
}
/**
 * 论文详情INFO
 *
 * @generated from protobuf message paper.PaperDetailInfo
 */
export interface PaperDetailInfo {
    /**
     * ==论文基本信息== //
     *
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string; // 论文id
    /**
     * @generated from protobuf field: string title = 2
     */
    title: string; // 标题
    /**
     * @generated from protobuf field: string publishDate = 3
     */
    publishDate: string; // 发布时间
    /**
     * @generated from protobuf field: string originalAbstract = 4
     */
    originalAbstract: string; // 原文摘要
    /**
     * @generated from protobuf field: repeated paper.BasePaperAuthorInfo authorList = 5
     */
    authorList: BasePaperAuthorInfo[]; // 作者信息
    /**
     * @generated from protobuf field: repeated paper.BasePaperTagInfo paperTagList = 6
     */
    paperTagList: BasePaperTagInfo[]; // 论文标签
    /**
     * @generated from protobuf field: int32 referenceCount = 7
     */
    referenceCount: number; // 引用数
    /**
     * @generated from protobuf field: int32 citationCount = 8
     */
    citationCount: number; // 被引用数
    /**
     * @generated from protobuf field: repeated string venues = 9
     */
    venues: string[]; // 会议/期刊列表
    /**
     * @generated from protobuf field: string primaryVenue = 10
     */
    primaryVenue: string; // 主会议/期刊
    /**
     * @generated from protobuf field: repeated string relatedUrls = 11
     */
    relatedUrls: string[]; // 相关url列表
    /**
     * @generated from protobuf field: repeated paper.PaperUrlsBean paperUrlList = 12
     */
    paperUrlList: PaperUrlsBean[]; // 相关url列表
    /**
     * @generated from protobuf field: repeated string venueTags = 13
     */
    venueTags: string[]; // venue标签列表
    /**
     * @generated from protobuf field: string doi = 14
     */
    doi: string; // DOI信息字段
    /**
     * @generated from protobuf field: bool newPaper = 15
     */
    newPaper: boolean; // 标记是否为新生成的论文
    /**
     * ==论文其他字段==//
     *
     * @generated from protobuf field: int32 noteCount = 16
     */
    noteCount: number; // 笔记数
    /**
     * @generated from protobuf field: int32 collectCount = 17
     */
    collectCount: number; // 收藏数
    /**
     * @generated from protobuf field: string pdfId = 18
     */
    pdfId: string; // pdfId
    /**
     * @generated from protobuf field: bool hasPublicPdf = 19
     */
    hasPublicPdf: boolean; // 是否有公开pdf
    /**
     * @generated from protobuf field: bool hasPrivatePdf = 20
     */
    hasPrivatePdf: boolean; // 是否有私有pdf
    /**
     * @generated from protobuf field: int32 questionAnswerCount = 21
     */
    questionAnswerCount: number; // 问答数
    /**
     * @generated from protobuf field: paper.AbstractInfoVo abstractTranslationInfo = 22
     */
    abstractTranslationInfo?: AbstractInfoVo; // 笔记-摘要信息
    /**
     * @generated from protobuf field: bool isCollected = 23
     */
    isCollected: boolean; // 是否收藏了该论文
    /**
     * @generated from protobuf field: repeated paper.PaperResourceVO paperResources = 24
     */
    paperResources: PaperResourceVO[]; // 论文精读数据
    /**
     * @generated from protobuf field: bool showPaperDetail = 25
     */
    showPaperDetail: boolean; // 是否展示论文详情页
    /**
     * @generated from protobuf field: paper.ReadStatusEnum readStatus = 26
     */
    readStatus: ReadStatusEnum; // 读取状态
    /**
     * @generated from protobuf field: uint64 paperCommentedCount = 27
     */
    paperCommentedCount: bigint; // 同行评审的人数
    /**
     * @generated from protobuf field: paper.MachineTranslationInfo machineTranslationInfo = 28
     */
    machineTranslationInfo?: MachineTranslationInfo; // 机器翻译信息
    /**
     * @generated from protobuf field: string userDocId = 29
     */
    userDocId: string; // 用户文档id
    /**
     * @generated from protobuf field: bool showMachineTranslationButton = 30
     */
    showMachineTranslationButton: boolean; // 是否展示机器翻译按钮
}
/**
 * 论文基本信息
 *
 * @generated from protobuf message paper.BasePaperInfo
 */
export interface BasePaperInfo {
    /**
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string; // 论文id
    /**
     * @generated from protobuf field: string title = 2
     */
    title: string; // 标题
    /**
     * @generated from protobuf field: string publishDate = 3
     */
    publishDate: string; // 发布时间
    /**
     * @generated from protobuf field: string originalAbstract = 4
     */
    originalAbstract: string; // 原文摘要
    /**
     * @generated from protobuf field: repeated paper.BasePaperAuthorInfo authorList = 5
     */
    authorList: BasePaperAuthorInfo[]; // 作者信息
    /**
     * @generated from protobuf field: repeated paper.BasePaperTagInfo paperTagList = 6
     */
    paperTagList: BasePaperTagInfo[]; // 论文标签
    /**
     * @generated from protobuf field: int32 referenceCount = 7
     */
    referenceCount: number; // 引用数
    /**
     * @generated from protobuf field: int32 citationCount = 8
     */
    citationCount: number; // 被引用数
    /**
     * @generated from protobuf field: repeated string venues = 9
     */
    venues: string[]; // 会议/期刊列表
    /**
     * @generated from protobuf field: string primaryVenue = 10
     */
    primaryVenue: string; // 主会议/期刊
    /**
     * @generated from protobuf field: repeated string relatedUrls = 11
     */
    relatedUrls: string[]; // 相关url列表
    /**
     * @generated from protobuf field: repeated paper.PaperUrlsBean paperUrlList = 12
     */
    paperUrlList: PaperUrlsBean[]; // 相关url列表
    /**
     * @generated from protobuf field: repeated string venueTags = 13
     */
    venueTags: string[]; // venue标签列表
    /**
     * @generated from protobuf field: string doi = 14
     */
    doi: string; // DOI信息字段
    /**
     * @generated from protobuf field: bool newPaper = 15
     */
    newPaper: boolean; // 标记是否为新生成的论文
}
/**
 * 作者信息
 *
 * @generated from protobuf message paper.BasePaperAuthorInfo
 */
export interface BasePaperAuthorInfo {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // 作者id
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string; // 作者名称
    /**
     * @generated from protobuf field: bool isAuthentication = 3
     */
    isAuthentication: boolean; // 是否认证作者
}
/**
 * 论文标签
 *
 * @generated from protobuf message paper.BasePaperTagInfo
 */
export interface BasePaperTagInfo {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // 标签id
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string; // 标签名称
    /**
     * @generated from protobuf field: int32 level = 3
     */
    level: number; // 标签级别
}
/**
 * 论文url
 *
 * @generated from protobuf message paper.PaperUrlsBean
 */
export interface PaperUrlsBean {
    /**
     * @generated from protobuf field: string sourceType = 1
     */
    sourceType: string; // 源类型
    /**
     * @generated from protobuf field: string url = 2
     */
    url: string; // url
    /**
     * @generated from protobuf field: string publishDate = 3
     */
    publishDate: string; // 发布时间
    /**
     * @generated from protobuf field: string venue = 4
     */
    venue: string; // 会议/期刊
}
/**
 * 摘要信息
 *
 * @generated from protobuf message paper.AbstractInfoVo
 */
export interface AbstractInfoVo {
    /**
     * @generated from protobuf field: user.AuthorBean bestAbsAuthor = 1
     */
    bestAbsAuthor?: AuthorBean; // 最佳摘要作者
    /**
     * @generated from protobuf field: string bestAbsContent = 2
     */
    bestAbsContent: string; // 最佳摘要内容
    /**
     * @generated from protobuf field: int32 totalCount = 3
     */
    totalCount: number; // 总数
    /**
     * @generated from protobuf field: int64 bestAbsModifyTime = 4
     */
    bestAbsModifyTime: bigint; // 最佳摘要修改时间
}
/**
 * 论文资源
 *
 * @generated from protobuf message paper.PaperResourceVO
 */
export interface PaperResourceVO {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // 资源id
    /**
     * @generated from protobuf field: string paperId = 2
     */
    paperId: string; // 论文id
    /**
     * @generated from protobuf field: string paperTitle = 3
     */
    paperTitle: string; // 论文标题
    /**
     * @generated from protobuf field: string resourceUrl = 4
     */
    resourceUrl: string; // 资源url
    /**
     * @generated from protobuf field: string resourceTitle = 5
     */
    resourceTitle: string; // 资源标题
}
/**
 * @generated from protobuf message paper.MachineTranslationInfo
 */
export interface MachineTranslationInfo {
    /**
     * @generated from protobuf field: paper.TranslationSourceEnum translationSource = 1
     */
    translationSource: TranslationSourceEnum; // 机器翻译来源
    /**
     * @generated from protobuf field: string translation = 2
     */
    translation: string; // 机器翻译内容
}
/**
 * 论文版本类型
 *
 * @generated from protobuf enum paper.PaperVersionType
 */
export enum PaperVersionType {
    /**
     * @generated from protobuf enum value: PAPER_LINK = 0;
     */
    PAPER_LINK = 0,
    /**
     * @generated from protobuf enum value: PAPER_PDF = 1;
     */
    PAPER_PDF = 1
}
/**
 * @generated from protobuf enum paper.ReadStatusEnum
 */
export enum ReadStatusEnum {
    /**
     * @generated from protobuf enum value: READABLE_PUBLIC = 0;
     */
    READABLE_PUBLIC = 0,
    /**
     * @generated from protobuf enum value: READABLE_PRIVATE = 1;
     */
    READABLE_PRIVATE = 1,
    /**
     * @generated from protobuf enum value: UNREADABLE = 2;
     */
    UNREADABLE = 2
}
/**
 * 机器翻译来源
 *
 * @generated from protobuf enum paper.TranslationSourceEnum
 */
export enum TranslationSourceEnum {
    /**
     * @generated from protobuf enum value: MANUAL = 0;
     */
    MANUAL = 0,
    /**
     * @generated from protobuf enum value: YOUDAO = 1;
     */
    YOUDAO = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class PaperVersionInfo$Type extends MessageType<PaperVersionInfo> {
    constructor() {
        super("paper.PaperVersionInfo", [
            { no: 1, name: "type", kind: "enum", T: () => ["paper.PaperVersionType", PaperVersionType] },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "jumpUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "curVersion", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "lastVersion", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "datePrefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PaperVersionInfo>): PaperVersionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.name = "";
        message.pdfId = "";
        message.jumpUrl = "";
        message.curVersion = false;
        message.lastVersion = false;
        message.datePrefix = "";
        if (value !== undefined)
            reflectionMergePartial<PaperVersionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperVersionInfo): PaperVersionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* paper.PaperVersionType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string pdfId */ 3:
                    message.pdfId = reader.string();
                    break;
                case /* string jumpUrl */ 4:
                    message.jumpUrl = reader.string();
                    break;
                case /* bool curVersion */ 5:
                    message.curVersion = reader.bool();
                    break;
                case /* bool lastVersion */ 6:
                    message.lastVersion = reader.bool();
                    break;
                case /* string datePrefix */ 7:
                    message.datePrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperVersionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* paper.PaperVersionType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string pdfId = 3; */
        if (message.pdfId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pdfId);
        /* string jumpUrl = 4; */
        if (message.jumpUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.jumpUrl);
        /* bool curVersion = 5; */
        if (message.curVersion !== false)
            writer.tag(5, WireType.Varint).bool(message.curVersion);
        /* bool lastVersion = 6; */
        if (message.lastVersion !== false)
            writer.tag(6, WireType.Varint).bool(message.lastVersion);
        /* string datePrefix = 7; */
        if (message.datePrefix !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.datePrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.PaperVersionInfo
 */
export const PaperVersionInfo = new PaperVersionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperVersionsRequest$Type extends MessageType<GetPaperVersionsRequest> {
    constructor() {
        super("paper.GetPaperVersionsRequest", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperVersionsRequest>): GetPaperVersionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperVersionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperVersionsRequest): GetPaperVersionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperVersionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.GetPaperVersionsRequest
 */
export const GetPaperVersionsRequest = new GetPaperVersionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperVersionsResponse$Type extends MessageType<GetPaperVersionsResponse> {
    constructor() {
        super("paper.GetPaperVersionsResponse", [
            { no: 1, name: "publicVersions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaperVersionInfo },
            { no: 2, name: "privateVersions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaperVersionInfo }
        ]);
    }
    create(value?: PartialMessage<GetPaperVersionsResponse>): GetPaperVersionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicVersions = [];
        message.privateVersions = [];
        if (value !== undefined)
            reflectionMergePartial<GetPaperVersionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperVersionsResponse): GetPaperVersionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated paper.PaperVersionInfo publicVersions */ 1:
                    message.publicVersions.push(PaperVersionInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated paper.PaperVersionInfo privateVersions */ 2:
                    message.privateVersions.push(PaperVersionInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperVersionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated paper.PaperVersionInfo publicVersions = 1; */
        for (let i = 0; i < message.publicVersions.length; i++)
            PaperVersionInfo.internalBinaryWrite(message.publicVersions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated paper.PaperVersionInfo privateVersions = 2; */
        for (let i = 0; i < message.privateVersions.length; i++)
            PaperVersionInfo.internalBinaryWrite(message.privateVersions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.GetPaperVersionsResponse
 */
export const GetPaperVersionsResponse = new GetPaperVersionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperDetailInfoRequest$Type extends MessageType<GetPaperDetailInfoRequest> {
    constructor() {
        super("paper.GetPaperDetailInfoRequest", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperDetailInfoRequest>): GetPaperDetailInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperDetailInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperDetailInfoRequest): GetPaperDetailInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperDetailInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.GetPaperDetailInfoRequest
 */
export const GetPaperDetailInfoRequest = new GetPaperDetailInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaperDetailInfo$Type extends MessageType<PaperDetailInfo> {
    constructor() {
        super("paper.PaperDetailInfo", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "originalAbstract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "authorList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BasePaperAuthorInfo },
            { no: 6, name: "paperTagList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BasePaperTagInfo },
            { no: 7, name: "referenceCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "citationCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "venues", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "primaryVenue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "relatedUrls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "paperUrlList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaperUrlsBean },
            { no: 13, name: "venueTags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "doi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "newPaper", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "noteCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "collectCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "hasPublicPdf", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "hasPrivatePdf", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "questionAnswerCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "abstractTranslationInfo", kind: "message", T: () => AbstractInfoVo },
            { no: 23, name: "isCollected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "paperResources", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaperResourceVO },
            { no: 25, name: "showPaperDetail", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "readStatus", kind: "enum", T: () => ["paper.ReadStatusEnum", ReadStatusEnum] },
            { no: 27, name: "paperCommentedCount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 28, name: "machineTranslationInfo", kind: "message", T: () => MachineTranslationInfo },
            { no: 29, name: "userDocId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "showMachineTranslationButton", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PaperDetailInfo>): PaperDetailInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        message.title = "";
        message.publishDate = "";
        message.originalAbstract = "";
        message.authorList = [];
        message.paperTagList = [];
        message.referenceCount = 0;
        message.citationCount = 0;
        message.venues = [];
        message.primaryVenue = "";
        message.relatedUrls = [];
        message.paperUrlList = [];
        message.venueTags = [];
        message.doi = "";
        message.newPaper = false;
        message.noteCount = 0;
        message.collectCount = 0;
        message.pdfId = "";
        message.hasPublicPdf = false;
        message.hasPrivatePdf = false;
        message.questionAnswerCount = 0;
        message.isCollected = false;
        message.paperResources = [];
        message.showPaperDetail = false;
        message.readStatus = 0;
        message.paperCommentedCount = 0n;
        message.userDocId = "";
        message.showMachineTranslationButton = false;
        if (value !== undefined)
            reflectionMergePartial<PaperDetailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperDetailInfo): PaperDetailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string publishDate */ 3:
                    message.publishDate = reader.string();
                    break;
                case /* string originalAbstract */ 4:
                    message.originalAbstract = reader.string();
                    break;
                case /* repeated paper.BasePaperAuthorInfo authorList */ 5:
                    message.authorList.push(BasePaperAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated paper.BasePaperTagInfo paperTagList */ 6:
                    message.paperTagList.push(BasePaperTagInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 referenceCount */ 7:
                    message.referenceCount = reader.int32();
                    break;
                case /* int32 citationCount */ 8:
                    message.citationCount = reader.int32();
                    break;
                case /* repeated string venues */ 9:
                    message.venues.push(reader.string());
                    break;
                case /* string primaryVenue */ 10:
                    message.primaryVenue = reader.string();
                    break;
                case /* repeated string relatedUrls */ 11:
                    message.relatedUrls.push(reader.string());
                    break;
                case /* repeated paper.PaperUrlsBean paperUrlList */ 12:
                    message.paperUrlList.push(PaperUrlsBean.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string venueTags */ 13:
                    message.venueTags.push(reader.string());
                    break;
                case /* string doi */ 14:
                    message.doi = reader.string();
                    break;
                case /* bool newPaper */ 15:
                    message.newPaper = reader.bool();
                    break;
                case /* int32 noteCount */ 16:
                    message.noteCount = reader.int32();
                    break;
                case /* int32 collectCount */ 17:
                    message.collectCount = reader.int32();
                    break;
                case /* string pdfId */ 18:
                    message.pdfId = reader.string();
                    break;
                case /* bool hasPublicPdf */ 19:
                    message.hasPublicPdf = reader.bool();
                    break;
                case /* bool hasPrivatePdf */ 20:
                    message.hasPrivatePdf = reader.bool();
                    break;
                case /* int32 questionAnswerCount */ 21:
                    message.questionAnswerCount = reader.int32();
                    break;
                case /* paper.AbstractInfoVo abstractTranslationInfo */ 22:
                    message.abstractTranslationInfo = AbstractInfoVo.internalBinaryRead(reader, reader.uint32(), options, message.abstractTranslationInfo);
                    break;
                case /* bool isCollected */ 23:
                    message.isCollected = reader.bool();
                    break;
                case /* repeated paper.PaperResourceVO paperResources */ 24:
                    message.paperResources.push(PaperResourceVO.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool showPaperDetail */ 25:
                    message.showPaperDetail = reader.bool();
                    break;
                case /* paper.ReadStatusEnum readStatus */ 26:
                    message.readStatus = reader.int32();
                    break;
                case /* uint64 paperCommentedCount */ 27:
                    message.paperCommentedCount = reader.uint64().toBigInt();
                    break;
                case /* paper.MachineTranslationInfo machineTranslationInfo */ 28:
                    message.machineTranslationInfo = MachineTranslationInfo.internalBinaryRead(reader, reader.uint32(), options, message.machineTranslationInfo);
                    break;
                case /* string userDocId */ 29:
                    message.userDocId = reader.string();
                    break;
                case /* bool showMachineTranslationButton */ 30:
                    message.showMachineTranslationButton = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperDetailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string publishDate = 3; */
        if (message.publishDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publishDate);
        /* string originalAbstract = 4; */
        if (message.originalAbstract !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.originalAbstract);
        /* repeated paper.BasePaperAuthorInfo authorList = 5; */
        for (let i = 0; i < message.authorList.length; i++)
            BasePaperAuthorInfo.internalBinaryWrite(message.authorList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated paper.BasePaperTagInfo paperTagList = 6; */
        for (let i = 0; i < message.paperTagList.length; i++)
            BasePaperTagInfo.internalBinaryWrite(message.paperTagList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int32 referenceCount = 7; */
        if (message.referenceCount !== 0)
            writer.tag(7, WireType.Varint).int32(message.referenceCount);
        /* int32 citationCount = 8; */
        if (message.citationCount !== 0)
            writer.tag(8, WireType.Varint).int32(message.citationCount);
        /* repeated string venues = 9; */
        for (let i = 0; i < message.venues.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.venues[i]);
        /* string primaryVenue = 10; */
        if (message.primaryVenue !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.primaryVenue);
        /* repeated string relatedUrls = 11; */
        for (let i = 0; i < message.relatedUrls.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.relatedUrls[i]);
        /* repeated paper.PaperUrlsBean paperUrlList = 12; */
        for (let i = 0; i < message.paperUrlList.length; i++)
            PaperUrlsBean.internalBinaryWrite(message.paperUrlList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string venueTags = 13; */
        for (let i = 0; i < message.venueTags.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.venueTags[i]);
        /* string doi = 14; */
        if (message.doi !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.doi);
        /* bool newPaper = 15; */
        if (message.newPaper !== false)
            writer.tag(15, WireType.Varint).bool(message.newPaper);
        /* int32 noteCount = 16; */
        if (message.noteCount !== 0)
            writer.tag(16, WireType.Varint).int32(message.noteCount);
        /* int32 collectCount = 17; */
        if (message.collectCount !== 0)
            writer.tag(17, WireType.Varint).int32(message.collectCount);
        /* string pdfId = 18; */
        if (message.pdfId !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.pdfId);
        /* bool hasPublicPdf = 19; */
        if (message.hasPublicPdf !== false)
            writer.tag(19, WireType.Varint).bool(message.hasPublicPdf);
        /* bool hasPrivatePdf = 20; */
        if (message.hasPrivatePdf !== false)
            writer.tag(20, WireType.Varint).bool(message.hasPrivatePdf);
        /* int32 questionAnswerCount = 21; */
        if (message.questionAnswerCount !== 0)
            writer.tag(21, WireType.Varint).int32(message.questionAnswerCount);
        /* paper.AbstractInfoVo abstractTranslationInfo = 22; */
        if (message.abstractTranslationInfo)
            AbstractInfoVo.internalBinaryWrite(message.abstractTranslationInfo, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* bool isCollected = 23; */
        if (message.isCollected !== false)
            writer.tag(23, WireType.Varint).bool(message.isCollected);
        /* repeated paper.PaperResourceVO paperResources = 24; */
        for (let i = 0; i < message.paperResources.length; i++)
            PaperResourceVO.internalBinaryWrite(message.paperResources[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* bool showPaperDetail = 25; */
        if (message.showPaperDetail !== false)
            writer.tag(25, WireType.Varint).bool(message.showPaperDetail);
        /* paper.ReadStatusEnum readStatus = 26; */
        if (message.readStatus !== 0)
            writer.tag(26, WireType.Varint).int32(message.readStatus);
        /* uint64 paperCommentedCount = 27; */
        if (message.paperCommentedCount !== 0n)
            writer.tag(27, WireType.Varint).uint64(message.paperCommentedCount);
        /* paper.MachineTranslationInfo machineTranslationInfo = 28; */
        if (message.machineTranslationInfo)
            MachineTranslationInfo.internalBinaryWrite(message.machineTranslationInfo, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* string userDocId = 29; */
        if (message.userDocId !== "")
            writer.tag(29, WireType.LengthDelimited).string(message.userDocId);
        /* bool showMachineTranslationButton = 30; */
        if (message.showMachineTranslationButton !== false)
            writer.tag(30, WireType.Varint).bool(message.showMachineTranslationButton);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.PaperDetailInfo
 */
export const PaperDetailInfo = new PaperDetailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasePaperInfo$Type extends MessageType<BasePaperInfo> {
    constructor() {
        super("paper.BasePaperInfo", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "originalAbstract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "authorList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BasePaperAuthorInfo },
            { no: 6, name: "paperTagList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BasePaperTagInfo },
            { no: 7, name: "referenceCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "citationCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "venues", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "primaryVenue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "relatedUrls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "paperUrlList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaperUrlsBean },
            { no: 13, name: "venueTags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "doi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "newPaper", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BasePaperInfo>): BasePaperInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        message.title = "";
        message.publishDate = "";
        message.originalAbstract = "";
        message.authorList = [];
        message.paperTagList = [];
        message.referenceCount = 0;
        message.citationCount = 0;
        message.venues = [];
        message.primaryVenue = "";
        message.relatedUrls = [];
        message.paperUrlList = [];
        message.venueTags = [];
        message.doi = "";
        message.newPaper = false;
        if (value !== undefined)
            reflectionMergePartial<BasePaperInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasePaperInfo): BasePaperInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string publishDate */ 3:
                    message.publishDate = reader.string();
                    break;
                case /* string originalAbstract */ 4:
                    message.originalAbstract = reader.string();
                    break;
                case /* repeated paper.BasePaperAuthorInfo authorList */ 5:
                    message.authorList.push(BasePaperAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated paper.BasePaperTagInfo paperTagList */ 6:
                    message.paperTagList.push(BasePaperTagInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 referenceCount */ 7:
                    message.referenceCount = reader.int32();
                    break;
                case /* int32 citationCount */ 8:
                    message.citationCount = reader.int32();
                    break;
                case /* repeated string venues */ 9:
                    message.venues.push(reader.string());
                    break;
                case /* string primaryVenue */ 10:
                    message.primaryVenue = reader.string();
                    break;
                case /* repeated string relatedUrls */ 11:
                    message.relatedUrls.push(reader.string());
                    break;
                case /* repeated paper.PaperUrlsBean paperUrlList */ 12:
                    message.paperUrlList.push(PaperUrlsBean.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string venueTags */ 13:
                    message.venueTags.push(reader.string());
                    break;
                case /* string doi */ 14:
                    message.doi = reader.string();
                    break;
                case /* bool newPaper */ 15:
                    message.newPaper = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasePaperInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string publishDate = 3; */
        if (message.publishDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publishDate);
        /* string originalAbstract = 4; */
        if (message.originalAbstract !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.originalAbstract);
        /* repeated paper.BasePaperAuthorInfo authorList = 5; */
        for (let i = 0; i < message.authorList.length; i++)
            BasePaperAuthorInfo.internalBinaryWrite(message.authorList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated paper.BasePaperTagInfo paperTagList = 6; */
        for (let i = 0; i < message.paperTagList.length; i++)
            BasePaperTagInfo.internalBinaryWrite(message.paperTagList[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int32 referenceCount = 7; */
        if (message.referenceCount !== 0)
            writer.tag(7, WireType.Varint).int32(message.referenceCount);
        /* int32 citationCount = 8; */
        if (message.citationCount !== 0)
            writer.tag(8, WireType.Varint).int32(message.citationCount);
        /* repeated string venues = 9; */
        for (let i = 0; i < message.venues.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.venues[i]);
        /* string primaryVenue = 10; */
        if (message.primaryVenue !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.primaryVenue);
        /* repeated string relatedUrls = 11; */
        for (let i = 0; i < message.relatedUrls.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.relatedUrls[i]);
        /* repeated paper.PaperUrlsBean paperUrlList = 12; */
        for (let i = 0; i < message.paperUrlList.length; i++)
            PaperUrlsBean.internalBinaryWrite(message.paperUrlList[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string venueTags = 13; */
        for (let i = 0; i < message.venueTags.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.venueTags[i]);
        /* string doi = 14; */
        if (message.doi !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.doi);
        /* bool newPaper = 15; */
        if (message.newPaper !== false)
            writer.tag(15, WireType.Varint).bool(message.newPaper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.BasePaperInfo
 */
export const BasePaperInfo = new BasePaperInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasePaperAuthorInfo$Type extends MessageType<BasePaperAuthorInfo> {
    constructor() {
        super("paper.BasePaperAuthorInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "isAuthentication", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BasePaperAuthorInfo>): BasePaperAuthorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.isAuthentication = false;
        if (value !== undefined)
            reflectionMergePartial<BasePaperAuthorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasePaperAuthorInfo): BasePaperAuthorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool isAuthentication */ 3:
                    message.isAuthentication = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasePaperAuthorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool isAuthentication = 3; */
        if (message.isAuthentication !== false)
            writer.tag(3, WireType.Varint).bool(message.isAuthentication);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.BasePaperAuthorInfo
 */
export const BasePaperAuthorInfo = new BasePaperAuthorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasePaperTagInfo$Type extends MessageType<BasePaperTagInfo> {
    constructor() {
        super("paper.BasePaperTagInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BasePaperTagInfo>): BasePaperTagInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.level = 0;
        if (value !== undefined)
            reflectionMergePartial<BasePaperTagInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasePaperTagInfo): BasePaperTagInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 level */ 3:
                    message.level = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasePaperTagInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 level = 3; */
        if (message.level !== 0)
            writer.tag(3, WireType.Varint).int32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.BasePaperTagInfo
 */
export const BasePaperTagInfo = new BasePaperTagInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaperUrlsBean$Type extends MessageType<PaperUrlsBean> {
    constructor() {
        super("paper.PaperUrlsBean", [
            { no: 1, name: "sourceType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "venue", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PaperUrlsBean>): PaperUrlsBean {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourceType = "";
        message.url = "";
        message.publishDate = "";
        message.venue = "";
        if (value !== undefined)
            reflectionMergePartial<PaperUrlsBean>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperUrlsBean): PaperUrlsBean {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sourceType */ 1:
                    message.sourceType = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string publishDate */ 3:
                    message.publishDate = reader.string();
                    break;
                case /* string venue */ 4:
                    message.venue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperUrlsBean, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sourceType = 1; */
        if (message.sourceType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sourceType);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string publishDate = 3; */
        if (message.publishDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publishDate);
        /* string venue = 4; */
        if (message.venue !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.venue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.PaperUrlsBean
 */
export const PaperUrlsBean = new PaperUrlsBean$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbstractInfoVo$Type extends MessageType<AbstractInfoVo> {
    constructor() {
        super("paper.AbstractInfoVo", [
            { no: 1, name: "bestAbsAuthor", kind: "message", T: () => AuthorBean },
            { no: 2, name: "bestAbsContent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "totalCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "bestAbsModifyTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AbstractInfoVo>): AbstractInfoVo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bestAbsContent = "";
        message.totalCount = 0;
        message.bestAbsModifyTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<AbstractInfoVo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbstractInfoVo): AbstractInfoVo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* user.AuthorBean bestAbsAuthor */ 1:
                    message.bestAbsAuthor = AuthorBean.internalBinaryRead(reader, reader.uint32(), options, message.bestAbsAuthor);
                    break;
                case /* string bestAbsContent */ 2:
                    message.bestAbsContent = reader.string();
                    break;
                case /* int32 totalCount */ 3:
                    message.totalCount = reader.int32();
                    break;
                case /* int64 bestAbsModifyTime */ 4:
                    message.bestAbsModifyTime = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbstractInfoVo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* user.AuthorBean bestAbsAuthor = 1; */
        if (message.bestAbsAuthor)
            AuthorBean.internalBinaryWrite(message.bestAbsAuthor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string bestAbsContent = 2; */
        if (message.bestAbsContent !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bestAbsContent);
        /* int32 totalCount = 3; */
        if (message.totalCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.totalCount);
        /* int64 bestAbsModifyTime = 4; */
        if (message.bestAbsModifyTime !== 0n)
            writer.tag(4, WireType.Varint).int64(message.bestAbsModifyTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.AbstractInfoVo
 */
export const AbstractInfoVo = new AbstractInfoVo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaperResourceVO$Type extends MessageType<PaperResourceVO> {
    constructor() {
        super("paper.PaperResourceVO", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "paperTitle", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "resourceUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "resourceTitle", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PaperResourceVO>): PaperResourceVO {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.paperId = "";
        message.paperTitle = "";
        message.resourceUrl = "";
        message.resourceTitle = "";
        if (value !== undefined)
            reflectionMergePartial<PaperResourceVO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperResourceVO): PaperResourceVO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string paperId */ 2:
                    message.paperId = reader.string();
                    break;
                case /* string paperTitle */ 3:
                    message.paperTitle = reader.string();
                    break;
                case /* string resourceUrl */ 4:
                    message.resourceUrl = reader.string();
                    break;
                case /* string resourceTitle */ 5:
                    message.resourceTitle = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperResourceVO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string paperId = 2; */
        if (message.paperId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paperId);
        /* string paperTitle = 3; */
        if (message.paperTitle !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.paperTitle);
        /* string resourceUrl = 4; */
        if (message.resourceUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.resourceUrl);
        /* string resourceTitle = 5; */
        if (message.resourceTitle !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.resourceTitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.PaperResourceVO
 */
export const PaperResourceVO = new PaperResourceVO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MachineTranslationInfo$Type extends MessageType<MachineTranslationInfo> {
    constructor() {
        super("paper.MachineTranslationInfo", [
            { no: 1, name: "translationSource", kind: "enum", T: () => ["paper.TranslationSourceEnum", TranslationSourceEnum] },
            { no: 2, name: "translation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MachineTranslationInfo>): MachineTranslationInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.translationSource = 0;
        message.translation = "";
        if (value !== undefined)
            reflectionMergePartial<MachineTranslationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MachineTranslationInfo): MachineTranslationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* paper.TranslationSourceEnum translationSource */ 1:
                    message.translationSource = reader.int32();
                    break;
                case /* string translation */ 2:
                    message.translation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MachineTranslationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* paper.TranslationSourceEnum translationSource = 1; */
        if (message.translationSource !== 0)
            writer.tag(1, WireType.Varint).int32(message.translationSource);
        /* string translation = 2; */
        if (message.translation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.translation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message paper.MachineTranslationInfo
 */
export const MachineTranslationInfo = new MachineTranslationInfo$Type();
