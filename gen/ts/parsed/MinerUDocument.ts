// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/parsed/MinerUDocument.proto" (package "parsed", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BBox } from "./Document";
/**
 * MineruContentList 表示Mineru内容列表项
 *
 * @generated from protobuf message parsed.MineruContentList
 */
export interface MineruContentList {
    /**
     * 通用属性
     *
     * @generated from protobuf field: string type = 1
     */
    type: string; // 内容类型
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string; // 文本内容
    /**
     * @generated from protobuf field: int32 page_idx = 3
     */
    page_idx: number; // 页码索引
    /**
     * text类型属性
     *
     * @generated from protobuf field: int32 text_level = 4
     */
    text_level: number; // 文本级别
    /**
     * equation类型属性
     *
     * @generated from protobuf field: string text_format = 5
     */
    text_format: string; // 文本格式
    /**
     * table类型属性
     *
     * @generated from protobuf field: repeated string table_caption = 6
     */
    table_caption: string[]; // 表格标题
    /**
     * @generated from protobuf field: repeated string table_footnote = 7
     */
    table_footnote: string[]; // 表格脚注
    /**
     * @generated from protobuf field: string table_body = 8
     */
    table_body: string; // 表格内容
    /**
     * image类型属性
     *
     * @generated from protobuf field: repeated string img_caption = 9
     */
    img_caption: string[]; // 图片标题
    /**
     * @generated from protobuf field: repeated string img_footnote = 10
     */
    img_footnote: string[]; // 图片脚注
    /**
     * image类型和table类型 公共属性
     *
     * @generated from protobuf field: string img_path = 11
     */
    img_path: string; // 图片路径
}
/**
 * UploadProgressResponse 上传进度响应结构
 *
 * @generated from protobuf message parsed.UploadProgressResponse
 */
export interface UploadProgressResponse {
    /**
     * @generated from protobuf field: string msg = 1
     */
    msg: string; // 消息
    /**
     * @generated from protobuf field: string orig_name = 2
     */
    orig_name: string; // 原始文件名
    /**
     * @generated from protobuf field: int32 chunk_size = 3
     */
    chunk_size: number; // 分块大小
}
/**
 * JoinResponse 合并结果响应结构
 *
 * @generated from protobuf message parsed.JoinResponse
 */
export interface JoinResponse {
    /**
     * @generated from protobuf field: string event_id = 1
     */
    event_id: string; // 事件ID
}
/**
 * ImageRecord 图片记录结构
 *
 * @generated from protobuf message parsed.ImageRecord
 */
export interface ImageRecord {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string; // 图片ID
    /**
     * @generated from protobuf field: string bucket_name = 2
     */
    bucket_name: string; // 存储桶名称
    /**
     * @generated from protobuf field: string object_key = 3
     */
    object_key: string; // 对象键
    /**
     * @generated from protobuf field: string file_name = 4
     */
    file_name: string; // 文件名
    /**
     * @generated from protobuf field: int64 file_size = 5
     */
    file_size: bigint; // 文件大小
    /**
     * @generated from protobuf field: string fileSHA256 = 6
     */
    fileSHA256: string; // SHA256校验和
    /**
     * @generated from protobuf field: string content_type = 7
     */
    content_type: string; // 内容类型
    /**
     * @generated from protobuf field: parsed.BBox ref_bbox = 8
     */
    ref_bbox?: BBox; // 引用边界框
    /**
     * @generated from protobuf field: parsed.BBox bbox = 9
     */
    bbox?: BBox; // 边界框
    /**
     * @generated from protobuf field: int32 page_idx = 10
     */
    page_idx: number; // 页码
    /**
     * @generated from protobuf field: string section_id = 11
     */
    section_id: string; // 所属章节id
    /**
     * @generated from protobuf field: string section_title = 12
     */
    section_title: string; // 所属章节标题
}
/**
 * 公式记录结构
 *
 * @generated from protobuf message parsed.FormulaRecord
 */
export interface FormulaRecord {
    /**
     * @generated from protobuf field: string content = 1
     */
    content: string; // 公式内容
    /**
     * @generated from protobuf field: parsed.BBox bbox = 2
     */
    bbox?: BBox; // 边界框
    /**
     * @generated from protobuf field: int32 page_idx = 3
     */
    page_idx: number; // 页码
    /**
     * @generated from protobuf field: string section_id = 4
     */
    section_id: string; // 所属章节id
    /**
     * @generated from protobuf field: string section_title = 5
     */
    section_title: string; // 所属章节标题
}
/**
 * EventOutput 事件输出结构 - 数组内容为["全文内容","全文内容","解析的zip文件信息","PDF信息【path和url等】"]
 *
 * @generated from protobuf message parsed.EventOutput
 */
export interface EventOutput {
    /**
     * @generated from protobuf field: repeated string data = 1
     */
    data: string[]; // 使用string类型表示任意JSON数据
}
/**
 * ProcessCompletedEventMessage process_completed事件消息结构
 *
 * @generated from protobuf message parsed.ProcessCompletedEventMessage
 */
export interface ProcessCompletedEventMessage {
    /**
     * @generated from protobuf field: string msg = 1
     */
    msg: string; // 消息
    /**
     * @generated from protobuf field: string event_id = 2
     */
    event_id: string; // 事件ID
    /**
     * @generated from protobuf field: parsed.EventOutput output = 3
     */
    output?: EventOutput; // 输出内容
    /**
     * @generated from protobuf field: bool success = 4
     */
    success: boolean; // 是否成功
    /**
     * @generated from protobuf field: string title = 5
     */
    title: string; // 标题
}
/**
 * PathInfo 路径信息结构
 *
 * @generated from protobuf message parsed.PathInfo
 */
export interface PathInfo {
    /**
     * @generated from protobuf field: string path = 1
     */
    path: string; // 路径
    /**
     * @generated from protobuf field: string url = 2
     */
    url: string; // URL
    /**
     * @generated from protobuf field: int32 size = 3
     */
    size: number; // 大小
    /**
     * @generated from protobuf field: string orig_name = 4
     */
    orig_name: string; // 原始文件名
    /**
     * @generated from protobuf field: string mime_type = 5
     */
    mime_type: string; // MIME类型
    /**
     * @generated from protobuf field: bool is_stream = 6
     */
    is_stream: boolean; // 是否为流
    /**
     * @generated from protobuf field: map<string, string> meta = 7
     */
    meta: {
        [key: string]: string;
    }; // 元数据
}
/**
 * @generated from protobuf message parsed.MineruPdfInfo
 */
export interface MineruPdfInfo {
    /**
     * @generated from protobuf field: repeated parsed.MineruPage pdf_info = 1
     */
    pdf_info: MineruPage[]; // pdf信息
}
/**
 * MineruPage 表示Mineru页面结构
 *
 * @generated from protobuf message parsed.MineruPage
 */
export interface MineruPage {
    /**
     * 需要解析的属性
     *
     * @generated from protobuf field: int32 page_idx = 1
     */
    page_idx: number; // 页面索引
    /**
     * @generated from protobuf field: repeated double page_size = 2
     */
    page_size: number[]; // 页面大小
    /**
     * @generated from protobuf field: repeated parsed.ImageAndTable images = 3
     */
    images: ImageAndTable[]; // 图片
    /**
     * @generated from protobuf field: repeated parsed.ImageAndTable tables = 4
     */
    tables: ImageAndTable[]; // 表格
    /**
     * @generated from protobuf field: repeated parsed.Block para_blocks = 5
     */
    para_blocks: Block[]; // 段落块
    // 以下属性暂时没发现存在value 所以无法定义结构 暂时注释
    // repeated string layout_bboxes = 6; // 布局框
    // repeated string layout_tree = 7;   // 布局树
    // repeated string drop_reason = 8;   // 丢弃原因

    /**
     * 下面属性过长，是否需要解析待定。。。  暂时注释
     *
     * @generated from protobuf field: repeated parsed.Block preproc_blocks = 9
     */
    preproc_blocks: Block[]; // 预处理块
}
/**
 * Block 表示块结构
 *
 * @generated from protobuf message parsed.Block
 */
export interface Block {
    /**
     * @generated from protobuf field: string type = 1
     */
    type: string; // 类型
    /**
     * @generated from protobuf field: repeated double bbox = 2
     */
    bbox: number[]; // 边界框
    /**
     * @generated from protobuf field: double index = 3
     */
    index: number; // 索引
    /**
     * @generated from protobuf field: repeated parsed.Line lines = 4
     */
    lines: Line[]; // 行
    /**
     * 下面这两个属性是para_blocks中独有的
     *
     * @generated from protobuf field: int32 page_num = 5
     */
    page_num: number; // 页码
    /**
     * @generated from protobuf field: repeated double page_size = 6
     */
    page_size: number[]; // 页面大小
    /**
     * 这两个属性是image中独有的
     *
     * @generated from protobuf field: double group_id = 7
     */
    group_id: number; // 组ID
    /**
     * @generated from protobuf field: repeated parsed.Line virtual_lines = 8
     */
    virtual_lines: Line[]; // 虚拟行
    /**
     * 这两个属性是type = table or figure独有的
     *
     * @generated from protobuf field: repeated parsed.Block blocks = 9
     */
    blocks: Block[]; // 块
    /**
     * 是否删除行（这里的意思代表的是，当前块是属于第一页段落中的内容，内容跨页了，需要删除，这里的坐标代表了跨页的文本行）
     *
     * @generated from protobuf field: bool lines_deleted = 10
     */
    lines_deleted: boolean;
}
/**
 * Line 表示行结构
 *
 * @generated from protobuf message parsed.Line
 */
export interface Line {
    /**
     * @generated from protobuf field: repeated double bbox = 1
     */
    bbox: number[]; // 边界框
    /**
     * @generated from protobuf field: double index = 2
     */
    index: number; // 索引
    /**
     * @generated from protobuf field: repeated parsed.Span spans = 3
     */
    spans: Span[]; // 跨度
}
/**
 * Span 表示跨度结构
 *
 * @generated from protobuf message parsed.Span
 */
export interface Span {
    /**
     * @generated from protobuf field: repeated double bbox = 1
     */
    bbox: number[]; // 边界框
    /**
     * @generated from protobuf field: string source = 2
     */
    source: string; // 源
    /**
     * @generated from protobuf field: string content = 3
     */
    content: string; // 内容
    /**
     * @generated from protobuf field: string type = 4
     */
    type: string; // 类型
    /**
     * @generated from protobuf field: string image_path = 5
     */
    image_path: string; // 图片路径
    /**
     * @generated from protobuf field: bool cross_page = 6
     */
    cross_page: boolean; // 是否跨页
}
/**
 * InterlineEquation 表示行间公式结构
 *
 * @generated from protobuf message parsed.InterlineEquation
 */
export interface InterlineEquation {
    /**
     * @generated from protobuf field: string type = 1
     */
    type: string; // 类型
    /**
     * @generated from protobuf field: repeated double bbox = 2
     */
    bbox: number[]; // 边界框
    /**
     * @generated from protobuf field: double line = 3
     */
    line: number; // 行
    /**
     * @generated from protobuf field: double index = 4
     */
    index: number; // 索引
    /**
     * @generated from protobuf field: repeated parsed.Line virtual_lines = 5
     */
    virtual_lines: Line[]; // 虚拟行
}
/**
 * ImageAndTable 表示图片和表格结构
 *
 * @generated from protobuf message parsed.ImageAndTable
 */
export interface ImageAndTable {
    /**
     * @generated from protobuf field: string type = 1
     */
    type: string; // 类型
    /**
     * @generated from protobuf field: repeated double bbox = 2
     */
    bbox: number[]; // 边界框
    /**
     * @generated from protobuf field: double index = 3
     */
    index: number; // 索引
    /**
     * @generated from protobuf field: repeated parsed.Block blocks = 4
     */
    blocks: Block[]; // 块
}
// @generated message type with reflection information, may provide speed optimized methods
class MineruContentList$Type extends MessageType<MineruContentList> {
    constructor() {
        super("parsed.MineruContentList", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "page_idx", kind: "scalar", localName: "page_idx", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "text_level", kind: "scalar", localName: "text_level", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "text_format", kind: "scalar", localName: "text_format", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "table_caption", kind: "scalar", localName: "table_caption", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "table_footnote", kind: "scalar", localName: "table_footnote", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "table_body", kind: "scalar", localName: "table_body", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "img_caption", kind: "scalar", localName: "img_caption", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "img_footnote", kind: "scalar", localName: "img_footnote", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "img_path", kind: "scalar", localName: "img_path", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MineruContentList>): MineruContentList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.text = "";
        message.page_idx = 0;
        message.text_level = 0;
        message.text_format = "";
        message.table_caption = [];
        message.table_footnote = [];
        message.table_body = "";
        message.img_caption = [];
        message.img_footnote = [];
        message.img_path = "";
        if (value !== undefined)
            reflectionMergePartial<MineruContentList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MineruContentList): MineruContentList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                case /* int32 page_idx */ 3:
                    message.page_idx = reader.int32();
                    break;
                case /* int32 text_level */ 4:
                    message.text_level = reader.int32();
                    break;
                case /* string text_format */ 5:
                    message.text_format = reader.string();
                    break;
                case /* repeated string table_caption */ 6:
                    message.table_caption.push(reader.string());
                    break;
                case /* repeated string table_footnote */ 7:
                    message.table_footnote.push(reader.string());
                    break;
                case /* string table_body */ 8:
                    message.table_body = reader.string();
                    break;
                case /* repeated string img_caption */ 9:
                    message.img_caption.push(reader.string());
                    break;
                case /* repeated string img_footnote */ 10:
                    message.img_footnote.push(reader.string());
                    break;
                case /* string img_path */ 11:
                    message.img_path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MineruContentList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        /* int32 page_idx = 3; */
        if (message.page_idx !== 0)
            writer.tag(3, WireType.Varint).int32(message.page_idx);
        /* int32 text_level = 4; */
        if (message.text_level !== 0)
            writer.tag(4, WireType.Varint).int32(message.text_level);
        /* string text_format = 5; */
        if (message.text_format !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.text_format);
        /* repeated string table_caption = 6; */
        for (let i = 0; i < message.table_caption.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.table_caption[i]);
        /* repeated string table_footnote = 7; */
        for (let i = 0; i < message.table_footnote.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.table_footnote[i]);
        /* string table_body = 8; */
        if (message.table_body !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.table_body);
        /* repeated string img_caption = 9; */
        for (let i = 0; i < message.img_caption.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.img_caption[i]);
        /* repeated string img_footnote = 10; */
        for (let i = 0; i < message.img_footnote.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.img_footnote[i]);
        /* string img_path = 11; */
        if (message.img_path !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.img_path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.MineruContentList
 */
export const MineruContentList = new MineruContentList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadProgressResponse$Type extends MessageType<UploadProgressResponse> {
    constructor() {
        super("parsed.UploadProgressResponse", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "orig_name", kind: "scalar", localName: "orig_name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "chunk_size", kind: "scalar", localName: "chunk_size", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UploadProgressResponse>): UploadProgressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msg = "";
        message.orig_name = "";
        message.chunk_size = 0;
        if (value !== undefined)
            reflectionMergePartial<UploadProgressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadProgressResponse): UploadProgressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg */ 1:
                    message.msg = reader.string();
                    break;
                case /* string orig_name */ 2:
                    message.orig_name = reader.string();
                    break;
                case /* int32 chunk_size */ 3:
                    message.chunk_size = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadProgressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg = 1; */
        if (message.msg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msg);
        /* string orig_name = 2; */
        if (message.orig_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orig_name);
        /* int32 chunk_size = 3; */
        if (message.chunk_size !== 0)
            writer.tag(3, WireType.Varint).int32(message.chunk_size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.UploadProgressResponse
 */
export const UploadProgressResponse = new UploadProgressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinResponse$Type extends MessageType<JoinResponse> {
    constructor() {
        super("parsed.JoinResponse", [
            { no: 1, name: "event_id", kind: "scalar", localName: "event_id", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JoinResponse>): JoinResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.event_id = "";
        if (value !== undefined)
            reflectionMergePartial<JoinResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinResponse): JoinResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string event_id */ 1:
                    message.event_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string event_id = 1; */
        if (message.event_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.event_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.JoinResponse
 */
export const JoinResponse = new JoinResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageRecord$Type extends MessageType<ImageRecord> {
    constructor() {
        super("parsed.ImageRecord", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bucket_name", kind: "scalar", localName: "bucket_name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "object_key", kind: "scalar", localName: "object_key", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "file_name", kind: "scalar", localName: "file_name", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "file_size", kind: "scalar", localName: "file_size", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "content_type", kind: "scalar", localName: "content_type", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "ref_bbox", kind: "message", localName: "ref_bbox", T: () => BBox },
            { no: 9, name: "bbox", kind: "message", T: () => BBox },
            { no: 10, name: "page_idx", kind: "scalar", localName: "page_idx", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "section_id", kind: "scalar", localName: "section_id", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "section_title", kind: "scalar", localName: "section_title", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImageRecord>): ImageRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.bucket_name = "";
        message.object_key = "";
        message.file_name = "";
        message.file_size = 0n;
        message.fileSHA256 = "";
        message.content_type = "";
        message.page_idx = 0;
        message.section_id = "";
        message.section_title = "";
        if (value !== undefined)
            reflectionMergePartial<ImageRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageRecord): ImageRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string bucket_name */ 2:
                    message.bucket_name = reader.string();
                    break;
                case /* string object_key */ 3:
                    message.object_key = reader.string();
                    break;
                case /* string file_name */ 4:
                    message.file_name = reader.string();
                    break;
                case /* int64 file_size */ 5:
                    message.file_size = reader.int64().toBigInt();
                    break;
                case /* string fileSHA256 */ 6:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string content_type */ 7:
                    message.content_type = reader.string();
                    break;
                case /* parsed.BBox ref_bbox */ 8:
                    message.ref_bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.ref_bbox);
                    break;
                case /* parsed.BBox bbox */ 9:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* int32 page_idx */ 10:
                    message.page_idx = reader.int32();
                    break;
                case /* string section_id */ 11:
                    message.section_id = reader.string();
                    break;
                case /* string section_title */ 12:
                    message.section_title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string bucket_name = 2; */
        if (message.bucket_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bucket_name);
        /* string object_key = 3; */
        if (message.object_key !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.object_key);
        /* string file_name = 4; */
        if (message.file_name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.file_name);
        /* int64 file_size = 5; */
        if (message.file_size !== 0n)
            writer.tag(5, WireType.Varint).int64(message.file_size);
        /* string fileSHA256 = 6; */
        if (message.fileSHA256 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fileSHA256);
        /* string content_type = 7; */
        if (message.content_type !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.content_type);
        /* parsed.BBox ref_bbox = 8; */
        if (message.ref_bbox)
            BBox.internalBinaryWrite(message.ref_bbox, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* parsed.BBox bbox = 9; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int32 page_idx = 10; */
        if (message.page_idx !== 0)
            writer.tag(10, WireType.Varint).int32(message.page_idx);
        /* string section_id = 11; */
        if (message.section_id !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.section_id);
        /* string section_title = 12; */
        if (message.section_title !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.section_title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.ImageRecord
 */
export const ImageRecord = new ImageRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaRecord$Type extends MessageType<FormulaRecord> {
    constructor() {
        super("parsed.FormulaRecord", [
            { no: 1, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bbox", kind: "message", T: () => BBox },
            { no: 3, name: "page_idx", kind: "scalar", localName: "page_idx", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "section_id", kind: "scalar", localName: "section_id", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "section_title", kind: "scalar", localName: "section_title", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FormulaRecord>): FormulaRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.content = "";
        message.page_idx = 0;
        message.section_id = "";
        message.section_title = "";
        if (value !== undefined)
            reflectionMergePartial<FormulaRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormulaRecord): FormulaRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content */ 1:
                    message.content = reader.string();
                    break;
                case /* parsed.BBox bbox */ 2:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* int32 page_idx */ 3:
                    message.page_idx = reader.int32();
                    break;
                case /* string section_id */ 4:
                    message.section_id = reader.string();
                    break;
                case /* string section_title */ 5:
                    message.section_title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormulaRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content = 1; */
        if (message.content !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.content);
        /* parsed.BBox bbox = 2; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 page_idx = 3; */
        if (message.page_idx !== 0)
            writer.tag(3, WireType.Varint).int32(message.page_idx);
        /* string section_id = 4; */
        if (message.section_id !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.section_id);
        /* string section_title = 5; */
        if (message.section_title !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.section_title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.FormulaRecord
 */
export const FormulaRecord = new FormulaRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventOutput$Type extends MessageType<EventOutput> {
    constructor() {
        super("parsed.EventOutput", [
            { no: 1, name: "data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventOutput>): EventOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<EventOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventOutput): EventOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string data */ 1:
                    message.data.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string data = 1; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.data[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.EventOutput
 */
export const EventOutput = new EventOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessCompletedEventMessage$Type extends MessageType<ProcessCompletedEventMessage> {
    constructor() {
        super("parsed.ProcessCompletedEventMessage", [
            { no: 1, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "event_id", kind: "scalar", localName: "event_id", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "output", kind: "message", T: () => EventOutput },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProcessCompletedEventMessage>): ProcessCompletedEventMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msg = "";
        message.event_id = "";
        message.success = false;
        message.title = "";
        if (value !== undefined)
            reflectionMergePartial<ProcessCompletedEventMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessCompletedEventMessage): ProcessCompletedEventMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg */ 1:
                    message.msg = reader.string();
                    break;
                case /* string event_id */ 2:
                    message.event_id = reader.string();
                    break;
                case /* parsed.EventOutput output */ 3:
                    message.output = EventOutput.internalBinaryRead(reader, reader.uint32(), options, message.output);
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                case /* string title */ 5:
                    message.title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessCompletedEventMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg = 1; */
        if (message.msg !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msg);
        /* string event_id = 2; */
        if (message.event_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.event_id);
        /* parsed.EventOutput output = 3; */
        if (message.output)
            EventOutput.internalBinaryWrite(message.output, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        /* string title = 5; */
        if (message.title !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.ProcessCompletedEventMessage
 */
export const ProcessCompletedEventMessage = new ProcessCompletedEventMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathInfo$Type extends MessageType<PathInfo> {
    constructor() {
        super("parsed.PathInfo", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "orig_name", kind: "scalar", localName: "orig_name", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "mime_type", kind: "scalar", localName: "mime_type", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_stream", kind: "scalar", localName: "is_stream", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "meta", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<PathInfo>): PathInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.url = "";
        message.size = 0;
        message.orig_name = "";
        message.mime_type = "";
        message.is_stream = false;
        message.meta = {};
        if (value !== undefined)
            reflectionMergePartial<PathInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PathInfo): PathInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* int32 size */ 3:
                    message.size = reader.int32();
                    break;
                case /* string orig_name */ 4:
                    message.orig_name = reader.string();
                    break;
                case /* string mime_type */ 5:
                    message.mime_type = reader.string();
                    break;
                case /* bool is_stream */ 6:
                    message.is_stream = reader.bool();
                    break;
                case /* map<string, string> meta */ 7:
                    this.binaryReadMap7(message.meta, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: PathInfo["meta"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PathInfo["meta"] | undefined, val: PathInfo["meta"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for parsed.PathInfo.meta");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: PathInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* int32 size = 3; */
        if (message.size !== 0)
            writer.tag(3, WireType.Varint).int32(message.size);
        /* string orig_name = 4; */
        if (message.orig_name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orig_name);
        /* string mime_type = 5; */
        if (message.mime_type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.mime_type);
        /* bool is_stream = 6; */
        if (message.is_stream !== false)
            writer.tag(6, WireType.Varint).bool(message.is_stream);
        /* map<string, string> meta = 7; */
        for (let k of globalThis.Object.keys(message.meta))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.meta[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.PathInfo
 */
export const PathInfo = new PathInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MineruPdfInfo$Type extends MessageType<MineruPdfInfo> {
    constructor() {
        super("parsed.MineruPdfInfo", [
            { no: 1, name: "pdf_info", kind: "message", localName: "pdf_info", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MineruPage }
        ]);
    }
    create(value?: PartialMessage<MineruPdfInfo>): MineruPdfInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdf_info = [];
        if (value !== undefined)
            reflectionMergePartial<MineruPdfInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MineruPdfInfo): MineruPdfInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated parsed.MineruPage pdf_info */ 1:
                    message.pdf_info.push(MineruPage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MineruPdfInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated parsed.MineruPage pdf_info = 1; */
        for (let i = 0; i < message.pdf_info.length; i++)
            MineruPage.internalBinaryWrite(message.pdf_info[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.MineruPdfInfo
 */
export const MineruPdfInfo = new MineruPdfInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MineruPage$Type extends MessageType<MineruPage> {
    constructor() {
        super("parsed.MineruPage", [
            { no: 1, name: "page_idx", kind: "scalar", localName: "page_idx", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_size", kind: "scalar", localName: "page_size", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "images", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ImageAndTable },
            { no: 4, name: "tables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ImageAndTable },
            { no: 5, name: "para_blocks", kind: "message", localName: "para_blocks", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Block },
            { no: 9, name: "preproc_blocks", kind: "message", localName: "preproc_blocks", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Block }
        ]);
    }
    create(value?: PartialMessage<MineruPage>): MineruPage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page_idx = 0;
        message.page_size = [];
        message.images = [];
        message.tables = [];
        message.para_blocks = [];
        message.preproc_blocks = [];
        if (value !== undefined)
            reflectionMergePartial<MineruPage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MineruPage): MineruPage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_idx */ 1:
                    message.page_idx = reader.int32();
                    break;
                case /* repeated double page_size */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.page_size.push(reader.double());
                    else
                        message.page_size.push(reader.double());
                    break;
                case /* repeated parsed.ImageAndTable images */ 3:
                    message.images.push(ImageAndTable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.ImageAndTable tables */ 4:
                    message.tables.push(ImageAndTable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.Block para_blocks */ 5:
                    message.para_blocks.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.Block preproc_blocks */ 9:
                    message.preproc_blocks.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MineruPage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_idx = 1; */
        if (message.page_idx !== 0)
            writer.tag(1, WireType.Varint).int32(message.page_idx);
        /* repeated double page_size = 2; */
        if (message.page_size.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.page_size.length; i++)
                writer.double(message.page_size[i]);
            writer.join();
        }
        /* repeated parsed.ImageAndTable images = 3; */
        for (let i = 0; i < message.images.length; i++)
            ImageAndTable.internalBinaryWrite(message.images[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.ImageAndTable tables = 4; */
        for (let i = 0; i < message.tables.length; i++)
            ImageAndTable.internalBinaryWrite(message.tables[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.Block para_blocks = 5; */
        for (let i = 0; i < message.para_blocks.length; i++)
            Block.internalBinaryWrite(message.para_blocks[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.Block preproc_blocks = 9; */
        for (let i = 0; i < message.preproc_blocks.length; i++)
            Block.internalBinaryWrite(message.preproc_blocks[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.MineruPage
 */
export const MineruPage = new MineruPage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Block$Type extends MessageType<Block> {
    constructor() {
        super("parsed.Block", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bbox", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "index", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "lines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Line },
            { no: 5, name: "page_num", kind: "scalar", localName: "page_num", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "page_size", kind: "scalar", localName: "page_size", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "group_id", kind: "scalar", localName: "group_id", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "virtual_lines", kind: "message", localName: "virtual_lines", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Line },
            { no: 9, name: "blocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Block },
            { no: 10, name: "lines_deleted", kind: "scalar", localName: "lines_deleted", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Block>): Block {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.bbox = [];
        message.index = 0;
        message.lines = [];
        message.page_num = 0;
        message.page_size = [];
        message.group_id = 0;
        message.virtual_lines = [];
        message.blocks = [];
        message.lines_deleted = false;
        if (value !== undefined)
            reflectionMergePartial<Block>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Block): Block {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated double bbox */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bbox.push(reader.double());
                    else
                        message.bbox.push(reader.double());
                    break;
                case /* double index */ 3:
                    message.index = reader.double();
                    break;
                case /* repeated parsed.Line lines */ 4:
                    message.lines.push(Line.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 page_num */ 5:
                    message.page_num = reader.int32();
                    break;
                case /* repeated double page_size */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.page_size.push(reader.double());
                    else
                        message.page_size.push(reader.double());
                    break;
                case /* double group_id */ 7:
                    message.group_id = reader.double();
                    break;
                case /* repeated parsed.Line virtual_lines */ 8:
                    message.virtual_lines.push(Line.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.Block blocks */ 9:
                    message.blocks.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool lines_deleted */ 10:
                    message.lines_deleted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Block, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated double bbox = 2; */
        if (message.bbox.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bbox.length; i++)
                writer.double(message.bbox[i]);
            writer.join();
        }
        /* double index = 3; */
        if (message.index !== 0)
            writer.tag(3, WireType.Bit64).double(message.index);
        /* repeated parsed.Line lines = 4; */
        for (let i = 0; i < message.lines.length; i++)
            Line.internalBinaryWrite(message.lines[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 page_num = 5; */
        if (message.page_num !== 0)
            writer.tag(5, WireType.Varint).int32(message.page_num);
        /* repeated double page_size = 6; */
        if (message.page_size.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.page_size.length; i++)
                writer.double(message.page_size[i]);
            writer.join();
        }
        /* double group_id = 7; */
        if (message.group_id !== 0)
            writer.tag(7, WireType.Bit64).double(message.group_id);
        /* repeated parsed.Line virtual_lines = 8; */
        for (let i = 0; i < message.virtual_lines.length; i++)
            Line.internalBinaryWrite(message.virtual_lines[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.Block blocks = 9; */
        for (let i = 0; i < message.blocks.length; i++)
            Block.internalBinaryWrite(message.blocks[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool lines_deleted = 10; */
        if (message.lines_deleted !== false)
            writer.tag(10, WireType.Varint).bool(message.lines_deleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Block
 */
export const Block = new Block$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Line$Type extends MessageType<Line> {
    constructor() {
        super("parsed.Line", [
            { no: 1, name: "bbox", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "index", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "spans", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Span }
        ]);
    }
    create(value?: PartialMessage<Line>): Line {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bbox = [];
        message.index = 0;
        message.spans = [];
        if (value !== undefined)
            reflectionMergePartial<Line>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Line): Line {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated double bbox */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bbox.push(reader.double());
                    else
                        message.bbox.push(reader.double());
                    break;
                case /* double index */ 2:
                    message.index = reader.double();
                    break;
                case /* repeated parsed.Span spans */ 3:
                    message.spans.push(Span.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Line, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated double bbox = 1; */
        if (message.bbox.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bbox.length; i++)
                writer.double(message.bbox[i]);
            writer.join();
        }
        /* double index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Bit64).double(message.index);
        /* repeated parsed.Span spans = 3; */
        for (let i = 0; i < message.spans.length; i++)
            Span.internalBinaryWrite(message.spans[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Line
 */
export const Line = new Line$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Span$Type extends MessageType<Span> {
    constructor() {
        super("parsed.Span", [
            { no: 1, name: "bbox", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "image_path", kind: "scalar", localName: "image_path", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "cross_page", kind: "scalar", localName: "cross_page", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Span>): Span {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bbox = [];
        message.source = "";
        message.content = "";
        message.type = "";
        message.image_path = "";
        message.cross_page = false;
        if (value !== undefined)
            reflectionMergePartial<Span>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Span): Span {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated double bbox */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bbox.push(reader.double());
                    else
                        message.bbox.push(reader.double());
                    break;
                case /* string source */ 2:
                    message.source = reader.string();
                    break;
                case /* string content */ 3:
                    message.content = reader.string();
                    break;
                case /* string type */ 4:
                    message.type = reader.string();
                    break;
                case /* string image_path */ 5:
                    message.image_path = reader.string();
                    break;
                case /* bool cross_page */ 6:
                    message.cross_page = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Span, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated double bbox = 1; */
        if (message.bbox.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bbox.length; i++)
                writer.double(message.bbox[i]);
            writer.join();
        }
        /* string source = 2; */
        if (message.source !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.source);
        /* string content = 3; */
        if (message.content !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.content);
        /* string type = 4; */
        if (message.type !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        /* string image_path = 5; */
        if (message.image_path !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.image_path);
        /* bool cross_page = 6; */
        if (message.cross_page !== false)
            writer.tag(6, WireType.Varint).bool(message.cross_page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Span
 */
export const Span = new Span$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterlineEquation$Type extends MessageType<InterlineEquation> {
    constructor() {
        super("parsed.InterlineEquation", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bbox", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "line", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "index", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "virtual_lines", kind: "message", localName: "virtual_lines", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Line }
        ]);
    }
    create(value?: PartialMessage<InterlineEquation>): InterlineEquation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.bbox = [];
        message.line = 0;
        message.index = 0;
        message.virtual_lines = [];
        if (value !== undefined)
            reflectionMergePartial<InterlineEquation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterlineEquation): InterlineEquation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated double bbox */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bbox.push(reader.double());
                    else
                        message.bbox.push(reader.double());
                    break;
                case /* double line */ 3:
                    message.line = reader.double();
                    break;
                case /* double index */ 4:
                    message.index = reader.double();
                    break;
                case /* repeated parsed.Line virtual_lines */ 5:
                    message.virtual_lines.push(Line.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterlineEquation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated double bbox = 2; */
        if (message.bbox.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bbox.length; i++)
                writer.double(message.bbox[i]);
            writer.join();
        }
        /* double line = 3; */
        if (message.line !== 0)
            writer.tag(3, WireType.Bit64).double(message.line);
        /* double index = 4; */
        if (message.index !== 0)
            writer.tag(4, WireType.Bit64).double(message.index);
        /* repeated parsed.Line virtual_lines = 5; */
        for (let i = 0; i < message.virtual_lines.length; i++)
            Line.internalBinaryWrite(message.virtual_lines[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.InterlineEquation
 */
export const InterlineEquation = new InterlineEquation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageAndTable$Type extends MessageType<ImageAndTable> {
    constructor() {
        super("parsed.ImageAndTable", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bbox", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "index", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "blocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Block }
        ]);
    }
    create(value?: PartialMessage<ImageAndTable>): ImageAndTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.bbox = [];
        message.index = 0;
        message.blocks = [];
        if (value !== undefined)
            reflectionMergePartial<ImageAndTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageAndTable): ImageAndTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated double bbox */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bbox.push(reader.double());
                    else
                        message.bbox.push(reader.double());
                    break;
                case /* double index */ 3:
                    message.index = reader.double();
                    break;
                case /* repeated parsed.Block blocks */ 4:
                    message.blocks.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageAndTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated double bbox = 2; */
        if (message.bbox.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bbox.length; i++)
                writer.double(message.bbox[i]);
            writer.join();
        }
        /* double index = 3; */
        if (message.index !== 0)
            writer.tag(3, WireType.Bit64).double(message.index);
        /* repeated parsed.Block blocks = 4; */
        for (let i = 0; i < message.blocks.length; i++)
            Block.internalBinaryWrite(message.blocks[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.ImageAndTable
 */
export const ImageAndTable = new ImageAndTable$Type();
