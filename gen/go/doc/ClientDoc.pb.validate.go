// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: definitions/doc/ClientDoc.proto

package doc

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetTopLevelFolderListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopLevelFolderListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopLevelFolderListReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTopLevelFolderListReqMultiError, or nil if none found.
func (m *GetTopLevelFolderListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopLevelFolderListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaperId

	if len(errors) > 0 {
		return GetTopLevelFolderListReqMultiError(errors)
	}

	return nil
}

// GetTopLevelFolderListReqMultiError is an error wrapping multiple validation
// errors returned by GetTopLevelFolderListReq.ValidateAll() if the designated
// constraints aren't met.
type GetTopLevelFolderListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopLevelFolderListReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopLevelFolderListReqMultiError) AllErrors() []error { return m }

// GetTopLevelFolderListReqValidationError is the validation error returned by
// GetTopLevelFolderListReq.Validate if the designated constraints aren't met.
type GetTopLevelFolderListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopLevelFolderListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopLevelFolderListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopLevelFolderListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopLevelFolderListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopLevelFolderListReqValidationError) ErrorName() string {
	return "GetTopLevelFolderListReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopLevelFolderListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopLevelFolderListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopLevelFolderListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopLevelFolderListReqValidationError{}

// Validate checks the field values on GetTopLevelFolderListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTopLevelFolderListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTopLevelFolderListResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTopLevelFolderListResponseMultiError, or nil if none found.
func (m *GetTopLevelFolderListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTopLevelFolderListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTopLevelFolderListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTopLevelFolderListResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTopLevelFolderListResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTopLevelFolderListResponseMultiError(errors)
	}

	return nil
}

// GetTopLevelFolderListResponseMultiError is an error wrapping multiple
// validation errors returned by GetTopLevelFolderListResponse.ValidateAll()
// if the designated constraints aren't met.
type GetTopLevelFolderListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTopLevelFolderListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTopLevelFolderListResponseMultiError) AllErrors() []error { return m }

// GetTopLevelFolderListResponseValidationError is the validation error
// returned by GetTopLevelFolderListResponse.Validate if the designated
// constraints aren't met.
type GetTopLevelFolderListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTopLevelFolderListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTopLevelFolderListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTopLevelFolderListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTopLevelFolderListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTopLevelFolderListResponseValidationError) ErrorName() string {
	return "GetTopLevelFolderListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTopLevelFolderListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTopLevelFolderListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTopLevelFolderListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTopLevelFolderListResponseValidationError{}

// Validate checks the field values on AttachPaperToFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttachPaperToFolderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttachPaperToFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttachPaperToFolderReqMultiError, or nil if none found.
func (m *AttachPaperToFolderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AttachPaperToFolderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaperId

	// no validation rules for FolderId

	if len(errors) > 0 {
		return AttachPaperToFolderReqMultiError(errors)
	}

	return nil
}

// AttachPaperToFolderReqMultiError is an error wrapping multiple validation
// errors returned by AttachPaperToFolderReq.ValidateAll() if the designated
// constraints aren't met.
type AttachPaperToFolderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachPaperToFolderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachPaperToFolderReqMultiError) AllErrors() []error { return m }

// AttachPaperToFolderReqValidationError is the validation error returned by
// AttachPaperToFolderReq.Validate if the designated constraints aren't met.
type AttachPaperToFolderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachPaperToFolderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachPaperToFolderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachPaperToFolderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachPaperToFolderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachPaperToFolderReqValidationError) ErrorName() string {
	return "AttachPaperToFolderReqValidationError"
}

// Error satisfies the builtin error interface
func (e AttachPaperToFolderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachPaperToFolderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachPaperToFolderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachPaperToFolderReqValidationError{}

// Validate checks the field values on AttachPaperToFolderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttachPaperToFolderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttachPaperToFolderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttachPaperToFolderResponseMultiError, or nil if none found.
func (m *AttachPaperToFolderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AttachPaperToFolderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Message

	// no validation rules for DocId

	if len(errors) > 0 {
		return AttachPaperToFolderResponseMultiError(errors)
	}

	return nil
}

// AttachPaperToFolderResponseMultiError is an error wrapping multiple
// validation errors returned by AttachPaperToFolderResponse.ValidateAll() if
// the designated constraints aren't met.
type AttachPaperToFolderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachPaperToFolderResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachPaperToFolderResponseMultiError) AllErrors() []error { return m }

// AttachPaperToFolderResponseValidationError is the validation error returned
// by AttachPaperToFolderResponse.Validate if the designated constraints
// aren't met.
type AttachPaperToFolderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachPaperToFolderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachPaperToFolderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachPaperToFolderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachPaperToFolderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachPaperToFolderResponseValidationError) ErrorName() string {
	return "AttachPaperToFolderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AttachPaperToFolderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachPaperToFolderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachPaperToFolderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachPaperToFolderResponseValidationError{}

// Validate checks the field values on RemoveDocFromFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveDocFromFolderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveDocFromFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveDocFromFolderReqMultiError, or nil if none found.
func (m *RemoveDocFromFolderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveDocFromFolderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRemovedDocItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RemoveDocFromFolderReqValidationError{
						field:  fmt.Sprintf("RemovedDocItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RemoveDocFromFolderReqValidationError{
						field:  fmt.Sprintf("RemovedDocItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RemoveDocFromFolderReqValidationError{
					field:  fmt.Sprintf("RemovedDocItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsHierarchicallyRemove

	if len(errors) > 0 {
		return RemoveDocFromFolderReqMultiError(errors)
	}

	return nil
}

// RemoveDocFromFolderReqMultiError is an error wrapping multiple validation
// errors returned by RemoveDocFromFolderReq.ValidateAll() if the designated
// constraints aren't met.
type RemoveDocFromFolderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveDocFromFolderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveDocFromFolderReqMultiError) AllErrors() []error { return m }

// RemoveDocFromFolderReqValidationError is the validation error returned by
// RemoveDocFromFolderReq.Validate if the designated constraints aren't met.
type RemoveDocFromFolderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveDocFromFolderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveDocFromFolderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveDocFromFolderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveDocFromFolderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveDocFromFolderReqValidationError) ErrorName() string {
	return "RemoveDocFromFolderReqValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveDocFromFolderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveDocFromFolderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveDocFromFolderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveDocFromFolderReqValidationError{}

// Validate checks the field values on RemovedDocItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RemovedDocItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemovedDocItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RemovedDocItemMultiError,
// or nil if none found.
func (m *RemovedDocItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RemovedDocItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocId

	// no validation rules for FolderId

	if len(errors) > 0 {
		return RemovedDocItemMultiError(errors)
	}

	return nil
}

// RemovedDocItemMultiError is an error wrapping multiple validation errors
// returned by RemovedDocItem.ValidateAll() if the designated constraints
// aren't met.
type RemovedDocItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemovedDocItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemovedDocItemMultiError) AllErrors() []error { return m }

// RemovedDocItemValidationError is the validation error returned by
// RemovedDocItem.Validate if the designated constraints aren't met.
type RemovedDocItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemovedDocItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemovedDocItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemovedDocItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemovedDocItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemovedDocItemValidationError) ErrorName() string { return "RemovedDocItemValidationError" }

// Error satisfies the builtin error interface
func (e RemovedDocItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemovedDocItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemovedDocItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemovedDocItemValidationError{}

// Validate checks the field values on CopyDocOrFolderToAnotherFolderReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CopyDocOrFolderToAnotherFolderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyDocOrFolderToAnotherFolderReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CopyDocOrFolderToAnotherFolderReqMultiError, or nil if none found.
func (m *CopyDocOrFolderToAnotherFolderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyDocOrFolderToAnotherFolderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetFolderId

	if len(errors) > 0 {
		return CopyDocOrFolderToAnotherFolderReqMultiError(errors)
	}

	return nil
}

// CopyDocOrFolderToAnotherFolderReqMultiError is an error wrapping multiple
// validation errors returned by
// CopyDocOrFolderToAnotherFolderReq.ValidateAll() if the designated
// constraints aren't met.
type CopyDocOrFolderToAnotherFolderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyDocOrFolderToAnotherFolderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyDocOrFolderToAnotherFolderReqMultiError) AllErrors() []error { return m }

// CopyDocOrFolderToAnotherFolderReqValidationError is the validation error
// returned by CopyDocOrFolderToAnotherFolderReq.Validate if the designated
// constraints aren't met.
type CopyDocOrFolderToAnotherFolderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyDocOrFolderToAnotherFolderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyDocOrFolderToAnotherFolderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyDocOrFolderToAnotherFolderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyDocOrFolderToAnotherFolderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyDocOrFolderToAnotherFolderReqValidationError) ErrorName() string {
	return "CopyDocOrFolderToAnotherFolderReqValidationError"
}

// Error satisfies the builtin error interface
func (e CopyDocOrFolderToAnotherFolderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyDocOrFolderToAnotherFolderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyDocOrFolderToAnotherFolderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyDocOrFolderToAnotherFolderReqValidationError{}

// Validate checks the field values on AttachDocToFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttachDocToFolderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttachDocToFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttachDocToFolderReqMultiError, or nil if none found.
func (m *AttachDocToFolderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AttachDocToFolderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocId

	// no validation rules for FolderId

	if len(errors) > 0 {
		return AttachDocToFolderReqMultiError(errors)
	}

	return nil
}

// AttachDocToFolderReqMultiError is an error wrapping multiple validation
// errors returned by AttachDocToFolderReq.ValidateAll() if the designated
// constraints aren't met.
type AttachDocToFolderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachDocToFolderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachDocToFolderReqMultiError) AllErrors() []error { return m }

// AttachDocToFolderReqValidationError is the validation error returned by
// AttachDocToFolderReq.Validate if the designated constraints aren't met.
type AttachDocToFolderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachDocToFolderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachDocToFolderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachDocToFolderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachDocToFolderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachDocToFolderReqValidationError) ErrorName() string {
	return "AttachDocToFolderReqValidationError"
}

// Error satisfies the builtin error interface
func (e AttachDocToFolderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachDocToFolderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachDocToFolderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachDocToFolderReqValidationError{}

// Validate checks the field values on RenameUserDocReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RenameUserDocReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenameUserDocReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenameUserDocReqMultiError, or nil if none found.
func (m *RenameUserDocReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RenameUserDocReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocId

	// no validation rules for DocName

	if len(errors) > 0 {
		return RenameUserDocReqMultiError(errors)
	}

	return nil
}

// RenameUserDocReqMultiError is an error wrapping multiple validation errors
// returned by RenameUserDocReq.ValidateAll() if the designated constraints
// aren't met.
type RenameUserDocReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenameUserDocReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenameUserDocReqMultiError) AllErrors() []error { return m }

// RenameUserDocReqValidationError is the validation error returned by
// RenameUserDocReq.Validate if the designated constraints aren't met.
type RenameUserDocReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenameUserDocReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenameUserDocReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenameUserDocReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenameUserDocReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenameUserDocReqValidationError) ErrorName() string { return "RenameUserDocReqValidationError" }

// Error satisfies the builtin error interface
func (e RenameUserDocReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenameUserDocReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenameUserDocReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenameUserDocReqValidationError{}

// Validate checks the field values on AddFolderReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddFolderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFolderReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddFolderReqMultiError, or
// nil if none found.
func (m *AddFolderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFolderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParentId

	// no validation rules for Name

	// no validation rules for Level

	// no validation rules for Sort

	for idx, item := range m.GetOldFolderItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddFolderReqValidationError{
						field:  fmt.Sprintf("OldFolderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddFolderReqValidationError{
						field:  fmt.Sprintf("OldFolderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddFolderReqValidationError{
					field:  fmt.Sprintf("OldFolderItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AddFolderReqMultiError(errors)
	}

	return nil
}

// AddFolderReqMultiError is an error wrapping multiple validation errors
// returned by AddFolderReq.ValidateAll() if the designated constraints aren't met.
type AddFolderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFolderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFolderReqMultiError) AllErrors() []error { return m }

// AddFolderReqValidationError is the validation error returned by
// AddFolderReq.Validate if the designated constraints aren't met.
type AddFolderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFolderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFolderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFolderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFolderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFolderReqValidationError) ErrorName() string { return "AddFolderReqValidationError" }

// Error satisfies the builtin error interface
func (e AddFolderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFolderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFolderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFolderReqValidationError{}

// Validate checks the field values on AddFolderResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddFolderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFolderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFolderResponseMultiError, or nil if none found.
func (m *AddFolderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFolderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddFolderResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddFolderResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddFolderResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AddFolderResponseMultiError(errors)
	}

	return nil
}

// AddFolderResponseMultiError is an error wrapping multiple validation errors
// returned by AddFolderResponse.ValidateAll() if the designated constraints
// aren't met.
type AddFolderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFolderResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFolderResponseMultiError) AllErrors() []error { return m }

// AddFolderResponseValidationError is the validation error returned by
// AddFolderResponse.Validate if the designated constraints aren't met.
type AddFolderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFolderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFolderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFolderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFolderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFolderResponseValidationError) ErrorName() string {
	return "AddFolderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddFolderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFolderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFolderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFolderResponseValidationError{}

// Validate checks the field values on FolderInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FolderInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FolderInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FolderInfoMultiError, or
// nil if none found.
func (m *FolderInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *FolderInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Remark

	if len(errors) > 0 {
		return FolderInfoMultiError(errors)
	}

	return nil
}

// FolderInfoMultiError is an error wrapping multiple validation errors
// returned by FolderInfo.ValidateAll() if the designated constraints aren't met.
type FolderInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FolderInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FolderInfoMultiError) AllErrors() []error { return m }

// FolderInfoValidationError is the validation error returned by
// FolderInfo.Validate if the designated constraints aren't met.
type FolderInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FolderInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FolderInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FolderInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FolderInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FolderInfoValidationError) ErrorName() string { return "FolderInfoValidationError" }

// Error satisfies the builtin error interface
func (e FolderInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFolderInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FolderInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FolderInfoValidationError{}

// Validate checks the field values on DeleteDocReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteDocReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDocReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteDocReqMultiError, or
// nil if none found.
func (m *DeleteDocReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDocReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteDocReqMultiError(errors)
	}

	return nil
}

// DeleteDocReqMultiError is an error wrapping multiple validation errors
// returned by DeleteDocReq.ValidateAll() if the designated constraints aren't met.
type DeleteDocReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDocReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDocReqMultiError) AllErrors() []error { return m }

// DeleteDocReqValidationError is the validation error returned by
// DeleteDocReq.Validate if the designated constraints aren't met.
type DeleteDocReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDocReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDocReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDocReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDocReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDocReqValidationError) ErrorName() string { return "DeleteDocReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteDocReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDocReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDocReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDocReqValidationError{}

// Validate checks the field values on DeleteFolderReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteFolderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFolderReqMultiError, or nil if none found.
func (m *DeleteFolderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFolderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteFolderReqMultiError(errors)
	}

	return nil
}

// DeleteFolderReqMultiError is an error wrapping multiple validation errors
// returned by DeleteFolderReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteFolderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFolderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFolderReqMultiError) AllErrors() []error { return m }

// DeleteFolderReqValidationError is the validation error returned by
// DeleteFolderReq.Validate if the designated constraints aren't met.
type DeleteFolderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFolderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFolderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFolderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFolderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFolderReqValidationError) ErrorName() string { return "DeleteFolderReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteFolderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFolderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFolderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFolderReqValidationError{}

// Validate checks the field values on UpdateFolderRemarkReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateFolderRemarkReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFolderRemarkReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateFolderRemarkReqMultiError, or nil if none found.
func (m *UpdateFolderRemarkReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFolderRemarkReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FolderId

	// no validation rules for Remark

	if len(errors) > 0 {
		return UpdateFolderRemarkReqMultiError(errors)
	}

	return nil
}

// UpdateFolderRemarkReqMultiError is an error wrapping multiple validation
// errors returned by UpdateFolderRemarkReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateFolderRemarkReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFolderRemarkReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFolderRemarkReqMultiError) AllErrors() []error { return m }

// UpdateFolderRemarkReqValidationError is the validation error returned by
// UpdateFolderRemarkReq.Validate if the designated constraints aren't met.
type UpdateFolderRemarkReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFolderRemarkReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFolderRemarkReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFolderRemarkReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFolderRemarkReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFolderRemarkReqValidationError) ErrorName() string {
	return "UpdateFolderRemarkReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFolderRemarkReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFolderRemarkReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFolderRemarkReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFolderRemarkReqValidationError{}

// Validate checks the field values on UpdateFolderReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateFolderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFolderReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateFolderReqMultiError, or nil if none found.
func (m *UpdateFolderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFolderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FolderId

	// no validation rules for Name

	if len(errors) > 0 {
		return UpdateFolderReqMultiError(errors)
	}

	return nil
}

// UpdateFolderReqMultiError is an error wrapping multiple validation errors
// returned by UpdateFolderReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateFolderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFolderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFolderReqMultiError) AllErrors() []error { return m }

// UpdateFolderReqValidationError is the validation error returned by
// UpdateFolderReq.Validate if the designated constraints aren't met.
type UpdateFolderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFolderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFolderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFolderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFolderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFolderReqValidationError) ErrorName() string { return "UpdateFolderReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateFolderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFolderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFolderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFolderReqValidationError{}

// Validate checks the field values on MoveFolderOrDocReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MoveFolderOrDocReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoveFolderOrDocReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MoveFolderOrDocReqMultiError, or nil if none found.
func (m *MoveFolderOrDocReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MoveFolderOrDocReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for SourceFolderId

	// no validation rules for TargetFolderId

	for idx, item := range m.GetTargetFolderItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MoveFolderOrDocReqValidationError{
						field:  fmt.Sprintf("TargetFolderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MoveFolderOrDocReqValidationError{
						field:  fmt.Sprintf("TargetFolderItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MoveFolderOrDocReqValidationError{
					field:  fmt.Sprintf("TargetFolderItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MoveFolderOrDocReqMultiError(errors)
	}

	return nil
}

// MoveFolderOrDocReqMultiError is an error wrapping multiple validation errors
// returned by MoveFolderOrDocReq.ValidateAll() if the designated constraints
// aren't met.
type MoveFolderOrDocReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoveFolderOrDocReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoveFolderOrDocReqMultiError) AllErrors() []error { return m }

// MoveFolderOrDocReqValidationError is the validation error returned by
// MoveFolderOrDocReq.Validate if the designated constraints aren't met.
type MoveFolderOrDocReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoveFolderOrDocReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoveFolderOrDocReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoveFolderOrDocReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoveFolderOrDocReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoveFolderOrDocReqValidationError) ErrorName() string {
	return "MoveFolderOrDocReqValidationError"
}

// Error satisfies the builtin error interface
func (e MoveFolderOrDocReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoveFolderOrDocReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoveFolderOrDocReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoveFolderOrDocReqValidationError{}

// Validate checks the field values on GetDocListByFolderIdReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocListByFolderIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocListByFolderIdReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocListByFolderIdReqMultiError, or nil if none found.
func (m *GetDocListByFolderIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocListByFolderIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FolderId

	// no validation rules for SortType

	if len(errors) > 0 {
		return GetDocListByFolderIdReqMultiError(errors)
	}

	return nil
}

// GetDocListByFolderIdReqMultiError is an error wrapping multiple validation
// errors returned by GetDocListByFolderIdReq.ValidateAll() if the designated
// constraints aren't met.
type GetDocListByFolderIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocListByFolderIdReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocListByFolderIdReqMultiError) AllErrors() []error { return m }

// GetDocListByFolderIdReqValidationError is the validation error returned by
// GetDocListByFolderIdReq.Validate if the designated constraints aren't met.
type GetDocListByFolderIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocListByFolderIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocListByFolderIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocListByFolderIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocListByFolderIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocListByFolderIdReqValidationError) ErrorName() string {
	return "GetDocListByFolderIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocListByFolderIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocListByFolderIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocListByFolderIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocListByFolderIdReqValidationError{}

// Validate checks the field values on GetDocListByFolderIdResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocListByFolderIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocListByFolderIdResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocListByFolderIdResponseMultiError, or nil if none found.
func (m *GetDocListByFolderIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocListByFolderIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDocListByFolderIdResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDocListByFolderIdResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDocListByFolderIdResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDocListByFolderIdResponseMultiError(errors)
	}

	return nil
}

// GetDocListByFolderIdResponseMultiError is an error wrapping multiple
// validation errors returned by GetDocListByFolderIdResponse.ValidateAll() if
// the designated constraints aren't met.
type GetDocListByFolderIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocListByFolderIdResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocListByFolderIdResponseMultiError) AllErrors() []error { return m }

// GetDocListByFolderIdResponseValidationError is the validation error returned
// by GetDocListByFolderIdResponse.Validate if the designated constraints
// aren't met.
type GetDocListByFolderIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocListByFolderIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocListByFolderIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocListByFolderIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocListByFolderIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocListByFolderIdResponseValidationError) ErrorName() string {
	return "GetDocListByFolderIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocListByFolderIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocListByFolderIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocListByFolderIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocListByFolderIdResponseValidationError{}

// Validate checks the field values on GetDocListByFolderIdForPageReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocListByFolderIdForPageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocListByFolderIdForPageReq with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDocListByFolderIdForPageReqMultiError, or nil if none found.
func (m *GetDocListByFolderIdForPageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocListByFolderIdForPageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FolderId

	// no validation rules for CurrentPage

	// no validation rules for PageSize

	if m.SortType != nil {
		// no validation rules for SortType
	}

	if len(errors) > 0 {
		return GetDocListByFolderIdForPageReqMultiError(errors)
	}

	return nil
}

// GetDocListByFolderIdForPageReqMultiError is an error wrapping multiple
// validation errors returned by GetDocListByFolderIdForPageReq.ValidateAll()
// if the designated constraints aren't met.
type GetDocListByFolderIdForPageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocListByFolderIdForPageReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocListByFolderIdForPageReqMultiError) AllErrors() []error { return m }

// GetDocListByFolderIdForPageReqValidationError is the validation error
// returned by GetDocListByFolderIdForPageReq.Validate if the designated
// constraints aren't met.
type GetDocListByFolderIdForPageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocListByFolderIdForPageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocListByFolderIdForPageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocListByFolderIdForPageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocListByFolderIdForPageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocListByFolderIdForPageReqValidationError) ErrorName() string {
	return "GetDocListByFolderIdForPageReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocListByFolderIdForPageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocListByFolderIdForPageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocListByFolderIdForPageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocListByFolderIdForPageReqValidationError{}

// Validate checks the field values on GetDocListByFolderIdForPageResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetDocListByFolderIdForPageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocListByFolderIdForPageResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetDocListByFolderIdForPageResponseMultiError, or nil if none found.
func (m *GetDocListByFolderIdForPageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocListByFolderIdForPageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetListDocDetailInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDocListByFolderIdForPageResponseValidationError{
						field:  fmt.Sprintf("ListDocDetailInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDocListByFolderIdForPageResponseValidationError{
						field:  fmt.Sprintf("ListDocDetailInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDocListByFolderIdForPageResponseValidationError{
					field:  fmt.Sprintf("ListDocDetailInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDocListByFolderIdForPageResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDocListByFolderIdForPageResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDocListByFolderIdForPageResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDocListByFolderIdForPageResponseMultiError(errors)
	}

	return nil
}

// GetDocListByFolderIdForPageResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetDocListByFolderIdForPageResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDocListByFolderIdForPageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocListByFolderIdForPageResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocListByFolderIdForPageResponseMultiError) AllErrors() []error { return m }

// GetDocListByFolderIdForPageResponseValidationError is the validation error
// returned by GetDocListByFolderIdForPageResponse.Validate if the designated
// constraints aren't met.
type GetDocListByFolderIdForPageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocListByFolderIdForPageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocListByFolderIdForPageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocListByFolderIdForPageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocListByFolderIdForPageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocListByFolderIdForPageResponseValidationError) ErrorName() string {
	return "GetDocListByFolderIdForPageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocListByFolderIdForPageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocListByFolderIdForPageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocListByFolderIdForPageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocListByFolderIdForPageResponseValidationError{}

// Validate checks the field values on DocDetailInfoForPage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocDetailInfoForPage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocDetailInfoForPage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocDetailInfoForPageMultiError, or nil if none found.
func (m *DocDetailInfoForPage) ValidateAll() error {
	return m.validate(true)
}

func (m *DocDetailInfoForPage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocId

	// no validation rules for DocName

	// no validation rules for Sort

	// no validation rules for PaperId

	// no validation rules for PdfId

	// no validation rules for Remark

	// no validation rules for PublishDate

	// no validation rules for CreateDate

	// no validation rules for LastReadTime

	// no validation rules for IsLatestRead

	for idx, item := range m.GetClassifyInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocDetailInfoForPageValidationError{
						field:  fmt.Sprintf("ClassifyInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocDetailInfoForPageValidationError{
						field:  fmt.Sprintf("ClassifyInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocDetailInfoForPageValidationError{
					field:  fmt.Sprintf("ClassifyInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PaperRepositoryStatus

	// no validation rules for NoteId

	if all {
		switch v := interface{}(m.GetDisplayVenue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocDetailInfoForPageValidationError{
					field:  "DisplayVenue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocDetailInfoForPageValidationError{
					field:  "DisplayVenue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisplayVenue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocDetailInfoForPageValidationError{
				field:  "DisplayVenue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDisplayAuthor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocDetailInfoForPageValidationError{
					field:  "DisplayAuthor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocDetailInfoForPageValidationError{
					field:  "DisplayAuthor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisplayAuthor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocDetailInfoForPageValidationError{
				field:  "DisplayAuthor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDisplayPublishDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocDetailInfoForPageValidationError{
					field:  "DisplayPublishDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocDetailInfoForPageValidationError{
					field:  "DisplayPublishDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisplayPublishDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocDetailInfoForPageValidationError{
				field:  "DisplayPublishDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PaperTitle

	// no validation rules for DocType

	for idx, item := range m.GetAuthorList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocDetailInfoForPageValidationError{
						field:  fmt.Sprintf("AuthorList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocDetailInfoForPageValidationError{
						field:  fmt.Sprintf("AuthorList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocDetailInfoForPageValidationError{
					field:  fmt.Sprintf("AuthorList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.EventTitle != nil {
		// no validation rules for EventTitle
	}

	if m.EventPlace != nil {
		// no validation rules for EventPlace
	}

	if m.Doi != nil {
		// no validation rules for Doi
	}

	if m.Volume != nil {
		// no validation rules for Volume
	}

	if m.Issue != nil {
		// no validation rules for Issue
	}

	if m.Url != nil {
		// no validation rules for Url
	}

	if m.Language != nil {
		// no validation rules for Language
	}

	if len(errors) > 0 {
		return DocDetailInfoForPageMultiError(errors)
	}

	return nil
}

// DocDetailInfoForPageMultiError is an error wrapping multiple validation
// errors returned by DocDetailInfoForPage.ValidateAll() if the designated
// constraints aren't met.
type DocDetailInfoForPageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocDetailInfoForPageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocDetailInfoForPageMultiError) AllErrors() []error { return m }

// DocDetailInfoForPageValidationError is the validation error returned by
// DocDetailInfoForPage.Validate if the designated constraints aren't met.
type DocDetailInfoForPageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocDetailInfoForPageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocDetailInfoForPageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocDetailInfoForPageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocDetailInfoForPageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocDetailInfoForPageValidationError) ErrorName() string {
	return "DocDetailInfoForPageValidationError"
}

// Error satisfies the builtin error interface
func (e DocDetailInfoForPageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocDetailInfoForPage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocDetailInfoForPageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocDetailInfoForPageValidationError{}

// Validate checks the field values on AuthorInfoForPage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AuthorInfoForPage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorInfoForPage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorInfoForPageMultiError, or nil if none found.
func (m *AuthorInfoForPage) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorInfoForPage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Given

	// no validation rules for Family

	// no validation rules for Literal

	if len(errors) > 0 {
		return AuthorInfoForPageMultiError(errors)
	}

	return nil
}

// AuthorInfoForPageMultiError is an error wrapping multiple validation errors
// returned by AuthorInfoForPage.ValidateAll() if the designated constraints
// aren't met.
type AuthorInfoForPageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorInfoForPageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorInfoForPageMultiError) AllErrors() []error { return m }

// AuthorInfoForPageValidationError is the validation error returned by
// AuthorInfoForPage.Validate if the designated constraints aren't met.
type AuthorInfoForPageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorInfoForPageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorInfoForPageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorInfoForPageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorInfoForPageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorInfoForPageValidationError) ErrorName() string {
	return "AuthorInfoForPageValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorInfoForPageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorInfoForPage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorInfoForPageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorInfoForPageValidationError{}

// Validate checks the field values on DocDetailInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DocDetailInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocDetailInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocDetailInfoMultiError, or
// nil if none found.
func (m *DocDetailInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DocDetailInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocId

	// no validation rules for DocName

	// no validation rules for Sort

	// no validation rules for PaperId

	// no validation rules for PdfId

	// no validation rules for Remark

	// no validation rules for PublishDate

	// no validation rules for CreateDate

	// no validation rules for LastReadTime

	// no validation rules for IsLatestRead

	for idx, item := range m.GetClassifyInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocDetailInfoValidationError{
						field:  fmt.Sprintf("ClassifyInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocDetailInfoValidationError{
						field:  fmt.Sprintf("ClassifyInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocDetailInfoValidationError{
					field:  fmt.Sprintf("ClassifyInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PaperRepositoryStatus

	// no validation rules for PrimaryVenue

	// no validation rules for NoteId

	if all {
		switch v := interface{}(m.GetDisplayVenue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocDetailInfoValidationError{
					field:  "DisplayVenue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocDetailInfoValidationError{
					field:  "DisplayVenue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisplayVenue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocDetailInfoValidationError{
				field:  "DisplayVenue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDisplayAuthor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocDetailInfoValidationError{
					field:  "DisplayAuthor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocDetailInfoValidationError{
					field:  "DisplayAuthor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisplayAuthor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocDetailInfoValidationError{
				field:  "DisplayAuthor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDisplayPublishDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocDetailInfoValidationError{
					field:  "DisplayPublishDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocDetailInfoValidationError{
					field:  "DisplayPublishDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisplayPublishDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocDetailInfoValidationError{
				field:  "DisplayPublishDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NewPaper

	// no validation rules for ParsedStatus

	// no validation rules for EmbeddingStatus

	if m.Language != nil {
		// no validation rules for Language
	}

	if m.Partition != nil {
		// no validation rules for Partition
	}

	if len(errors) > 0 {
		return DocDetailInfoMultiError(errors)
	}

	return nil
}

// DocDetailInfoMultiError is an error wrapping multiple validation errors
// returned by DocDetailInfo.ValidateAll() if the designated constraints
// aren't met.
type DocDetailInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocDetailInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocDetailInfoMultiError) AllErrors() []error { return m }

// DocDetailInfoValidationError is the validation error returned by
// DocDetailInfo.Validate if the designated constraints aren't met.
type DocDetailInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocDetailInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocDetailInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocDetailInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocDetailInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocDetailInfoValidationError) ErrorName() string { return "DocDetailInfoValidationError" }

// Error satisfies the builtin error interface
func (e DocDetailInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocDetailInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocDetailInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocDetailInfoValidationError{}

// Validate checks the field values on DocClassifyInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocClassifyInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocClassifyInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocClassifyInfoMultiError, or nil if none found.
func (m *DocClassifyInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DocClassifyInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClassifyId

	// no validation rules for ClassifyName

	if len(errors) > 0 {
		return DocClassifyInfoMultiError(errors)
	}

	return nil
}

// DocClassifyInfoMultiError is an error wrapping multiple validation errors
// returned by DocClassifyInfo.ValidateAll() if the designated constraints
// aren't met.
type DocClassifyInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocClassifyInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocClassifyInfoMultiError) AllErrors() []error { return m }

// DocClassifyInfoValidationError is the validation error returned by
// DocClassifyInfo.Validate if the designated constraints aren't met.
type DocClassifyInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocClassifyInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocClassifyInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocClassifyInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocClassifyInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocClassifyInfoValidationError) ErrorName() string { return "DocClassifyInfoValidationError" }

// Error satisfies the builtin error interface
func (e DocClassifyInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocClassifyInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocClassifyInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocClassifyInfoValidationError{}

// Validate checks the field values on DisplayVenue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DisplayVenue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisplayVenue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DisplayVenueMultiError, or
// nil if none found.
func (m *DisplayVenue) ValidateAll() error {
	return m.validate(true)
}

func (m *DisplayVenue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Venue

	// no validation rules for RollbackEnable

	// no validation rules for OriginVenue

	if len(errors) > 0 {
		return DisplayVenueMultiError(errors)
	}

	return nil
}

// DisplayVenueMultiError is an error wrapping multiple validation errors
// returned by DisplayVenue.ValidateAll() if the designated constraints aren't met.
type DisplayVenueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisplayVenueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisplayVenueMultiError) AllErrors() []error { return m }

// DisplayVenueValidationError is the validation error returned by
// DisplayVenue.Validate if the designated constraints aren't met.
type DisplayVenueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisplayVenueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisplayVenueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisplayVenueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisplayVenueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisplayVenueValidationError) ErrorName() string { return "DisplayVenueValidationError" }

// Error satisfies the builtin error interface
func (e DisplayVenueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisplayVenue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisplayVenueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisplayVenueValidationError{}

// Validate checks the field values on DisplayAuthor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DisplayAuthor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisplayAuthor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DisplayAuthorMultiError, or
// nil if none found.
func (m *DisplayAuthor) ValidateAll() error {
	return m.validate(true)
}

func (m *DisplayAuthor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RollbackEnable

	if len(errors) > 0 {
		return DisplayAuthorMultiError(errors)
	}

	return nil
}

// DisplayAuthorMultiError is an error wrapping multiple validation errors
// returned by DisplayAuthor.ValidateAll() if the designated constraints
// aren't met.
type DisplayAuthorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisplayAuthorMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisplayAuthorMultiError) AllErrors() []error { return m }

// DisplayAuthorValidationError is the validation error returned by
// DisplayAuthor.Validate if the designated constraints aren't met.
type DisplayAuthorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisplayAuthorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisplayAuthorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisplayAuthorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisplayAuthorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisplayAuthorValidationError) ErrorName() string { return "DisplayAuthorValidationError" }

// Error satisfies the builtin error interface
func (e DisplayAuthorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisplayAuthor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisplayAuthorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisplayAuthorValidationError{}

// Validate checks the field values on DisplayPublishDate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DisplayPublishDate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisplayPublishDate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisplayPublishDateMultiError, or nil if none found.
func (m *DisplayPublishDate) ValidateAll() error {
	return m.validate(true)
}

func (m *DisplayPublishDate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PublishDate

	// no validation rules for RollbackEnable

	// no validation rules for OriginPublishDate

	if len(errors) > 0 {
		return DisplayPublishDateMultiError(errors)
	}

	return nil
}

// DisplayPublishDateMultiError is an error wrapping multiple validation errors
// returned by DisplayPublishDate.ValidateAll() if the designated constraints
// aren't met.
type DisplayPublishDateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisplayPublishDateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisplayPublishDateMultiError) AllErrors() []error { return m }

// DisplayPublishDateValidationError is the validation error returned by
// DisplayPublishDate.Validate if the designated constraints aren't met.
type DisplayPublishDateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisplayPublishDateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisplayPublishDateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisplayPublishDateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisplayPublishDateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisplayPublishDateValidationError) ErrorName() string {
	return "DisplayPublishDateValidationError"
}

// Error satisfies the builtin error interface
func (e DisplayPublishDateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisplayPublishDate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisplayPublishDateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisplayPublishDateValidationError{}

// Validate checks the field values on GetFolderTreeAndSimpleDocInfoListReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetFolderTreeAndSimpleDocInfoListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFolderTreeAndSimpleDocInfoListReq
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetFolderTreeAndSimpleDocInfoListReqMultiError, or nil if none found.
func (m *GetFolderTreeAndSimpleDocInfoListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFolderTreeAndSimpleDocInfoListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetFolderTreeAndSimpleDocInfoListReqMultiError(errors)
	}

	return nil
}

// GetFolderTreeAndSimpleDocInfoListReqMultiError is an error wrapping multiple
// validation errors returned by
// GetFolderTreeAndSimpleDocInfoListReq.ValidateAll() if the designated
// constraints aren't met.
type GetFolderTreeAndSimpleDocInfoListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFolderTreeAndSimpleDocInfoListReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFolderTreeAndSimpleDocInfoListReqMultiError) AllErrors() []error { return m }

// GetFolderTreeAndSimpleDocInfoListReqValidationError is the validation error
// returned by GetFolderTreeAndSimpleDocInfoListReq.Validate if the designated
// constraints aren't met.
type GetFolderTreeAndSimpleDocInfoListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFolderTreeAndSimpleDocInfoListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFolderTreeAndSimpleDocInfoListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFolderTreeAndSimpleDocInfoListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFolderTreeAndSimpleDocInfoListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFolderTreeAndSimpleDocInfoListReqValidationError) ErrorName() string {
	return "GetFolderTreeAndSimpleDocInfoListReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetFolderTreeAndSimpleDocInfoListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFolderTreeAndSimpleDocInfoListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFolderTreeAndSimpleDocInfoListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFolderTreeAndSimpleDocInfoListReqValidationError{}

// Validate checks the field values on
// GetFolderTreeAndSimpleDocInfoListResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetFolderTreeAndSimpleDocInfoListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetFolderTreeAndSimpleDocInfoListResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetFolderTreeAndSimpleDocInfoListResponseMultiError, or nil if none found.
func (m *GetFolderTreeAndSimpleDocInfoListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFolderTreeAndSimpleDocInfoListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFolderTreeAndSimpleDocInfoListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFolderTreeAndSimpleDocInfoListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFolderTreeAndSimpleDocInfoListResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetFolderTreeAndSimpleDocInfoListResponseMultiError(errors)
	}

	return nil
}

// GetFolderTreeAndSimpleDocInfoListResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetFolderTreeAndSimpleDocInfoListResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFolderTreeAndSimpleDocInfoListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFolderTreeAndSimpleDocInfoListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFolderTreeAndSimpleDocInfoListResponseMultiError) AllErrors() []error { return m }

// GetFolderTreeAndSimpleDocInfoListResponseValidationError is the validation
// error returned by GetFolderTreeAndSimpleDocInfoListResponse.Validate if the
// designated constraints aren't met.
type GetFolderTreeAndSimpleDocInfoListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFolderTreeAndSimpleDocInfoListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFolderTreeAndSimpleDocInfoListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFolderTreeAndSimpleDocInfoListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFolderTreeAndSimpleDocInfoListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFolderTreeAndSimpleDocInfoListResponseValidationError) ErrorName() string {
	return "GetFolderTreeAndSimpleDocInfoListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFolderTreeAndSimpleDocInfoListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFolderTreeAndSimpleDocInfoListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFolderTreeAndSimpleDocInfoListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFolderTreeAndSimpleDocInfoListResponseValidationError{}

// Validate checks the field values on IndexFolderAndDocContent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndexFolderAndDocContent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndexFolderAndDocContent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndexFolderAndDocContentMultiError, or nil if none found.
func (m *IndexFolderAndDocContent) ValidateAll() error {
	return m.validate(true)
}

func (m *IndexFolderAndDocContent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalDocCount

	for idx, item := range m.GetFolderInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndexFolderAndDocContentValidationError{
						field:  fmt.Sprintf("FolderInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndexFolderAndDocContentValidationError{
						field:  fmt.Sprintf("FolderInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndexFolderAndDocContentValidationError{
					field:  fmt.Sprintf("FolderInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUnclassifiedDocInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndexFolderAndDocContentValidationError{
						field:  fmt.Sprintf("UnclassifiedDocInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndexFolderAndDocContentValidationError{
						field:  fmt.Sprintf("UnclassifiedDocInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndexFolderAndDocContentValidationError{
					field:  fmt.Sprintf("UnclassifiedDocInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndexFolderAndDocContentMultiError(errors)
	}

	return nil
}

// IndexFolderAndDocContentMultiError is an error wrapping multiple validation
// errors returned by IndexFolderAndDocContent.ValidateAll() if the designated
// constraints aren't met.
type IndexFolderAndDocContentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndexFolderAndDocContentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndexFolderAndDocContentMultiError) AllErrors() []error { return m }

// IndexFolderAndDocContentValidationError is the validation error returned by
// IndexFolderAndDocContent.Validate if the designated constraints aren't met.
type IndexFolderAndDocContentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndexFolderAndDocContentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndexFolderAndDocContentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndexFolderAndDocContentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndexFolderAndDocContentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndexFolderAndDocContentValidationError) ErrorName() string {
	return "IndexFolderAndDocContentValidationError"
}

// Error satisfies the builtin error interface
func (e IndexFolderAndDocContentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndexFolderAndDocContent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndexFolderAndDocContentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndexFolderAndDocContentValidationError{}

// Validate checks the field values on SimpleFolderInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SimpleFolderInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SimpleFolderInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SimpleFolderInfoMultiError, or nil if none found.
func (m *SimpleFolderInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SimpleFolderInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DocCount

	// no validation rules for ParentId

	// no validation rules for FolderId

	// no validation rules for Level

	// no validation rules for Sort

	for idx, item := range m.GetChildrenFolders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SimpleFolderInfoValidationError{
						field:  fmt.Sprintf("ChildrenFolders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SimpleFolderInfoValidationError{
						field:  fmt.Sprintf("ChildrenFolders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SimpleFolderInfoValidationError{
					field:  fmt.Sprintf("ChildrenFolders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDocInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SimpleFolderInfoValidationError{
						field:  fmt.Sprintf("DocInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SimpleFolderInfoValidationError{
						field:  fmt.Sprintf("DocInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SimpleFolderInfoValidationError{
					field:  fmt.Sprintf("DocInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsContainCurrentPaper

	// no validation rules for DocId

	if len(errors) > 0 {
		return SimpleFolderInfoMultiError(errors)
	}

	return nil
}

// SimpleFolderInfoMultiError is an error wrapping multiple validation errors
// returned by SimpleFolderInfo.ValidateAll() if the designated constraints
// aren't met.
type SimpleFolderInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SimpleFolderInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SimpleFolderInfoMultiError) AllErrors() []error { return m }

// SimpleFolderInfoValidationError is the validation error returned by
// SimpleFolderInfo.Validate if the designated constraints aren't met.
type SimpleFolderInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SimpleFolderInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SimpleFolderInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SimpleFolderInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SimpleFolderInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SimpleFolderInfoValidationError) ErrorName() string { return "SimpleFolderInfoValidationError" }

// Error satisfies the builtin error interface
func (e SimpleFolderInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSimpleFolderInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SimpleFolderInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SimpleFolderInfoValidationError{}

// Validate checks the field values on SimpleDocInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SimpleDocInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SimpleDocInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SimpleDocInfoMultiError, or
// nil if none found.
func (m *SimpleDocInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SimpleDocInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sort

	// no validation rules for DocName

	// no validation rules for DocId

	// no validation rules for PdfId

	// no validation rules for PaperId

	if len(errors) > 0 {
		return SimpleDocInfoMultiError(errors)
	}

	return nil
}

// SimpleDocInfoMultiError is an error wrapping multiple validation errors
// returned by SimpleDocInfo.ValidateAll() if the designated constraints
// aren't met.
type SimpleDocInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SimpleDocInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SimpleDocInfoMultiError) AllErrors() []error { return m }

// SimpleDocInfoValidationError is the validation error returned by
// SimpleDocInfo.Validate if the designated constraints aren't met.
type SimpleDocInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SimpleDocInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SimpleDocInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SimpleDocInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SimpleDocInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SimpleDocInfoValidationError) ErrorName() string { return "SimpleDocInfoValidationError" }

// Error satisfies the builtin error interface
func (e SimpleDocInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSimpleDocInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SimpleDocInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SimpleDocInfoValidationError{}
