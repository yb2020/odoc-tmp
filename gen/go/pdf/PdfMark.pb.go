// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v4.24.4
// source: definitions/pdf/PdfMark.proto

package pdf

import (
	note "github.com/yb2020/odoc-proto/gen/go/note"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SortTypeEnum int32

const (
	// 最新
	SortTypeEnum_NEWEST SortTypeEnum = 0
	// 最早
	SortTypeEnum_EARLIEST SortTypeEnum = 1
	// 默认排序: 列表时：按文献最近阅读倒序，搜索时：按搜索匹配度
	SortTypeEnum_SORT_DEFAULT SortTypeEnum = 2 // 改为 SORT_DEFAULT
)

// Enum value maps for SortTypeEnum.
var (
	SortTypeEnum_name = map[int32]string{
		0: "NEWEST",
		1: "EARLIEST",
		2: "SORT_DEFAULT",
	}
	SortTypeEnum_value = map[string]int32{
		"NEWEST":       0,
		"EARLIEST":     1,
		"SORT_DEFAULT": 2,
	}
)

func (x SortTypeEnum) Enum() *SortTypeEnum {
	p := new(SortTypeEnum)
	*p = x
	return p
}

func (x SortTypeEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SortTypeEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_definitions_pdf_PdfMark_proto_enumTypes[0].Descriptor()
}

func (SortTypeEnum) Type() protoreflect.EnumType {
	return &file_definitions_pdf_PdfMark_proto_enumTypes[0]
}

func (x SortTypeEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SortTypeEnum.Descriptor instead.
func (SortTypeEnum) EnumDescriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{0}
}

// @old_api_path: /pdfMark/v3/web/getByNote
// @api_path: /api/pdf/pdfMark/v3/web/getByNote
// @method: GET
// @content-type: application/json
// @summary: 获取笔记标注列表
type GetNoteAnnotationListByNoteIdRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NoteId        string                 `protobuf:"bytes,1,opt,name=noteId,proto3" json:"noteId,omitempty"`
	GroupId       string                 `protobuf:"bytes,2,opt,name=groupId,proto3" json:"groupId,omitempty"`
	Handtext      bool                   `protobuf:"varint,3,opt,name=handtext,proto3" json:"handtext,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetNoteAnnotationListByNoteIdRequest) Reset() {
	*x = GetNoteAnnotationListByNoteIdRequest{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNoteAnnotationListByNoteIdRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNoteAnnotationListByNoteIdRequest) ProtoMessage() {}

func (x *GetNoteAnnotationListByNoteIdRequest) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNoteAnnotationListByNoteIdRequest.ProtoReflect.Descriptor instead.
func (*GetNoteAnnotationListByNoteIdRequest) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{0}
}

func (x *GetNoteAnnotationListByNoteIdRequest) GetNoteId() string {
	if x != nil {
		return x.NoteId
	}
	return ""
}

func (x *GetNoteAnnotationListByNoteIdRequest) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

func (x *GetNoteAnnotationListByNoteIdRequest) GetHandtext() bool {
	if x != nil {
		return x.Handtext
	}
	return false
}

type GetNoteAnnotationListByNoteIdResponse struct {
	state         protoimpl.MessageState         `protogen:"open.v1"`
	Annotations   []*note.WebNoteAnnotationModel `protobuf:"bytes,1,rep,name=annotations,proto3" json:"annotations,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetNoteAnnotationListByNoteIdResponse) Reset() {
	*x = GetNoteAnnotationListByNoteIdResponse{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNoteAnnotationListByNoteIdResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNoteAnnotationListByNoteIdResponse) ProtoMessage() {}

func (x *GetNoteAnnotationListByNoteIdResponse) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNoteAnnotationListByNoteIdResponse.ProtoReflect.Descriptor instead.
func (*GetNoteAnnotationListByNoteIdResponse) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{1}
}

func (x *GetNoteAnnotationListByNoteIdResponse) GetAnnotations() []*note.WebNoteAnnotationModel {
	if x != nil {
		return x.Annotations
	}
	return nil
}

// @old_api_path: /pdfMark/v3/web/draw/getByNote
// @api_path: /api/pdf/pdfMark/v3/web/draw/getByNote
// @method: GET
// @content-type: application/json
// @summary: 获取笔记标注列表
type GetDrawNoteAnnotationListByNoteIdRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NoteId        string                 `protobuf:"bytes,1,opt,name=noteId,proto3" json:"noteId,omitempty"`
	GroupId       string                 `protobuf:"bytes,2,opt,name=groupId,proto3" json:"groupId,omitempty"`
	FetchAll      bool                   `protobuf:"varint,3,opt,name=fetchAll,proto3" json:"fetchAll,omitempty"`
	Handwrite     bool                   `protobuf:"varint,4,opt,name=handwrite,proto3" json:"handwrite,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetDrawNoteAnnotationListByNoteIdRequest) Reset() {
	*x = GetDrawNoteAnnotationListByNoteIdRequest{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetDrawNoteAnnotationListByNoteIdRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetDrawNoteAnnotationListByNoteIdRequest) ProtoMessage() {}

func (x *GetDrawNoteAnnotationListByNoteIdRequest) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetDrawNoteAnnotationListByNoteIdRequest.ProtoReflect.Descriptor instead.
func (*GetDrawNoteAnnotationListByNoteIdRequest) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{2}
}

func (x *GetDrawNoteAnnotationListByNoteIdRequest) GetNoteId() string {
	if x != nil {
		return x.NoteId
	}
	return ""
}

func (x *GetDrawNoteAnnotationListByNoteIdRequest) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

func (x *GetDrawNoteAnnotationListByNoteIdRequest) GetFetchAll() bool {
	if x != nil {
		return x.FetchAll
	}
	return false
}

func (x *GetDrawNoteAnnotationListByNoteIdRequest) GetHandwrite() bool {
	if x != nil {
		return x.Handwrite
	}
	return false
}

type GetDrawNoteAnnotationListByNoteIdResponse struct {
	state         protoimpl.MessageState         `protogen:"open.v1"`
	Annotations   []*note.WebNoteAnnotationModel `protobuf:"bytes,1,rep,name=annotations,proto3" json:"annotations,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetDrawNoteAnnotationListByNoteIdResponse) Reset() {
	*x = GetDrawNoteAnnotationListByNoteIdResponse{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetDrawNoteAnnotationListByNoteIdResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetDrawNoteAnnotationListByNoteIdResponse) ProtoMessage() {}

func (x *GetDrawNoteAnnotationListByNoteIdResponse) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetDrawNoteAnnotationListByNoteIdResponse.ProtoReflect.Descriptor instead.
func (*GetDrawNoteAnnotationListByNoteIdResponse) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{3}
}

func (x *GetDrawNoteAnnotationListByNoteIdResponse) GetAnnotations() []*note.WebNoteAnnotationModel {
	if x != nil {
		return x.Annotations
	}
	return nil
}

// @api_path: /api/pdf/pdfMark/v2/web/hotSelect
// @method: GET
// @content-type: application/json
// @summary: 获取热选笔记标注列表
type HotSelectRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PdfId         string                 `protobuf:"bytes,1,opt,name=pdfId,proto3" json:"pdfId,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HotSelectRequest) Reset() {
	*x = HotSelectRequest{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HotSelectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HotSelectRequest) ProtoMessage() {}

func (x *HotSelectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HotSelectRequest.ProtoReflect.Descriptor instead.
func (*HotSelectRequest) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{4}
}

func (x *HotSelectRequest) GetPdfId() string {
	if x != nil {
		return x.PdfId
	}
	return ""
}

type HotSelectResponse struct {
	state         protoimpl.MessageState         `protogen:"open.v1"`
	Annotations   []*note.WebNoteAnnotationModel `protobuf:"bytes,1,rep,name=annotations,proto3" json:"annotations,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HotSelectResponse) Reset() {
	*x = HotSelectResponse{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HotSelectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HotSelectResponse) ProtoMessage() {}

func (x *HotSelectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HotSelectResponse.ProtoReflect.Descriptor instead.
func (*HotSelectResponse) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{5}
}

func (x *HotSelectResponse) GetAnnotations() []*note.WebNoteAnnotationModel {
	if x != nil {
		return x.Annotations
	}
	return nil
}

// *
// @api_path: /api/pdf/pdfMark/v2/web/getMyNoteMarkList
// @method: POST
// @content-type: application/json
// @summary: 查询我的笔记列表
type GetMyNoteMarkListReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 文件夹id
	FolderId *string `protobuf:"bytes,1,opt,name=folderId,proto3,oneof" json:"folderId,omitempty"`
	// 标签id
	TagIdList []string `protobuf:"bytes,2,rep,name=tagIdList,proto3" json:"tagIdList,omitempty"`
	// 排序
	SortType    SortTypeEnum `protobuf:"varint,3,opt,name=sortType,proto3,enum=pdf.SortTypeEnum" json:"sortType,omitempty"`
	CurrentPage int32        `protobuf:"varint,4,opt,name=currentPage,proto3" json:"currentPage,omitempty"`
	PageSize    int32        `protobuf:"varint,5,opt,name=pageSize,proto3" json:"pageSize,omitempty"`
	// 搜索内容
	SearchContent string `protobuf:"bytes,6,opt,name=searchContent,proto3" json:"searchContent,omitempty"`
	// 显示规则
	StyleIdList []uint32 `protobuf:"varint,7,rep,packed,name=styleIdList,proto3" json:"styleIdList,omitempty"`
	// 文献id
	DocId         *string `protobuf:"bytes,8,opt,name=docId,proto3,oneof" json:"docId,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMyNoteMarkListReq) Reset() {
	*x = GetMyNoteMarkListReq{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMyNoteMarkListReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMyNoteMarkListReq) ProtoMessage() {}

func (x *GetMyNoteMarkListReq) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMyNoteMarkListReq.ProtoReflect.Descriptor instead.
func (*GetMyNoteMarkListReq) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{6}
}

func (x *GetMyNoteMarkListReq) GetFolderId() string {
	if x != nil && x.FolderId != nil {
		return *x.FolderId
	}
	return ""
}

func (x *GetMyNoteMarkListReq) GetTagIdList() []string {
	if x != nil {
		return x.TagIdList
	}
	return nil
}

func (x *GetMyNoteMarkListReq) GetSortType() SortTypeEnum {
	if x != nil {
		return x.SortType
	}
	return SortTypeEnum_NEWEST
}

func (x *GetMyNoteMarkListReq) GetCurrentPage() int32 {
	if x != nil {
		return x.CurrentPage
	}
	return 0
}

func (x *GetMyNoteMarkListReq) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *GetMyNoteMarkListReq) GetSearchContent() string {
	if x != nil {
		return x.SearchContent
	}
	return ""
}

func (x *GetMyNoteMarkListReq) GetStyleIdList() []uint32 {
	if x != nil {
		return x.StyleIdList
	}
	return nil
}

func (x *GetMyNoteMarkListReq) GetDocId() string {
	if x != nil && x.DocId != nil {
		return *x.DocId
	}
	return ""
}

// *
// @api_path: /api/pdf/pdfMark/v2/web/getMyNoteMarkList
// @method: POST
// @content-type: application/json
// @summary: 查询我的笔记列表
type GetMyNoteMarkListResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 笔记内容
	AnnotationModelList []*note.WebNoteAnnotationModel `protobuf:"bytes,1,rep,name=annotationModelList,proto3" json:"annotationModelList,omitempty"`
	Total               int32                          `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *GetMyNoteMarkListResponse) Reset() {
	*x = GetMyNoteMarkListResponse{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMyNoteMarkListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMyNoteMarkListResponse) ProtoMessage() {}

func (x *GetMyNoteMarkListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMyNoteMarkListResponse.ProtoReflect.Descriptor instead.
func (*GetMyNoteMarkListResponse) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{7}
}

func (x *GetMyNoteMarkListResponse) GetAnnotationModelList() []*note.WebNoteAnnotationModel {
	if x != nil {
		return x.AnnotationModelList
	}
	return nil
}

func (x *GetMyNoteMarkListResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

// @api_path: /api/pdf/pdfMark/v2/web/save
// @method post
// @summary 保存标注笔记
type SavePdfMarkRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NoteId        string                 `protobuf:"bytes,1,opt,name=noteId,proto3" json:"noteId,omitempty"`
	GroupId       string                 `protobuf:"bytes,2,opt,name=groupId,proto3" json:"groupId,omitempty"`
	Handtext      bool                   `protobuf:"varint,3,opt,name=handtext,proto3" json:"handtext,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SavePdfMarkRequest) Reset() {
	*x = SavePdfMarkRequest{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SavePdfMarkRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SavePdfMarkRequest) ProtoMessage() {}

func (x *SavePdfMarkRequest) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SavePdfMarkRequest.ProtoReflect.Descriptor instead.
func (*SavePdfMarkRequest) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{8}
}

func (x *SavePdfMarkRequest) GetNoteId() string {
	if x != nil {
		return x.NoteId
	}
	return ""
}

func (x *SavePdfMarkRequest) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

func (x *SavePdfMarkRequest) GetHandtext() bool {
	if x != nil {
		return x.Handtext
	}
	return false
}

type SavePdfMarkResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Uuid          string                 `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SavePdfMarkResponse) Reset() {
	*x = SavePdfMarkResponse{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SavePdfMarkResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SavePdfMarkResponse) ProtoMessage() {}

func (x *SavePdfMarkResponse) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SavePdfMarkResponse.ProtoReflect.Descriptor instead.
func (*SavePdfMarkResponse) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{9}
}

func (x *SavePdfMarkResponse) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

// @api_path: /api/pdf/pdfMark/v2/web/update
// @method post
// @summary 更新标注笔记
type UpdatePdfMarkRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdatePdfMarkRequest) Reset() {
	*x = UpdatePdfMarkRequest{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdatePdfMarkRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdatePdfMarkRequest) ProtoMessage() {}

func (x *UpdatePdfMarkRequest) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdatePdfMarkRequest.ProtoReflect.Descriptor instead.
func (*UpdatePdfMarkRequest) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{10}
}

type UpdatePdfMarkResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Uuid          string                 `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdatePdfMarkResponse) Reset() {
	*x = UpdatePdfMarkResponse{}
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdatePdfMarkResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdatePdfMarkResponse) ProtoMessage() {}

func (x *UpdatePdfMarkResponse) ProtoReflect() protoreflect.Message {
	mi := &file_definitions_pdf_PdfMark_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdatePdfMarkResponse.ProtoReflect.Descriptor instead.
func (*UpdatePdfMarkResponse) Descriptor() ([]byte, []int) {
	return file_definitions_pdf_PdfMark_proto_rawDescGZIP(), []int{11}
}

func (x *UpdatePdfMarkResponse) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

var File_definitions_pdf_PdfMark_proto protoreflect.FileDescriptor

const file_definitions_pdf_PdfMark_proto_rawDesc = "" +
	"\n" +
	"\x1ddefinitions/pdf/PdfMark.proto\x12\x03pdf\x1a\x1adefinitions/note/Web.proto\"t\n" +
	"$GetNoteAnnotationListByNoteIdRequest\x12\x16\n" +
	"\x06noteId\x18\x01 \x01(\tR\x06noteId\x12\x18\n" +
	"\agroupId\x18\x02 \x01(\tR\agroupId\x12\x1a\n" +
	"\bhandtext\x18\x03 \x01(\bR\bhandtext\"g\n" +
	"%GetNoteAnnotationListByNoteIdResponse\x12>\n" +
	"\vannotations\x18\x01 \x03(\v2\x1c.note.WebNoteAnnotationModelR\vannotations\"\x96\x01\n" +
	"(GetDrawNoteAnnotationListByNoteIdRequest\x12\x16\n" +
	"\x06noteId\x18\x01 \x01(\tR\x06noteId\x12\x18\n" +
	"\agroupId\x18\x02 \x01(\tR\agroupId\x12\x1a\n" +
	"\bfetchAll\x18\x03 \x01(\bR\bfetchAll\x12\x1c\n" +
	"\thandwrite\x18\x04 \x01(\bR\thandwrite\"k\n" +
	")GetDrawNoteAnnotationListByNoteIdResponse\x12>\n" +
	"\vannotations\x18\x01 \x03(\v2\x1c.note.WebNoteAnnotationModelR\vannotations\"(\n" +
	"\x10HotSelectRequest\x12\x14\n" +
	"\x05pdfId\x18\x01 \x01(\tR\x05pdfId\"S\n" +
	"\x11HotSelectResponse\x12>\n" +
	"\vannotations\x18\x01 \x03(\v2\x1c.note.WebNoteAnnotationModelR\vannotations\"\xbc\x02\n" +
	"\x14GetMyNoteMarkListReq\x12\x1f\n" +
	"\bfolderId\x18\x01 \x01(\tH\x00R\bfolderId\x88\x01\x01\x12\x1c\n" +
	"\ttagIdList\x18\x02 \x03(\tR\ttagIdList\x12-\n" +
	"\bsortType\x18\x03 \x01(\x0e2\x11.pdf.SortTypeEnumR\bsortType\x12 \n" +
	"\vcurrentPage\x18\x04 \x01(\x05R\vcurrentPage\x12\x1a\n" +
	"\bpageSize\x18\x05 \x01(\x05R\bpageSize\x12$\n" +
	"\rsearchContent\x18\x06 \x01(\tR\rsearchContent\x12 \n" +
	"\vstyleIdList\x18\a \x03(\rR\vstyleIdList\x12\x19\n" +
	"\x05docId\x18\b \x01(\tH\x01R\x05docId\x88\x01\x01B\v\n" +
	"\t_folderIdB\b\n" +
	"\x06_docId\"\x81\x01\n" +
	"\x19GetMyNoteMarkListResponse\x12N\n" +
	"\x13annotationModelList\x18\x01 \x03(\v2\x1c.note.WebNoteAnnotationModelR\x13annotationModelList\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"b\n" +
	"\x12SavePdfMarkRequest\x12\x16\n" +
	"\x06noteId\x18\x01 \x01(\tR\x06noteId\x12\x18\n" +
	"\agroupId\x18\x02 \x01(\tR\agroupId\x12\x1a\n" +
	"\bhandtext\x18\x03 \x01(\bR\bhandtext\")\n" +
	"\x13SavePdfMarkResponse\x12\x12\n" +
	"\x04uuid\x18\x01 \x01(\tR\x04uuid\"\x16\n" +
	"\x14UpdatePdfMarkRequest\"+\n" +
	"\x15UpdatePdfMarkResponse\x12\x12\n" +
	"\x04uuid\x18\x01 \x01(\tR\x04uuid*:\n" +
	"\fSortTypeEnum\x12\n" +
	"\n" +
	"\x06NEWEST\x10\x00\x12\f\n" +
	"\bEARLIEST\x10\x01\x12\x10\n" +
	"\fSORT_DEFAULT\x10\x02B)Z'github.com/yb2020/odoc-proto/gen/go/pdfb\x06proto3"

var (
	file_definitions_pdf_PdfMark_proto_rawDescOnce sync.Once
	file_definitions_pdf_PdfMark_proto_rawDescData []byte
)

func file_definitions_pdf_PdfMark_proto_rawDescGZIP() []byte {
	file_definitions_pdf_PdfMark_proto_rawDescOnce.Do(func() {
		file_definitions_pdf_PdfMark_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_definitions_pdf_PdfMark_proto_rawDesc), len(file_definitions_pdf_PdfMark_proto_rawDesc)))
	})
	return file_definitions_pdf_PdfMark_proto_rawDescData
}

var file_definitions_pdf_PdfMark_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_definitions_pdf_PdfMark_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_definitions_pdf_PdfMark_proto_goTypes = []any{
	(SortTypeEnum)(0), // 0: pdf.SortTypeEnum
	(*GetNoteAnnotationListByNoteIdRequest)(nil),      // 1: pdf.GetNoteAnnotationListByNoteIdRequest
	(*GetNoteAnnotationListByNoteIdResponse)(nil),     // 2: pdf.GetNoteAnnotationListByNoteIdResponse
	(*GetDrawNoteAnnotationListByNoteIdRequest)(nil),  // 3: pdf.GetDrawNoteAnnotationListByNoteIdRequest
	(*GetDrawNoteAnnotationListByNoteIdResponse)(nil), // 4: pdf.GetDrawNoteAnnotationListByNoteIdResponse
	(*HotSelectRequest)(nil),                          // 5: pdf.HotSelectRequest
	(*HotSelectResponse)(nil),                         // 6: pdf.HotSelectResponse
	(*GetMyNoteMarkListReq)(nil),                      // 7: pdf.GetMyNoteMarkListReq
	(*GetMyNoteMarkListResponse)(nil),                 // 8: pdf.GetMyNoteMarkListResponse
	(*SavePdfMarkRequest)(nil),                        // 9: pdf.SavePdfMarkRequest
	(*SavePdfMarkResponse)(nil),                       // 10: pdf.SavePdfMarkResponse
	(*UpdatePdfMarkRequest)(nil),                      // 11: pdf.UpdatePdfMarkRequest
	(*UpdatePdfMarkResponse)(nil),                     // 12: pdf.UpdatePdfMarkResponse
	(*note.WebNoteAnnotationModel)(nil),               // 13: note.WebNoteAnnotationModel
}
var file_definitions_pdf_PdfMark_proto_depIdxs = []int32{
	13, // 0: pdf.GetNoteAnnotationListByNoteIdResponse.annotations:type_name -> note.WebNoteAnnotationModel
	13, // 1: pdf.GetDrawNoteAnnotationListByNoteIdResponse.annotations:type_name -> note.WebNoteAnnotationModel
	13, // 2: pdf.HotSelectResponse.annotations:type_name -> note.WebNoteAnnotationModel
	0,  // 3: pdf.GetMyNoteMarkListReq.sortType:type_name -> pdf.SortTypeEnum
	13, // 4: pdf.GetMyNoteMarkListResponse.annotationModelList:type_name -> note.WebNoteAnnotationModel
	5,  // [5:5] is the sub-list for method output_type
	5,  // [5:5] is the sub-list for method input_type
	5,  // [5:5] is the sub-list for extension type_name
	5,  // [5:5] is the sub-list for extension extendee
	0,  // [0:5] is the sub-list for field type_name
}

func init() { file_definitions_pdf_PdfMark_proto_init() }
func file_definitions_pdf_PdfMark_proto_init() {
	if File_definitions_pdf_PdfMark_proto != nil {
		return
	}
	file_definitions_pdf_PdfMark_proto_msgTypes[6].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_definitions_pdf_PdfMark_proto_rawDesc), len(file_definitions_pdf_PdfMark_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_definitions_pdf_PdfMark_proto_goTypes,
		DependencyIndexes: file_definitions_pdf_PdfMark_proto_depIdxs,
		EnumInfos:         file_definitions_pdf_PdfMark_proto_enumTypes,
		MessageInfos:      file_definitions_pdf_PdfMark_proto_msgTypes,
	}.Build()
	File_definitions_pdf_PdfMark_proto = out.File
	file_definitions_pdf_PdfMark_proto_goTypes = nil
	file_definitions_pdf_PdfMark_proto_depIdxs = nil
}
