// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: definitions/membership/MembershipApi.proto

package membership

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SubInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SubInfoMultiError, or nil if none found.
func (m *SubInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SubInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Price

	// no validation rules for OriginalPrice

	// no validation rules for Currency

	// no validation rules for Credit

	// no validation rules for OriginalCredit

	// no validation rules for AddOnCredit

	// no validation rules for Duration

	// no validation rules for StripePayMode

	// no validation rules for StripePriceId

	if len(errors) > 0 {
		return SubInfoMultiError(errors)
	}

	return nil
}

// SubInfoMultiError is an error wrapping multiple validation errors returned
// by SubInfo.ValidateAll() if the designated constraints aren't met.
type SubInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubInfoMultiError) AllErrors() []error { return m }

// SubInfoValidationError is the validation error returned by SubInfo.Validate
// if the designated constraints aren't met.
type SubInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubInfoValidationError) ErrorName() string { return "SubInfoValidationError" }

// Error satisfies the builtin error interface
func (e SubInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubInfoValidationError{}

// Validate checks the field values on BasePermission with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BasePermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BasePermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BasePermissionMultiError,
// or nil if none found.
func (m *BasePermission) ValidateAll() error {
	return m.validate(true)
}

func (m *BasePermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BasePermissionValidationError{
					field:  "SubInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BasePermissionValidationError{
					field:  "SubInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BasePermissionValidationError{
				field:  "SubInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsEnableAddOnCredit

	// no validation rules for IsEnableSubAddOnCredit

	// no validation rules for MaxAddOnCreditSubCountOfMonth

	if all {
		switch v := interface{}(m.GetSubAddOnCreditInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BasePermissionValidationError{
					field:  "SubAddOnCreditInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BasePermissionValidationError{
					field:  "SubAddOnCreditInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubAddOnCreditInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BasePermissionValidationError{
				field:  "SubAddOnCreditInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BasePermissionMultiError(errors)
	}

	return nil
}

// BasePermissionMultiError is an error wrapping multiple validation errors
// returned by BasePermission.ValidateAll() if the designated constraints
// aren't met.
type BasePermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BasePermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BasePermissionMultiError) AllErrors() []error { return m }

// BasePermissionValidationError is the validation error returned by
// BasePermission.Validate if the designated constraints aren't met.
type BasePermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BasePermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BasePermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BasePermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BasePermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BasePermissionValidationError) ErrorName() string { return "BasePermissionValidationError" }

// Error satisfies the builtin error interface
func (e BasePermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBasePermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BasePermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BasePermissionValidationError{}

// Validate checks the field values on DocsPermission with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DocsPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocsPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocsPermissionMultiError,
// or nil if none found.
func (m *DocsPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *DocsPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxStorageCapacity

	// no validation rules for MaxStorageCapacityOriginal

	// no validation rules for DocUploadMaxSize

	// no validation rules for DocUploadMaxSizeOriginal

	// no validation rules for DocUploadMaxPageCount

	// no validation rules for DocUploadMaxPageCountOriginal

	if len(errors) > 0 {
		return DocsPermissionMultiError(errors)
	}

	return nil
}

// DocsPermissionMultiError is an error wrapping multiple validation errors
// returned by DocsPermission.ValidateAll() if the designated constraints
// aren't met.
type DocsPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocsPermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocsPermissionMultiError) AllErrors() []error { return m }

// DocsPermissionValidationError is the validation error returned by
// DocsPermission.Validate if the designated constraints aren't met.
type DocsPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocsPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocsPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocsPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocsPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocsPermissionValidationError) ErrorName() string { return "DocsPermissionValidationError" }

// Error satisfies the builtin error interface
func (e DocsPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocsPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocsPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocsPermissionValidationError{}

// Validate checks the field values on NotePermission with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotePermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotePermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotePermissionMultiError,
// or nil if none found.
func (m *NotePermission) ValidateAll() error {
	return m.validate(true)
}

func (m *NotePermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsNoteSummary

	// no validation rules for IsNoteWord

	// no validation rules for IsNoteExtract

	// no validation rules for IsNoteManage

	// no validation rules for IsNotePdfDownload

	if len(errors) > 0 {
		return NotePermissionMultiError(errors)
	}

	return nil
}

// NotePermissionMultiError is an error wrapping multiple validation errors
// returned by NotePermission.ValidateAll() if the designated constraints
// aren't met.
type NotePermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotePermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotePermissionMultiError) AllErrors() []error { return m }

// NotePermissionValidationError is the validation error returned by
// NotePermission.Validate if the designated constraints aren't met.
type NotePermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotePermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotePermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotePermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotePermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotePermissionValidationError) ErrorName() string { return "NotePermissionValidationError" }

// Error satisfies the builtin error interface
func (e NotePermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotePermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotePermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotePermissionValidationError{}

// Validate checks the field values on CopilotModel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CopilotModel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopilotModel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CopilotModelMultiError, or
// nil if none found.
func (m *CopilotModel) ValidateAll() error {
	return m.validate(true)
}

func (m *CopilotModel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for IsEnable

	// no validation rules for IsFree

	// no validation rules for CreditCost

	if len(errors) > 0 {
		return CopilotModelMultiError(errors)
	}

	return nil
}

// CopilotModelMultiError is an error wrapping multiple validation errors
// returned by CopilotModel.ValidateAll() if the designated constraints aren't met.
type CopilotModelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopilotModelMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopilotModelMultiError) AllErrors() []error { return m }

// CopilotModelValidationError is the validation error returned by
// CopilotModel.Validate if the designated constraints aren't met.
type CopilotModelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopilotModelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopilotModelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopilotModelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopilotModelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopilotModelValidationError) ErrorName() string { return "CopilotModelValidationError" }

// Error satisfies the builtin error interface
func (e CopilotModelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopilotModel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopilotModelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopilotModelValidationError{}

// Validate checks the field values on CopilotPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CopilotPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopilotPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CopilotPermissionMultiError, or nil if none found.
func (m *CopilotPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *CopilotPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsEnable

	for idx, item := range m.GetModels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CopilotPermissionValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CopilotPermissionValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CopilotPermissionValidationError{
					field:  fmt.Sprintf("Models[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CopilotPermissionMultiError(errors)
	}

	return nil
}

// CopilotPermissionMultiError is an error wrapping multiple validation errors
// returned by CopilotPermission.ValidateAll() if the designated constraints
// aren't met.
type CopilotPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopilotPermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopilotPermissionMultiError) AllErrors() []error { return m }

// CopilotPermissionValidationError is the validation error returned by
// CopilotPermission.Validate if the designated constraints aren't met.
type CopilotPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopilotPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopilotPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopilotPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopilotPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopilotPermissionValidationError) ErrorName() string {
	return "CopilotPermissionValidationError"
}

// Error satisfies the builtin error interface
func (e CopilotPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopilotPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopilotPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopilotPermissionValidationError{}

// Validate checks the field values on AIPermission with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AIPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AIPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AIPermissionMultiError, or
// nil if none found.
func (m *AIPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *AIPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCopilot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AIPermissionValidationError{
					field:  "Copilot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AIPermissionValidationError{
					field:  "Copilot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopilot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AIPermissionValidationError{
				field:  "Copilot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AIPermissionMultiError(errors)
	}

	return nil
}

// AIPermissionMultiError is an error wrapping multiple validation errors
// returned by AIPermission.ValidateAll() if the designated constraints aren't met.
type AIPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AIPermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AIPermissionMultiError) AllErrors() []error { return m }

// AIPermissionValidationError is the validation error returned by
// AIPermission.Validate if the designated constraints aren't met.
type AIPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AIPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AIPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AIPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AIPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AIPermissionValidationError) ErrorName() string { return "AIPermissionValidationError" }

// Error satisfies the builtin error interface
func (e AIPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAIPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AIPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AIPermissionValidationError{}

// Validate checks the field values on TranslatePermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TranslatePermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TranslatePermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TranslatePermissionMultiError, or nil if none found.
func (m *TranslatePermission) ValidateAll() error {
	return m.validate(true)
}

func (m *TranslatePermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsOcr

	// no validation rules for OcrCreditCost

	// no validation rules for IsWordTranslate

	// no validation rules for WordTranslateCreditCost

	// no validation rules for IsFullTextTranslate

	// no validation rules for FullTextTranslateCreditCost

	// no validation rules for FullTextTranslateCreditCostOriginal

	// no validation rules for FullTextTranslateMaxPageCount

	// no validation rules for IsAiTranslation

	// no validation rules for AiTranslationCreditCost

	if len(errors) > 0 {
		return TranslatePermissionMultiError(errors)
	}

	return nil
}

// TranslatePermissionMultiError is an error wrapping multiple validation
// errors returned by TranslatePermission.ValidateAll() if the designated
// constraints aren't met.
type TranslatePermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TranslatePermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TranslatePermissionMultiError) AllErrors() []error { return m }

// TranslatePermissionValidationError is the validation error returned by
// TranslatePermission.Validate if the designated constraints aren't met.
type TranslatePermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TranslatePermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TranslatePermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TranslatePermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TranslatePermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TranslatePermissionValidationError) ErrorName() string {
	return "TranslatePermissionValidationError"
}

// Error satisfies the builtin error interface
func (e TranslatePermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTranslatePermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TranslatePermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TranslatePermissionValidationError{}

// Validate checks the field values on UserBasePermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserBasePermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBasePermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserBasePermissionMultiError, or nil if none found.
func (m *UserBasePermission) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBasePermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsEnableAddOnCredit

	// no validation rules for IsEnableSubAddOnCredit

	if len(errors) > 0 {
		return UserBasePermissionMultiError(errors)
	}

	return nil
}

// UserBasePermissionMultiError is an error wrapping multiple validation errors
// returned by UserBasePermission.ValidateAll() if the designated constraints
// aren't met.
type UserBasePermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBasePermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBasePermissionMultiError) AllErrors() []error { return m }

// UserBasePermissionValidationError is the validation error returned by
// UserBasePermission.Validate if the designated constraints aren't met.
type UserBasePermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBasePermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBasePermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBasePermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBasePermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBasePermissionValidationError) ErrorName() string {
	return "UserBasePermissionValidationError"
}

// Error satisfies the builtin error interface
func (e UserBasePermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBasePermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBasePermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBasePermissionValidationError{}

// Validate checks the field values on UserDocsPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserDocsPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserDocsPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserDocsPermissionMultiError, or nil if none found.
func (m *UserDocsPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *UserDocsPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxStorageCapacity

	// no validation rules for DocUploadMaxSize

	// no validation rules for DocUploadMaxPageCount

	// no validation rules for UseStorageCapacity

	if len(errors) > 0 {
		return UserDocsPermissionMultiError(errors)
	}

	return nil
}

// UserDocsPermissionMultiError is an error wrapping multiple validation errors
// returned by UserDocsPermission.ValidateAll() if the designated constraints
// aren't met.
type UserDocsPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserDocsPermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserDocsPermissionMultiError) AllErrors() []error { return m }

// UserDocsPermissionValidationError is the validation error returned by
// UserDocsPermission.Validate if the designated constraints aren't met.
type UserDocsPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserDocsPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserDocsPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserDocsPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserDocsPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserDocsPermissionValidationError) ErrorName() string {
	return "UserDocsPermissionValidationError"
}

// Error satisfies the builtin error interface
func (e UserDocsPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserDocsPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserDocsPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserDocsPermissionValidationError{}

// Validate checks the field values on UserNotePermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserNotePermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserNotePermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserNotePermissionMultiError, or nil if none found.
func (m *UserNotePermission) ValidateAll() error {
	return m.validate(true)
}

func (m *UserNotePermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsNoteSummary

	// no validation rules for IsNoteWord

	// no validation rules for IsNoteExtract

	// no validation rules for IsNoteManage

	// no validation rules for IsNotePdfDownload

	if len(errors) > 0 {
		return UserNotePermissionMultiError(errors)
	}

	return nil
}

// UserNotePermissionMultiError is an error wrapping multiple validation errors
// returned by UserNotePermission.ValidateAll() if the designated constraints
// aren't met.
type UserNotePermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserNotePermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserNotePermissionMultiError) AllErrors() []error { return m }

// UserNotePermissionValidationError is the validation error returned by
// UserNotePermission.Validate if the designated constraints aren't met.
type UserNotePermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserNotePermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserNotePermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserNotePermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserNotePermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserNotePermissionValidationError) ErrorName() string {
	return "UserNotePermissionValidationError"
}

// Error satisfies the builtin error interface
func (e UserNotePermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserNotePermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserNotePermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserNotePermissionValidationError{}

// Validate checks the field values on UserAIPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserAIPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserAIPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserAIPermissionMultiError, or nil if none found.
func (m *UserAIPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *UserAIPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCopilot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserAIPermissionValidationError{
					field:  "Copilot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserAIPermissionValidationError{
					field:  "Copilot",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCopilot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserAIPermissionValidationError{
				field:  "Copilot",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserAIPermissionMultiError(errors)
	}

	return nil
}

// UserAIPermissionMultiError is an error wrapping multiple validation errors
// returned by UserAIPermission.ValidateAll() if the designated constraints
// aren't met.
type UserAIPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserAIPermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserAIPermissionMultiError) AllErrors() []error { return m }

// UserAIPermissionValidationError is the validation error returned by
// UserAIPermission.Validate if the designated constraints aren't met.
type UserAIPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserAIPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserAIPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserAIPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserAIPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserAIPermissionValidationError) ErrorName() string { return "UserAIPermissionValidationError" }

// Error satisfies the builtin error interface
func (e UserAIPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserAIPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserAIPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserAIPermissionValidationError{}

// Validate checks the field values on UserTranslatePermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserTranslatePermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserTranslatePermission with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserTranslatePermissionMultiError, or nil if none found.
func (m *UserTranslatePermission) ValidateAll() error {
	return m.validate(true)
}

func (m *UserTranslatePermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsOcr

	// no validation rules for OcrCreditCost

	// no validation rules for IsWordTranslate

	// no validation rules for WordTranslateCreditCost

	// no validation rules for IsFullTextTranslate

	// no validation rules for FullTextTranslateCreditCost

	// no validation rules for FullTextTranslateMaxPageCount

	// no validation rules for IsAiTranslation

	// no validation rules for AiTranslationCreditCost

	if len(errors) > 0 {
		return UserTranslatePermissionMultiError(errors)
	}

	return nil
}

// UserTranslatePermissionMultiError is an error wrapping multiple validation
// errors returned by UserTranslatePermission.ValidateAll() if the designated
// constraints aren't met.
type UserTranslatePermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserTranslatePermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserTranslatePermissionMultiError) AllErrors() []error { return m }

// UserTranslatePermissionValidationError is the validation error returned by
// UserTranslatePermission.Validate if the designated constraints aren't met.
type UserTranslatePermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserTranslatePermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserTranslatePermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserTranslatePermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserTranslatePermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserTranslatePermissionValidationError) ErrorName() string {
	return "UserTranslatePermissionValidationError"
}

// Error satisfies the builtin error interface
func (e UserTranslatePermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserTranslatePermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserTranslatePermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserTranslatePermissionValidationError{}

// Validate checks the field values on MembershipSubPlanInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MembershipSubPlanInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MembershipSubPlanInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MembershipSubPlanInfoMultiError, or nil if none found.
func (m *MembershipSubPlanInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MembershipSubPlanInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for IsFree

	if all {
		switch v := interface{}(m.GetBase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Base",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Base",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MembershipSubPlanInfoValidationError{
				field:  "Base",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDocs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Docs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Docs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MembershipSubPlanInfoValidationError{
				field:  "Docs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MembershipSubPlanInfoValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Ai",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Ai",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MembershipSubPlanInfoValidationError{
				field:  "Ai",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTranslate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Translate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MembershipSubPlanInfoValidationError{
					field:  "Translate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTranslate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MembershipSubPlanInfoValidationError{
				field:  "Translate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MembershipSubPlanInfoMultiError(errors)
	}

	return nil
}

// MembershipSubPlanInfoMultiError is an error wrapping multiple validation
// errors returned by MembershipSubPlanInfo.ValidateAll() if the designated
// constraints aren't met.
type MembershipSubPlanInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MembershipSubPlanInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MembershipSubPlanInfoMultiError) AllErrors() []error { return m }

// MembershipSubPlanInfoValidationError is the validation error returned by
// MembershipSubPlanInfo.Validate if the designated constraints aren't met.
type MembershipSubPlanInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MembershipSubPlanInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MembershipSubPlanInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MembershipSubPlanInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MembershipSubPlanInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MembershipSubPlanInfoValidationError) ErrorName() string {
	return "MembershipSubPlanInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MembershipSubPlanInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMembershipSubPlanInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MembershipSubPlanInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MembershipSubPlanInfoValidationError{}

// Validate checks the field values on UserMembershipBaseInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserMembershipBaseInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserMembershipBaseInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserMembershipBaseInfoMultiError, or nil if none found.
func (m *UserMembershipBaseInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserMembershipBaseInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Type

	// no validation rules for TypeName

	// no validation rules for Credit

	// no validation rules for AddOnCredit

	// no validation rules for IsExpired

	// no validation rules for ExpiredDay

	// no validation rules for StartAt

	// no validation rules for EndAt

	if len(errors) > 0 {
		return UserMembershipBaseInfoMultiError(errors)
	}

	return nil
}

// UserMembershipBaseInfoMultiError is an error wrapping multiple validation
// errors returned by UserMembershipBaseInfo.ValidateAll() if the designated
// constraints aren't met.
type UserMembershipBaseInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMembershipBaseInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMembershipBaseInfoMultiError) AllErrors() []error { return m }

// UserMembershipBaseInfoValidationError is the validation error returned by
// UserMembershipBaseInfo.Validate if the designated constraints aren't met.
type UserMembershipBaseInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserMembershipBaseInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserMembershipBaseInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserMembershipBaseInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserMembershipBaseInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserMembershipBaseInfoValidationError) ErrorName() string {
	return "UserMembershipBaseInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserMembershipBaseInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserMembershipBaseInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserMembershipBaseInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserMembershipBaseInfoValidationError{}

// Validate checks the field values on UserMembershipInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserMembershipInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserMembershipInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserMembershipInfoMultiError, or nil if none found.
func (m *UserMembershipInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserMembershipInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBaseInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserMembershipInfoValidationError{
					field:  "BaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserMembershipInfoValidationError{
					field:  "BaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserMembershipInfoValidationError{
				field:  "BaseInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPermission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserMembershipInfoValidationError{
					field:  "Permission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserMembershipInfoValidationError{
					field:  "Permission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPermission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserMembershipInfoValidationError{
				field:  "Permission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserMembershipInfoMultiError(errors)
	}

	return nil
}

// UserMembershipInfoMultiError is an error wrapping multiple validation errors
// returned by UserMembershipInfo.ValidateAll() if the designated constraints
// aren't met.
type UserMembershipInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMembershipInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMembershipInfoMultiError) AllErrors() []error { return m }

// UserMembershipInfoValidationError is the validation error returned by
// UserMembershipInfo.Validate if the designated constraints aren't met.
type UserMembershipInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserMembershipInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserMembershipInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserMembershipInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserMembershipInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserMembershipInfoValidationError) ErrorName() string {
	return "UserMembershipInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserMembershipInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserMembershipInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserMembershipInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserMembershipInfoValidationError{}

// Validate checks the field values on UserPermission with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserPermission with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserPermissionMultiError,
// or nil if none found.
func (m *UserPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *UserPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Base",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Base",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserPermissionValidationError{
				field:  "Base",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDocs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Docs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Docs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserPermissionValidationError{
				field:  "Docs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserPermissionValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Ai",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Ai",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserPermissionValidationError{
				field:  "Ai",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTranslate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Translate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserPermissionValidationError{
					field:  "Translate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTranslate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserPermissionValidationError{
				field:  "Translate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserPermissionMultiError(errors)
	}

	return nil
}

// UserPermissionMultiError is an error wrapping multiple validation errors
// returned by UserPermission.ValidateAll() if the designated constraints
// aren't met.
type UserPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserPermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserPermissionMultiError) AllErrors() []error { return m }

// UserPermissionValidationError is the validation error returned by
// UserPermission.Validate if the designated constraints aren't met.
type UserPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserPermissionValidationError) ErrorName() string { return "UserPermissionValidationError" }

// Error satisfies the builtin error interface
func (e UserPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserPermissionValidationError{}

// Validate checks the field values on GetSubPlanInfosRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubPlanInfosRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubPlanInfosRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubPlanInfosRequestMultiError, or nil if none found.
func (m *GetSubPlanInfosRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubPlanInfosRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetSubPlanInfosRequestMultiError(errors)
	}

	return nil
}

// GetSubPlanInfosRequestMultiError is an error wrapping multiple validation
// errors returned by GetSubPlanInfosRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSubPlanInfosRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubPlanInfosRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubPlanInfosRequestMultiError) AllErrors() []error { return m }

// GetSubPlanInfosRequestValidationError is the validation error returned by
// GetSubPlanInfosRequest.Validate if the designated constraints aren't met.
type GetSubPlanInfosRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubPlanInfosRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubPlanInfosRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubPlanInfosRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubPlanInfosRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubPlanInfosRequestValidationError) ErrorName() string {
	return "GetSubPlanInfosRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubPlanInfosRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubPlanInfosRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubPlanInfosRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubPlanInfosRequestValidationError{}

// Validate checks the field values on GetSubPlanInfosResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubPlanInfosResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubPlanInfosResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubPlanInfosResponseMultiError, or nil if none found.
func (m *GetSubPlanInfosResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubPlanInfosResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSubPlanInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSubPlanInfosResponseValidationError{
						field:  fmt.Sprintf("SubPlanInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSubPlanInfosResponseValidationError{
						field:  fmt.Sprintf("SubPlanInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSubPlanInfosResponseValidationError{
					field:  fmt.Sprintf("SubPlanInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSubPlanInfosResponseMultiError(errors)
	}

	return nil
}

// GetSubPlanInfosResponseMultiError is an error wrapping multiple validation
// errors returned by GetSubPlanInfosResponse.ValidateAll() if the designated
// constraints aren't met.
type GetSubPlanInfosResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubPlanInfosResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubPlanInfosResponseMultiError) AllErrors() []error { return m }

// GetSubPlanInfosResponseValidationError is the validation error returned by
// GetSubPlanInfosResponse.Validate if the designated constraints aren't met.
type GetSubPlanInfosResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubPlanInfosResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubPlanInfosResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubPlanInfosResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubPlanInfosResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubPlanInfosResponseValidationError) ErrorName() string {
	return "GetSubPlanInfosResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubPlanInfosResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubPlanInfosResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubPlanInfosResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubPlanInfosResponseValidationError{}

// Validate checks the field values on GetBaseInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBaseInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBaseInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBaseInfoRequestMultiError, or nil if none found.
func (m *GetBaseInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBaseInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetBaseInfoRequestMultiError(errors)
	}

	return nil
}

// GetBaseInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetBaseInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBaseInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBaseInfoRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBaseInfoRequestMultiError) AllErrors() []error { return m }

// GetBaseInfoRequestValidationError is the validation error returned by
// GetBaseInfoRequest.Validate if the designated constraints aren't met.
type GetBaseInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBaseInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBaseInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBaseInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBaseInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBaseInfoRequestValidationError) ErrorName() string {
	return "GetBaseInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBaseInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBaseInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBaseInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBaseInfoRequestValidationError{}

// Validate checks the field values on GetBaseInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBaseInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBaseInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBaseInfoResponseMultiError, or nil if none found.
func (m *GetBaseInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBaseInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBaseInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBaseInfoResponseValidationError{
					field:  "BaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBaseInfoResponseValidationError{
					field:  "BaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBaseInfoResponseValidationError{
				field:  "BaseInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBaseInfoResponseMultiError(errors)
	}

	return nil
}

// GetBaseInfoResponseMultiError is an error wrapping multiple validation
// errors returned by GetBaseInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBaseInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBaseInfoResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBaseInfoResponseMultiError) AllErrors() []error { return m }

// GetBaseInfoResponseValidationError is the validation error returned by
// GetBaseInfoResponse.Validate if the designated constraints aren't met.
type GetBaseInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBaseInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBaseInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBaseInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBaseInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBaseInfoResponseValidationError) ErrorName() string {
	return "GetBaseInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBaseInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBaseInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBaseInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBaseInfoResponseValidationError{}

// Validate checks the field values on GetInfoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInfoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetInfoRequestMultiError,
// or nil if none found.
func (m *GetInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetInfoRequestMultiError(errors)
	}

	return nil
}

// GetInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInfoRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInfoRequestMultiError) AllErrors() []error { return m }

// GetInfoRequestValidationError is the validation error returned by
// GetInfoRequest.Validate if the designated constraints aren't met.
type GetInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInfoRequestValidationError) ErrorName() string { return "GetInfoRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInfoRequestValidationError{}

// Validate checks the field values on GetInfoResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInfoResponseMultiError, or nil if none found.
func (m *GetInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInfoResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInfoResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInfoResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInfoResponseMultiError(errors)
	}

	return nil
}

// GetInfoResponseMultiError is an error wrapping multiple validation errors
// returned by GetInfoResponse.ValidateAll() if the designated constraints
// aren't met.
type GetInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInfoResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInfoResponseMultiError) AllErrors() []error { return m }

// GetInfoResponseValidationError is the validation error returned by
// GetInfoResponse.Validate if the designated constraints aren't met.
type GetInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInfoResponseValidationError) ErrorName() string { return "GetInfoResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInfoResponseValidationError{}

// Validate checks the field values on GetMembershipProfileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMembershipProfileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMembershipProfileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMembershipProfileRequestMultiError, or nil if none found.
func (m *GetMembershipProfileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMembershipProfileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetMembershipProfileRequestMultiError(errors)
	}

	return nil
}

// GetMembershipProfileRequestMultiError is an error wrapping multiple
// validation errors returned by GetMembershipProfileRequest.ValidateAll() if
// the designated constraints aren't met.
type GetMembershipProfileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMembershipProfileRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMembershipProfileRequestMultiError) AllErrors() []error { return m }

// GetMembershipProfileRequestValidationError is the validation error returned
// by GetMembershipProfileRequest.Validate if the designated constraints
// aren't met.
type GetMembershipProfileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMembershipProfileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMembershipProfileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMembershipProfileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMembershipProfileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMembershipProfileRequestValidationError) ErrorName() string {
	return "GetMembershipProfileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMembershipProfileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMembershipProfileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMembershipProfileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMembershipProfileRequestValidationError{}

// Validate checks the field values on GetMembershipProfileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMembershipProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMembershipProfileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMembershipProfileResponseMultiError, or nil if none found.
func (m *GetMembershipProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMembershipProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMembershipProfileResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMembershipProfileResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMembershipProfileResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMembershipProfileResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMembershipProfileResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMembershipProfileResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMembershipProfileResponseMultiError(errors)
	}

	return nil
}

// GetMembershipProfileResponseMultiError is an error wrapping multiple
// validation errors returned by GetMembershipProfileResponse.ValidateAll() if
// the designated constraints aren't met.
type GetMembershipProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMembershipProfileResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMembershipProfileResponseMultiError) AllErrors() []error { return m }

// GetMembershipProfileResponseValidationError is the validation error returned
// by GetMembershipProfileResponse.Validate if the designated constraints
// aren't met.
type GetMembershipProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMembershipProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMembershipProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMembershipProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMembershipProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMembershipProfileResponseValidationError) ErrorName() string {
	return "GetMembershipProfileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMembershipProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMembershipProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMembershipProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMembershipProfileResponseValidationError{}

// Validate checks the field values on GetLoginPageConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLoginPageConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLoginPageConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLoginPageConfigRequestMultiError, or nil if none found.
func (m *GetLoginPageConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLoginPageConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetLoginPageConfigRequestMultiError(errors)
	}

	return nil
}

// GetLoginPageConfigRequestMultiError is an error wrapping multiple validation
// errors returned by GetLoginPageConfigRequest.ValidateAll() if the
// designated constraints aren't met.
type GetLoginPageConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLoginPageConfigRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLoginPageConfigRequestMultiError) AllErrors() []error { return m }

// GetLoginPageConfigRequestValidationError is the validation error returned by
// GetLoginPageConfigRequest.Validate if the designated constraints aren't met.
type GetLoginPageConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLoginPageConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLoginPageConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLoginPageConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLoginPageConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLoginPageConfigRequestValidationError) ErrorName() string {
	return "GetLoginPageConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLoginPageConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLoginPageConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLoginPageConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLoginPageConfigRequestValidationError{}

// Validate checks the field values on GetLoginPageConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLoginPageConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLoginPageConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLoginPageConfigResponseMultiError, or nil if none found.
func (m *GetLoginPageConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLoginPageConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsGoogleLoginEnabled

	// no validation rules for IsUsernamePasswordLoginEnabled

	// no validation rules for IsRegisterEnabled

	// no validation rules for IsForgetPasswordEnabled

	if len(errors) > 0 {
		return GetLoginPageConfigResponseMultiError(errors)
	}

	return nil
}

// GetLoginPageConfigResponseMultiError is an error wrapping multiple
// validation errors returned by GetLoginPageConfigResponse.ValidateAll() if
// the designated constraints aren't met.
type GetLoginPageConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLoginPageConfigResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLoginPageConfigResponseMultiError) AllErrors() []error { return m }

// GetLoginPageConfigResponseValidationError is the validation error returned
// by GetLoginPageConfigResponse.Validate if the designated constraints aren't met.
type GetLoginPageConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLoginPageConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLoginPageConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLoginPageConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLoginPageConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLoginPageConfigResponseValidationError) ErrorName() string {
	return "GetLoginPageConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLoginPageConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLoginPageConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLoginPageConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLoginPageConfigResponseValidationError{}

// Validate checks the field values on GetUserCreditRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserCreditRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserCreditRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserCreditRequestMultiError, or nil if none found.
func (m *GetUserCreditRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserCreditRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetUserCreditRequestMultiError(errors)
	}

	return nil
}

// GetUserCreditRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserCreditRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserCreditRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserCreditRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserCreditRequestMultiError) AllErrors() []error { return m }

// GetUserCreditRequestValidationError is the validation error returned by
// GetUserCreditRequest.Validate if the designated constraints aren't met.
type GetUserCreditRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserCreditRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserCreditRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserCreditRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserCreditRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserCreditRequestValidationError) ErrorName() string {
	return "GetUserCreditRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserCreditRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserCreditRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserCreditRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserCreditRequestValidationError{}

// Validate checks the field values on GetUserCreditResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserCreditResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserCreditResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserCreditResponseMultiError, or nil if none found.
func (m *GetUserCreditResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserCreditResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Credit

	// no validation rules for AddOnCredit

	if len(errors) > 0 {
		return GetUserCreditResponseMultiError(errors)
	}

	return nil
}

// GetUserCreditResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserCreditResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserCreditResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserCreditResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserCreditResponseMultiError) AllErrors() []error { return m }

// GetUserCreditResponseValidationError is the validation error returned by
// GetUserCreditResponse.Validate if the designated constraints aren't met.
type GetUserCreditResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserCreditResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserCreditResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserCreditResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserCreditResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserCreditResponseValidationError) ErrorName() string {
	return "GetUserCreditResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserCreditResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserCreditResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserCreditResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserCreditResponseValidationError{}
