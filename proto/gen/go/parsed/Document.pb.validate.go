// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: definitions/parsed/Document.proto

package parsed

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on BBox with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *BBox) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BBox with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BBoxMultiError, or nil if none found.
func (m *BBox) ValidateAll() error {
	return m.validate(true)
}

func (m *BBox) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X0

	// no validation rules for Y0

	// no validation rules for X1

	// no validation rules for Y1

	// no validation rules for OriginHeight

	// no validation rules for OriginWidth

	// no validation rules for PageNumber

	if len(errors) > 0 {
		return BBoxMultiError(errors)
	}

	return nil
}

// BBoxMultiError is an error wrapping multiple validation errors returned by
// BBox.ValidateAll() if the designated constraints aren't met.
type BBoxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BBoxMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BBoxMultiError) AllErrors() []error { return m }

// BBoxValidationError is the validation error returned by BBox.Validate if the
// designated constraints aren't met.
type BBoxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BBoxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BBoxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BBoxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BBoxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BBoxValidationError) ErrorName() string { return "BBoxValidationError" }

// Error satisfies the builtin error interface
func (e BBoxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBBox.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BBoxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BBoxValidationError{}

// Validate checks the field values on PageInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PageInfoMultiError, or nil
// if none found.
func (m *PageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNumber

	// no validation rules for Width

	// no validation rules for Height

	if len(errors) > 0 {
		return PageInfoMultiError(errors)
	}

	return nil
}

// PageInfoMultiError is an error wrapping multiple validation errors returned
// by PageInfo.ValidateAll() if the designated constraints aren't met.
type PageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageInfoMultiError) AllErrors() []error { return m }

// PageInfoValidationError is the validation error returned by
// PageInfo.Validate if the designated constraints aren't met.
type PageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageInfoValidationError) ErrorName() string { return "PageInfoValidationError" }

// Error satisfies the builtin error interface
func (e PageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageInfoValidationError{}

// Validate checks the field values on Author with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Author) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Author with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AuthorMultiError, or nil if none found.
func (m *Author) ValidateAll() error {
	return m.validate(true)
}

func (m *Author) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FullName

	// no validation rules for GivenName

	// no validation rules for Surname

	// no validation rules for Email

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthorValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthorValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthorValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthorMultiError(errors)
	}

	return nil
}

// AuthorMultiError is an error wrapping multiple validation errors returned by
// Author.ValidateAll() if the designated constraints aren't met.
type AuthorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorMultiError) AllErrors() []error { return m }

// AuthorValidationError is the validation error returned by Author.Validate if
// the designated constraints aren't met.
type AuthorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorValidationError) ErrorName() string { return "AuthorValidationError" }

// Error satisfies the builtin error interface
func (e AuthorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorValidationError{}

// Validate checks the field values on CatalogueItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CatalogueItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CatalogueItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CatalogueItemMultiError, or
// nil if none found.
func (m *CatalogueItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CatalogueItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for FormattedTitle

	for idx, item := range m.GetChild() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CatalogueItemValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CatalogueItemValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CatalogueItemValidationError{
					field:  fmt.Sprintf("Child[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CatalogueItemValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CatalogueItemValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CatalogueItemValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Level

	// no validation rules for TitleOrder

	// no validation rules for Order

	if len(errors) > 0 {
		return CatalogueItemMultiError(errors)
	}

	return nil
}

// CatalogueItemMultiError is an error wrapping multiple validation errors
// returned by CatalogueItem.ValidateAll() if the designated constraints
// aren't met.
type CatalogueItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CatalogueItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CatalogueItemMultiError) AllErrors() []error { return m }

// CatalogueItemValidationError is the validation error returned by
// CatalogueItem.Validate if the designated constraints aren't met.
type CatalogueItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CatalogueItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CatalogueItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CatalogueItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CatalogueItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CatalogueItemValidationError) ErrorName() string { return "CatalogueItemValidationError" }

// Error satisfies the builtin error interface
func (e CatalogueItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCatalogueItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CatalogueItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CatalogueItemValidationError{}

// Validate checks the field values on Reference with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Reference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Reference with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReferenceMultiError, or nil
// if none found.
func (m *Reference) ValidateAll() error {
	return m.validate(true)
}

func (m *Reference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefIdx

	// no validation rules for PublishDate

	// no validation rules for SearchKey

	for idx, item := range m.GetAuthors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceValidationError{
						field:  fmt.Sprintf("Authors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceValidationError{
						field:  fmt.Sprintf("Authors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceValidationError{
					field:  fmt.Sprintf("Authors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ContentText

	// no validation rules for ArxivId

	if len(errors) > 0 {
		return ReferenceMultiError(errors)
	}

	return nil
}

// ReferenceMultiError is an error wrapping multiple validation errors returned
// by Reference.ValidateAll() if the designated constraints aren't met.
type ReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceMultiError) AllErrors() []error { return m }

// ReferenceValidationError is the validation error returned by
// Reference.Validate if the designated constraints aren't met.
type ReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceValidationError) ErrorName() string { return "ReferenceValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceValidationError{}

// Validate checks the field values on RefMarker with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefMarker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefMarker with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefMarkerMultiError, or nil
// if none found.
func (m *RefMarker) ValidateAll() error {
	return m.validate(true)
}

func (m *RefMarker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefIdx

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefMarkerValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefMarkerValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefMarkerValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefContent

	if len(errors) > 0 {
		return RefMarkerMultiError(errors)
	}

	return nil
}

// RefMarkerMultiError is an error wrapping multiple validation errors returned
// by RefMarker.ValidateAll() if the designated constraints aren't met.
type RefMarkerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefMarkerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefMarkerMultiError) AllErrors() []error { return m }

// RefMarkerValidationError is the validation error returned by
// RefMarker.Validate if the designated constraints aren't met.
type RefMarkerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefMarkerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefMarkerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefMarkerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefMarkerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefMarkerValidationError) ErrorName() string { return "RefMarkerValidationError" }

// Error satisfies the builtin error interface
func (e RefMarkerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefMarker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefMarkerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefMarkerValidationError{}

// Validate checks the field values on FigureTable with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FigureTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FigureTable with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FigureTableMultiError, or
// nil if none found.
func (m *FigureTable) ValidateAll() error {
	return m.validate(true)
}

func (m *FigureTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FigureTableValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FigureTableValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FigureTableValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefContent

	if all {
		switch v := interface{}(m.GetRefBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FigureTableValidationError{
					field:  "RefBbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FigureTableValidationError{
					field:  "RefBbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FigureTableValidationError{
				field:  "RefBbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefIdx

	// no validation rules for Type

	// no validation rules for Id

	// no validation rules for SectionId

	// no validation rules for SectionTitle

	if len(errors) > 0 {
		return FigureTableMultiError(errors)
	}

	return nil
}

// FigureTableMultiError is an error wrapping multiple validation errors
// returned by FigureTable.ValidateAll() if the designated constraints aren't met.
type FigureTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FigureTableMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FigureTableMultiError) AllErrors() []error { return m }

// FigureTableValidationError is the validation error returned by
// FigureTable.Validate if the designated constraints aren't met.
type FigureTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FigureTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FigureTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FigureTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FigureTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FigureTableValidationError) ErrorName() string { return "FigureTableValidationError" }

// Error satisfies the builtin error interface
func (e FigureTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFigureTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FigureTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FigureTableValidationError{}

// Validate checks the field values on ContentTitle with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContentTitle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContentTitle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContentTitleMultiError, or
// nil if none found.
func (m *ContentTitle) ValidateAll() error {
	return m.validate(true)
}

func (m *ContentTitle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Text

	// no validation rules for Level

	// no validation rules for PageNumber

	if len(errors) > 0 {
		return ContentTitleMultiError(errors)
	}

	return nil
}

// ContentTitleMultiError is an error wrapping multiple validation errors
// returned by ContentTitle.ValidateAll() if the designated constraints aren't met.
type ContentTitleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContentTitleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContentTitleMultiError) AllErrors() []error { return m }

// ContentTitleValidationError is the validation error returned by
// ContentTitle.Validate if the designated constraints aren't met.
type ContentTitleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContentTitleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContentTitleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContentTitleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContentTitleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContentTitleValidationError) ErrorName() string { return "ContentTitleValidationError" }

// Error satisfies the builtin error interface
func (e ContentTitleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContentTitle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContentTitleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContentTitleValidationError{}

// Validate checks the field values on Formula with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Formula) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Formula with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FormulaMultiError, or nil if none found.
func (m *Formula) ValidateAll() error {
	return m.validate(true)
}

func (m *Formula) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FormulaValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FormulaValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FormulaValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefContent

	// no validation rules for RefIdx

	// no validation rules for Id

	// no validation rules for SectionId

	// no validation rules for SectionTitle

	if len(errors) > 0 {
		return FormulaMultiError(errors)
	}

	return nil
}

// FormulaMultiError is an error wrapping multiple validation errors returned
// by Formula.ValidateAll() if the designated constraints aren't met.
type FormulaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FormulaMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FormulaMultiError) AllErrors() []error { return m }

// FormulaValidationError is the validation error returned by Formula.Validate
// if the designated constraints aren't met.
type FormulaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FormulaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FormulaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FormulaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FormulaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FormulaValidationError) ErrorName() string { return "FormulaValidationError" }

// Error satisfies the builtin error interface
func (e FormulaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFormula.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FormulaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FormulaValidationError{}

// Validate checks the field values on Doi with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Doi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Doi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DoiMultiError, or nil if none found.
func (m *Doi) ValidateAll() error {
	return m.validate(true)
}

func (m *Doi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Doi

	// no validation rules for Type

	if len(errors) > 0 {
		return DoiMultiError(errors)
	}

	return nil
}

// DoiMultiError is an error wrapping multiple validation errors returned by
// Doi.ValidateAll() if the designated constraints aren't met.
type DoiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DoiMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DoiMultiError) AllErrors() []error { return m }

// DoiValidationError is the validation error returned by Doi.Validate if the
// designated constraints aren't met.
type DoiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DoiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DoiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DoiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DoiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DoiValidationError) ErrorName() string { return "DoiValidationError" }

// Error satisfies the builtin error interface
func (e DoiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDoi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DoiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DoiValidationError{}

// Validate checks the field values on RefInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RefInfoMultiError, or nil if none found.
func (m *RefInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RefInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Text

	// no validation rules for Target

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefInfoValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefInfoMultiError(errors)
	}

	return nil
}

// RefInfoMultiError is an error wrapping multiple validation errors returned
// by RefInfo.ValidateAll() if the designated constraints aren't met.
type RefInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefInfoMultiError) AllErrors() []error { return m }

// RefInfoValidationError is the validation error returned by RefInfo.Validate
// if the designated constraints aren't met.
type RefInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefInfoValidationError) ErrorName() string { return "RefInfoValidationError" }

// Error satisfies the builtin error interface
func (e RefInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefInfoValidationError{}

// Validate checks the field values on Paragraph with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Paragraph) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Paragraph with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParagraphMultiError, or nil
// if none found.
func (m *Paragraph) ValidateAll() error {
	return m.validate(true)
}

func (m *Paragraph) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for SectionTitle

	// no validation rules for SectionId

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParagraphValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParagraphValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParagraphValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetText()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParagraphValidationError{
					field:  "Text",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParagraphValidationError{
					field:  "Text",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetText()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParagraphValidationError{
				field:  "Text",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFormula()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParagraphValidationError{
					field:  "Formula",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParagraphValidationError{
					field:  "Formula",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFormula()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParagraphValidationError{
				field:  "Formula",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFigureTable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParagraphValidationError{
					field:  "FigureTable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParagraphValidationError{
					field:  "FigureTable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFigureTable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParagraphValidationError{
				field:  "FigureTable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Order

	if len(errors) > 0 {
		return ParagraphMultiError(errors)
	}

	return nil
}

// ParagraphMultiError is an error wrapping multiple validation errors returned
// by Paragraph.ValidateAll() if the designated constraints aren't met.
type ParagraphMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParagraphMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParagraphMultiError) AllErrors() []error { return m }

// ParagraphValidationError is the validation error returned by
// Paragraph.Validate if the designated constraints aren't met.
type ParagraphValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParagraphValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParagraphValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParagraphValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParagraphValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParagraphValidationError) ErrorName() string { return "ParagraphValidationError" }

// Error satisfies the builtin error interface
func (e ParagraphValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParagraph.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParagraphValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParagraphValidationError{}

// Validate checks the field values on Text with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Text) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Text with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TextMultiError, or nil if none found.
func (m *Text) ValidateAll() error {
	return m.validate(true)
}

func (m *Text) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TextValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TextValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TextValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Text

	for idx, item := range m.GetSentences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TextValidationError{
						field:  fmt.Sprintf("Sentences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TextValidationError{
						field:  fmt.Sprintf("Sentences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TextValidationError{
					field:  fmt.Sprintf("Sentences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TextMultiError(errors)
	}

	return nil
}

// TextMultiError is an error wrapping multiple validation errors returned by
// Text.ValidateAll() if the designated constraints aren't met.
type TextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TextMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TextMultiError) AllErrors() []error { return m }

// TextValidationError is the validation error returned by Text.Validate if the
// designated constraints aren't met.
type TextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TextValidationError) ErrorName() string { return "TextValidationError" }

// Error satisfies the builtin error interface
func (e TextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sText.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TextValidationError{}

// Validate checks the field values on Abstract with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Abstract) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Abstract with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AbstractMultiError, or nil
// if none found.
func (m *Abstract) ValidateAll() error {
	return m.validate(true)
}

func (m *Abstract) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AbstractValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AbstractValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AbstractValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Text

	if len(errors) > 0 {
		return AbstractMultiError(errors)
	}

	return nil
}

// AbstractMultiError is an error wrapping multiple validation errors returned
// by Abstract.ValidateAll() if the designated constraints aren't met.
type AbstractMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AbstractMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AbstractMultiError) AllErrors() []error { return m }

// AbstractValidationError is the validation error returned by
// Abstract.Validate if the designated constraints aren't met.
type AbstractValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AbstractValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AbstractValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AbstractValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AbstractValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AbstractValidationError) ErrorName() string { return "AbstractValidationError" }

// Error satisfies the builtin error interface
func (e AbstractValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAbstract.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AbstractValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AbstractValidationError{}

// Validate checks the field values on Acknowledgment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Acknowledgment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Acknowledgment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AcknowledgmentMultiError,
// or nil if none found.
func (m *Acknowledgment) ValidateAll() error {
	return m.validate(true)
}

func (m *Acknowledgment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AcknowledgmentValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AcknowledgmentValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AcknowledgmentValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Text

	if len(errors) > 0 {
		return AcknowledgmentMultiError(errors)
	}

	return nil
}

// AcknowledgmentMultiError is an error wrapping multiple validation errors
// returned by Acknowledgment.ValidateAll() if the designated constraints
// aren't met.
type AcknowledgmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AcknowledgmentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AcknowledgmentMultiError) AllErrors() []error { return m }

// AcknowledgmentValidationError is the validation error returned by
// Acknowledgment.Validate if the designated constraints aren't met.
type AcknowledgmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AcknowledgmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AcknowledgmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AcknowledgmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AcknowledgmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AcknowledgmentValidationError) ErrorName() string { return "AcknowledgmentValidationError" }

// Error satisfies the builtin error interface
func (e AcknowledgmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAcknowledgment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AcknowledgmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AcknowledgmentValidationError{}

// Validate checks the field values on Title with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Title) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Title with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TitleMultiError, or nil if none found.
func (m *Title) ValidateAll() error {
	return m.validate(true)
}

func (m *Title) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TitleValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TitleValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TitleValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Text

	if len(errors) > 0 {
		return TitleMultiError(errors)
	}

	return nil
}

// TitleMultiError is an error wrapping multiple validation errors returned by
// Title.ValidateAll() if the designated constraints aren't met.
type TitleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TitleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TitleMultiError) AllErrors() []error { return m }

// TitleValidationError is the validation error returned by Title.Validate if
// the designated constraints aren't met.
type TitleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TitleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TitleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TitleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TitleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TitleValidationError) ErrorName() string { return "TitleValidationError" }

// Error satisfies the builtin error interface
func (e TitleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTitle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TitleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TitleValidationError{}

// Validate checks the field values on Sentence with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Sentence) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sentence with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SentenceMultiError, or nil
// if none found.
func (m *Sentence) ValidateAll() error {
	return m.validate(true)
}

func (m *Sentence) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for Text

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SentenceValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SentenceValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SentenceValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SentenceMultiError(errors)
	}

	return nil
}

// SentenceMultiError is an error wrapping multiple validation errors returned
// by Sentence.ValidateAll() if the designated constraints aren't met.
type SentenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SentenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SentenceMultiError) AllErrors() []error { return m }

// SentenceValidationError is the validation error returned by
// Sentence.Validate if the designated constraints aren't met.
type SentenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SentenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SentenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SentenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SentenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SentenceValidationError) ErrorName() string { return "SentenceValidationError" }

// Error satisfies the builtin error interface
func (e SentenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSentence.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SentenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SentenceValidationError{}

// Validate checks the field values on DocumentMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocumentMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentMetadataMultiError, or nil if none found.
func (m *DocumentMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GrobidVersion

	// no validation rules for GrobidTs

	for idx, item := range m.GetAuthors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Authors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Authors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("Authors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Date

	for idx, item := range m.GetDois() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Dois[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Dois[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("Dois[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FileSHA256

	// no validation rules for Lang

	if all {
		switch v := interface{}(m.GetAbstract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentMetadataValidationError{
					field:  "Abstract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentMetadataValidationError{
					field:  "Abstract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAbstract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentMetadataValidationError{
				field:  "Abstract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTitle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentMetadataValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentMetadataValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTitle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentMetadataValidationError{
				field:  "Title",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAcknowledgment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentMetadataValidationError{
					field:  "Acknowledgment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentMetadataValidationError{
					field:  "Acknowledgment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAcknowledgment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentMetadataValidationError{
				field:  "Acknowledgment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCatalogue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Catalogue[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Catalogue[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("Catalogue[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetReferences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("References[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("References[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetReferenceMarkers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("ReferenceMarkers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("ReferenceMarkers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("ReferenceMarkers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFiguresAndTables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("FiguresAndTables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("FiguresAndTables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("FiguresAndTables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFigureAndTableMarkers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("FigureAndTableMarkers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("FigureAndTableMarkers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("FigureAndTableMarkers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Pages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Pages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("Pages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFormulas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Formulas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentMetadataValidationError{
						field:  fmt.Sprintf("Formulas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentMetadataValidationError{
					field:  fmt.Sprintf("Formulas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentMetadataMultiError(errors)
	}

	return nil
}

// DocumentMetadataMultiError is an error wrapping multiple validation errors
// returned by DocumentMetadata.ValidateAll() if the designated constraints
// aren't met.
type DocumentMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentMetadataMultiError) AllErrors() []error { return m }

// DocumentMetadataValidationError is the validation error returned by
// DocumentMetadata.Validate if the designated constraints aren't met.
type DocumentMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentMetadataValidationError) ErrorName() string { return "DocumentMetadataValidationError" }

// Error satisfies the builtin error interface
func (e DocumentMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentMetadataValidationError{}

// Validate checks the field values on DocumentHeader with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DocumentHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentHeader with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocumentHeaderMultiError,
// or nil if none found.
func (m *DocumentHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GrobidVersion

	// no validation rules for GrobidTs

	if all {
		switch v := interface{}(m.GetAbstract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentHeaderValidationError{
					field:  "Abstract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentHeaderValidationError{
					field:  "Abstract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAbstract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentHeaderValidationError{
				field:  "Abstract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTitle()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentHeaderValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentHeaderValidationError{
					field:  "Title",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTitle()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentHeaderValidationError{
				field:  "Title",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FileSHA256

	// no validation rules for Lang

	// no validation rules for Date

	for idx, item := range m.GetDois() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentHeaderValidationError{
						field:  fmt.Sprintf("Dois[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentHeaderValidationError{
						field:  fmt.Sprintf("Dois[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentHeaderValidationError{
					field:  fmt.Sprintf("Dois[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAuthors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DocumentHeaderValidationError{
						field:  fmt.Sprintf("Authors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DocumentHeaderValidationError{
						field:  fmt.Sprintf("Authors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DocumentHeaderValidationError{
					field:  fmt.Sprintf("Authors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DocumentHeaderMultiError(errors)
	}

	return nil
}

// DocumentHeaderMultiError is an error wrapping multiple validation errors
// returned by DocumentHeader.ValidateAll() if the designated constraints
// aren't met.
type DocumentHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentHeaderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentHeaderMultiError) AllErrors() []error { return m }

// DocumentHeaderValidationError is the validation error returned by
// DocumentHeader.Validate if the designated constraints aren't met.
type DocumentHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentHeaderValidationError) ErrorName() string { return "DocumentHeaderValidationError" }

// Error satisfies the builtin error interface
func (e DocumentHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentHeaderValidationError{}

// Validate checks the field values on FullDocument with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FullDocument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FullDocument with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FullDocumentMultiError, or
// nil if none found.
func (m *FullDocument) ValidateAll() error {
	return m.validate(true)
}

func (m *FullDocument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParagraphs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FullDocumentValidationError{
						field:  fmt.Sprintf("Paragraphs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FullDocumentValidationError{
						field:  fmt.Sprintf("Paragraphs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FullDocumentValidationError{
					field:  fmt.Sprintf("Paragraphs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FullDocumentMultiError(errors)
	}

	return nil
}

// FullDocumentMultiError is an error wrapping multiple validation errors
// returned by FullDocument.ValidateAll() if the designated constraints aren't met.
type FullDocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FullDocumentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FullDocumentMultiError) AllErrors() []error { return m }

// FullDocumentValidationError is the validation error returned by
// FullDocument.Validate if the designated constraints aren't met.
type FullDocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FullDocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FullDocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FullDocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FullDocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FullDocumentValidationError) ErrorName() string { return "FullDocumentValidationError" }

// Error satisfies the builtin error interface
func (e FullDocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFullDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FullDocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FullDocumentValidationError{}

// Validate checks the field values on BlockText with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockText) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockText with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlockTextMultiError, or nil
// if none found.
func (m *BlockText) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockText) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockTextValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockTextValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockTextValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Text

	// no validation rules for CrossPage

	if len(errors) > 0 {
		return BlockTextMultiError(errors)
	}

	return nil
}

// BlockTextMultiError is an error wrapping multiple validation errors returned
// by BlockText.ValidateAll() if the designated constraints aren't met.
type BlockTextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockTextMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockTextMultiError) AllErrors() []error { return m }

// BlockTextValidationError is the validation error returned by
// BlockText.Validate if the designated constraints aren't met.
type BlockTextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockTextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockTextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockTextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockTextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockTextValidationError) ErrorName() string { return "BlockTextValidationError" }

// Error satisfies the builtin error interface
func (e BlockTextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockText.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockTextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockTextValidationError{}

// Validate checks the field values on PageBlock with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PageBlock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageBlock with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PageBlockMultiError, or nil
// if none found.
func (m *PageBlock) ValidateAll() error {
	return m.validate(true)
}

func (m *PageBlock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PageBlockValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PageBlockValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PageBlockValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTexts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageBlockValidationError{
						field:  fmt.Sprintf("Texts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageBlockValidationError{
						field:  fmt.Sprintf("Texts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageBlockValidationError{
					field:  fmt.Sprintf("Texts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Index

	// no validation rules for LinesDeleted

	// no validation rules for Level

	if len(errors) > 0 {
		return PageBlockMultiError(errors)
	}

	return nil
}

// PageBlockMultiError is an error wrapping multiple validation errors returned
// by PageBlock.ValidateAll() if the designated constraints aren't met.
type PageBlockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageBlockMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageBlockMultiError) AllErrors() []error { return m }

// PageBlockValidationError is the validation error returned by
// PageBlock.Validate if the designated constraints aren't met.
type PageBlockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageBlockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageBlockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageBlockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageBlockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageBlockValidationError) ErrorName() string { return "PageBlockValidationError" }

// Error satisfies the builtin error interface
func (e PageBlockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageBlock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageBlockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageBlockValidationError{}

// Validate checks the field values on PageBlockData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PageBlockData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageBlockData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PageBlockDataMultiError, or
// nil if none found.
func (m *PageBlockData) ValidateAll() error {
	return m.validate(true)
}

func (m *PageBlockData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageIndex

	for idx, item := range m.GetPageBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageBlockDataValidationError{
						field:  fmt.Sprintf("PageBlocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageBlockDataValidationError{
						field:  fmt.Sprintf("PageBlocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageBlockDataValidationError{
					field:  fmt.Sprintf("PageBlocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PageBlockDataMultiError(errors)
	}

	return nil
}

// PageBlockDataMultiError is an error wrapping multiple validation errors
// returned by PageBlockData.ValidateAll() if the designated constraints
// aren't met.
type PageBlockDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageBlockDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageBlockDataMultiError) AllErrors() []error { return m }

// PageBlockDataValidationError is the validation error returned by
// PageBlockData.Validate if the designated constraints aren't met.
type PageBlockDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageBlockDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageBlockDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageBlockDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageBlockDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageBlockDataValidationError) ErrorName() string { return "PageBlockDataValidationError" }

// Error satisfies the builtin error interface
func (e PageBlockDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageBlockData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageBlockDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageBlockDataValidationError{}
