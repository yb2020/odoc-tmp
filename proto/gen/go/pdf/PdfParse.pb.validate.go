// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: definitions/pdf/PdfParse.proto

package pdf

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PdfBBox with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PdfBBox) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PdfBBox with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PdfBBoxMultiError, or nil if none found.
func (m *PdfBBox) ValidateAll() error {
	return m.validate(true)
}

func (m *PdfBBox) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X0

	// no validation rules for Y0

	// no validation rules for X1

	// no validation rules for Y1

	// no validation rules for OriginHeight

	// no validation rules for OriginWidth

	if len(errors) > 0 {
		return PdfBBoxMultiError(errors)
	}

	return nil
}

// PdfBBoxMultiError is an error wrapping multiple validation errors returned
// by PdfBBox.ValidateAll() if the designated constraints aren't met.
type PdfBBoxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PdfBBoxMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PdfBBoxMultiError) AllErrors() []error { return m }

// PdfBBoxValidationError is the validation error returned by PdfBBox.Validate
// if the designated constraints aren't met.
type PdfBBoxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PdfBBoxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PdfBBoxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PdfBBoxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PdfBBoxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PdfBBoxValidationError) ErrorName() string { return "PdfBBoxValidationError" }

// Error satisfies the builtin error interface
func (e PdfBBoxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPdfBBox.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PdfBBoxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PdfBBoxValidationError{}

// Validate checks the field values on GetFiguresAndTablesListRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFiguresAndTablesListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFiguresAndTablesListRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetFiguresAndTablesListRequestMultiError, or nil if none found.
func (m *GetFiguresAndTablesListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFiguresAndTablesListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFiguresAndTablesListRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFiguresAndTablesListRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFiguresAndTablesListRequestValidationError{
				field:  "PageReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PdfId

	if len(errors) > 0 {
		return GetFiguresAndTablesListRequestMultiError(errors)
	}

	return nil
}

// GetFiguresAndTablesListRequestMultiError is an error wrapping multiple
// validation errors returned by GetFiguresAndTablesListRequest.ValidateAll()
// if the designated constraints aren't met.
type GetFiguresAndTablesListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFiguresAndTablesListRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFiguresAndTablesListRequestMultiError) AllErrors() []error { return m }

// GetFiguresAndTablesListRequestValidationError is the validation error
// returned by GetFiguresAndTablesListRequest.Validate if the designated
// constraints aren't met.
type GetFiguresAndTablesListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFiguresAndTablesListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFiguresAndTablesListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFiguresAndTablesListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFiguresAndTablesListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFiguresAndTablesListRequestValidationError) ErrorName() string {
	return "GetFiguresAndTablesListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFiguresAndTablesListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFiguresAndTablesListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFiguresAndTablesListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFiguresAndTablesListRequestValidationError{}

// Validate checks the field values on GetFiguresAndTablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFiguresAndTablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFiguresAndTablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFiguresAndTablesRequestMultiError, or nil if none found.
func (m *GetFiguresAndTablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFiguresAndTablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFiguresAndTablesRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFiguresAndTablesRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFiguresAndTablesRequestValidationError{
				field:  "PageReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PdfId

	// no validation rules for PaperId

	if len(errors) > 0 {
		return GetFiguresAndTablesRequestMultiError(errors)
	}

	return nil
}

// GetFiguresAndTablesRequestMultiError is an error wrapping multiple
// validation errors returned by GetFiguresAndTablesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetFiguresAndTablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFiguresAndTablesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFiguresAndTablesRequestMultiError) AllErrors() []error { return m }

// GetFiguresAndTablesRequestValidationError is the validation error returned
// by GetFiguresAndTablesRequest.Validate if the designated constraints aren't met.
type GetFiguresAndTablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFiguresAndTablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFiguresAndTablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFiguresAndTablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFiguresAndTablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFiguresAndTablesRequestValidationError) ErrorName() string {
	return "GetFiguresAndTablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFiguresAndTablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFiguresAndTablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFiguresAndTablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFiguresAndTablesRequestValidationError{}

// Validate checks the field values on PdfFigureAndTableInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PdfFigureAndTableInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PdfFigureAndTableInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PdfFigureAndTableInfoMultiError, or nil if none found.
func (m *PdfFigureAndTableInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PdfFigureAndTableInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for Desc

	// no validation rules for Url

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PdfFigureAndTableInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PdfFigureAndTableInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PdfFigureAndTableInfoValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefIdx

	if len(errors) > 0 {
		return PdfFigureAndTableInfoMultiError(errors)
	}

	return nil
}

// PdfFigureAndTableInfoMultiError is an error wrapping multiple validation
// errors returned by PdfFigureAndTableInfo.ValidateAll() if the designated
// constraints aren't met.
type PdfFigureAndTableInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PdfFigureAndTableInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PdfFigureAndTableInfoMultiError) AllErrors() []error { return m }

// PdfFigureAndTableInfoValidationError is the validation error returned by
// PdfFigureAndTableInfo.Validate if the designated constraints aren't met.
type PdfFigureAndTableInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PdfFigureAndTableInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PdfFigureAndTableInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PdfFigureAndTableInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PdfFigureAndTableInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PdfFigureAndTableInfoValidationError) ErrorName() string {
	return "PdfFigureAndTableInfoValidationError"
}

// Error satisfies the builtin error interface
func (e PdfFigureAndTableInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPdfFigureAndTableInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PdfFigureAndTableInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PdfFigureAndTableInfoValidationError{}

// Validate checks the field values on GetFiguresAndTablesListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFiguresAndTablesListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFiguresAndTablesListResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetFiguresAndTablesListResponseMultiError, or nil if none found.
func (m *GetFiguresAndTablesListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFiguresAndTablesListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFiguresAndTablesListResponseValidationError{
					field:  "PageResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFiguresAndTablesListResponseValidationError{
					field:  "PageResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFiguresAndTablesListResponseValidationError{
				field:  "PageResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFigureAndTableList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFiguresAndTablesListResponseValidationError{
						field:  fmt.Sprintf("FigureAndTableList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFiguresAndTablesListResponseValidationError{
						field:  fmt.Sprintf("FigureAndTableList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFiguresAndTablesListResponseValidationError{
					field:  fmt.Sprintf("FigureAndTableList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NeedFetch

	if len(errors) > 0 {
		return GetFiguresAndTablesListResponseMultiError(errors)
	}

	return nil
}

// GetFiguresAndTablesListResponseMultiError is an error wrapping multiple
// validation errors returned by GetFiguresAndTablesListResponse.ValidateAll()
// if the designated constraints aren't met.
type GetFiguresAndTablesListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFiguresAndTablesListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFiguresAndTablesListResponseMultiError) AllErrors() []error { return m }

// GetFiguresAndTablesListResponseValidationError is the validation error
// returned by GetFiguresAndTablesListResponse.Validate if the designated
// constraints aren't met.
type GetFiguresAndTablesListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFiguresAndTablesListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFiguresAndTablesListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFiguresAndTablesListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFiguresAndTablesListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFiguresAndTablesListResponseValidationError) ErrorName() string {
	return "GetFiguresAndTablesListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFiguresAndTablesListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFiguresAndTablesListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFiguresAndTablesListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFiguresAndTablesListResponseValidationError{}

// Validate checks the field values on GetReferenceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReferenceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReferenceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReferenceRequestMultiError, or nil if none found.
func (m *GetReferenceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReferenceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReferenceRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReferenceRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReferenceRequestValidationError{
				field:  "PageReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PdfId

	// no validation rules for SortType

	// no validation rules for PaperId

	if m.FilterNoTitle != nil {
		// no validation rules for FilterNoTitle
	}

	if len(errors) > 0 {
		return GetReferenceRequestMultiError(errors)
	}

	return nil
}

// GetReferenceRequestMultiError is an error wrapping multiple validation
// errors returned by GetReferenceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetReferenceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReferenceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReferenceRequestMultiError) AllErrors() []error { return m }

// GetReferenceRequestValidationError is the validation error returned by
// GetReferenceRequest.Validate if the designated constraints aren't met.
type GetReferenceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReferenceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReferenceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReferenceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReferenceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReferenceRequestValidationError) ErrorName() string {
	return "GetReferenceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReferenceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReferenceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReferenceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReferenceRequestValidationError{}

// Validate checks the field values on ReferenceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReferenceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReferenceInfoMultiError, or
// nil if none found.
func (m *ReferenceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaperId

	// no validation rules for Title

	// no validation rules for PageNum

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceInfoValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefIdx

	// no validation rules for CitationCount

	// no validation rules for PublishDate

	// no validation rules for SearchKey

	if all {
		switch v := interface{}(m.GetPaperMetaExtend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceInfoValidationError{
					field:  "PaperMetaExtend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceInfoValidationError{
					field:  "PaperMetaExtend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaperMetaExtend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceInfoValidationError{
				field:  "PaperMetaExtend",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReferenceInfoMultiError(errors)
	}

	return nil
}

// ReferenceInfoMultiError is an error wrapping multiple validation errors
// returned by ReferenceInfo.ValidateAll() if the designated constraints
// aren't met.
type ReferenceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceInfoMultiError) AllErrors() []error { return m }

// ReferenceInfoValidationError is the validation error returned by
// ReferenceInfo.Validate if the designated constraints aren't met.
type ReferenceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceInfoValidationError) ErrorName() string { return "ReferenceInfoValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceInfoValidationError{}

// Validate checks the field values on GetReferenceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReferenceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReferenceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReferenceResponseMultiError, or nil if none found.
func (m *GetReferenceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReferenceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReferenceResponseValidationError{
					field:  "PageResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReferenceResponseValidationError{
					field:  "PageResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReferenceResponseValidationError{
				field:  "PageResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetReferenceInfoList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReferenceResponseValidationError{
						field:  fmt.Sprintf("ReferenceInfoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReferenceResponseValidationError{
						field:  fmt.Sprintf("ReferenceInfoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReferenceResponseValidationError{
					field:  fmt.Sprintf("ReferenceInfoList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReferenceCount

	// no validation rules for CitationCount

	// no validation rules for NeedFetch

	if len(errors) > 0 {
		return GetReferenceResponseMultiError(errors)
	}

	return nil
}

// GetReferenceResponseMultiError is an error wrapping multiple validation
// errors returned by GetReferenceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetReferenceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReferenceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReferenceResponseMultiError) AllErrors() []error { return m }

// GetReferenceResponseValidationError is the validation error returned by
// GetReferenceResponse.Validate if the designated constraints aren't met.
type GetReferenceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReferenceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReferenceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReferenceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReferenceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReferenceResponseValidationError) ErrorName() string {
	return "GetReferenceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReferenceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReferenceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReferenceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReferenceResponseValidationError{}

// Validate checks the field values on PaperMetaExtend with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PaperMetaExtend) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaperMetaExtend with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaperMetaExtendMultiError, or nil if none found.
func (m *PaperMetaExtend) ValidateAll() error {
	return m.validate(true)
}

func (m *PaperMetaExtend) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PdfId

	for idx, item := range m.GetAuthorList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaperMetaExtendValidationError{
						field:  fmt.Sprintf("AuthorList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaperMetaExtendValidationError{
						field:  fmt.Sprintf("AuthorList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaperMetaExtendValidationError{
					field:  fmt.Sprintf("AuthorList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PublishDate

	// no validation rules for NoteCount

	// no validation rules for CitationCount

	// no validation rules for Summary

	// no validation rules for Title

	// no validation rules for PaperId

	if len(errors) > 0 {
		return PaperMetaExtendMultiError(errors)
	}

	return nil
}

// PaperMetaExtendMultiError is an error wrapping multiple validation errors
// returned by PaperMetaExtend.ValidateAll() if the designated constraints
// aren't met.
type PaperMetaExtendMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaperMetaExtendMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaperMetaExtendMultiError) AllErrors() []error { return m }

// PaperMetaExtendValidationError is the validation error returned by
// PaperMetaExtend.Validate if the designated constraints aren't met.
type PaperMetaExtendValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaperMetaExtendValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaperMetaExtendValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaperMetaExtendValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaperMetaExtendValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaperMetaExtendValidationError) ErrorName() string { return "PaperMetaExtendValidationError" }

// Error satisfies the builtin error interface
func (e PaperMetaExtendValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaperMetaExtend.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaperMetaExtendValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaperMetaExtendValidationError{}

// Validate checks the field values on Author with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Author) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Author with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AuthorMultiError, or nil if none found.
func (m *Author) ValidateAll() error {
	return m.validate(true)
}

func (m *Author) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return AuthorMultiError(errors)
	}

	return nil
}

// AuthorMultiError is an error wrapping multiple validation errors returned by
// Author.ValidateAll() if the designated constraints aren't met.
type AuthorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorMultiError) AllErrors() []error { return m }

// AuthorValidationError is the validation error returned by Author.Validate if
// the designated constraints aren't met.
type AuthorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorValidationError) ErrorName() string { return "AuthorValidationError" }

// Error satisfies the builtin error interface
func (e AuthorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorValidationError{}

// Validate checks the field values on GetCitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCitationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCitationRequestMultiError, or nil if none found.
func (m *GetCitationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCitationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCitationRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCitationRequestValidationError{
					field:  "PageReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCitationRequestValidationError{
				field:  "PageReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PaperId

	// no validation rules for SortType

	if len(errors) > 0 {
		return GetCitationRequestMultiError(errors)
	}

	return nil
}

// GetCitationRequestMultiError is an error wrapping multiple validation errors
// returned by GetCitationRequest.ValidateAll() if the designated constraints
// aren't met.
type GetCitationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCitationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCitationRequestMultiError) AllErrors() []error { return m }

// GetCitationRequestValidationError is the validation error returned by
// GetCitationRequest.Validate if the designated constraints aren't met.
type GetCitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCitationRequestValidationError) ErrorName() string {
	return "GetCitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCitationRequestValidationError{}

// Validate checks the field values on CitationInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CitationInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CitationInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CitationInfoMultiError, or
// nil if none found.
func (m *CitationInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CitationInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaperId

	// no validation rules for Title

	// no validation rules for CitaIdx

	// no validation rules for CitationCount

	// no validation rules for PublishDate

	if all {
		switch v := interface{}(m.GetPaperMetaExtend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CitationInfoValidationError{
					field:  "PaperMetaExtend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CitationInfoValidationError{
					field:  "PaperMetaExtend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaperMetaExtend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CitationInfoValidationError{
				field:  "PaperMetaExtend",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CitationInfoMultiError(errors)
	}

	return nil
}

// CitationInfoMultiError is an error wrapping multiple validation errors
// returned by CitationInfo.ValidateAll() if the designated constraints aren't met.
type CitationInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CitationInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CitationInfoMultiError) AllErrors() []error { return m }

// CitationInfoValidationError is the validation error returned by
// CitationInfo.Validate if the designated constraints aren't met.
type CitationInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CitationInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CitationInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CitationInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CitationInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CitationInfoValidationError) ErrorName() string { return "CitationInfoValidationError" }

// Error satisfies the builtin error interface
func (e CitationInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCitationInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CitationInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CitationInfoValidationError{}

// Validate checks the field values on GetCitationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCitationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCitationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCitationResponseMultiError, or nil if none found.
func (m *GetCitationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCitationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCitationResponseValidationError{
					field:  "PageResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCitationResponseValidationError{
					field:  "PageResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCitationResponseValidationError{
				field:  "PageResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCitationInfoList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCitationResponseValidationError{
						field:  fmt.Sprintf("CitationInfoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCitationResponseValidationError{
						field:  fmt.Sprintf("CitationInfoList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCitationResponseValidationError{
					field:  fmt.Sprintf("CitationInfoList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReferenceCount

	// no validation rules for CitationCount

	// no validation rules for NeedFetch

	if len(errors) > 0 {
		return GetCitationResponseMultiError(errors)
	}

	return nil
}

// GetCitationResponseMultiError is an error wrapping multiple validation
// errors returned by GetCitationResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCitationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCitationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCitationResponseMultiError) AllErrors() []error { return m }

// GetCitationResponseValidationError is the validation error returned by
// GetCitationResponse.Validate if the designated constraints aren't met.
type GetCitationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCitationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCitationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCitationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCitationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCitationResponseValidationError) ErrorName() string {
	return "GetCitationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCitationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCitationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCitationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCitationResponseValidationError{}

// Validate checks the field values on GetReferenceMarkersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReferenceMarkersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReferenceMarkersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReferenceMarkersRequestMultiError, or nil if none found.
func (m *GetReferenceMarkersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReferenceMarkersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PdfId

	if len(errors) > 0 {
		return GetReferenceMarkersRequestMultiError(errors)
	}

	return nil
}

// GetReferenceMarkersRequestMultiError is an error wrapping multiple
// validation errors returned by GetReferenceMarkersRequest.ValidateAll() if
// the designated constraints aren't met.
type GetReferenceMarkersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReferenceMarkersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReferenceMarkersRequestMultiError) AllErrors() []error { return m }

// GetReferenceMarkersRequestValidationError is the validation error returned
// by GetReferenceMarkersRequest.Validate if the designated constraints aren't met.
type GetReferenceMarkersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReferenceMarkersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReferenceMarkersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReferenceMarkersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReferenceMarkersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReferenceMarkersRequestValidationError) ErrorName() string {
	return "GetReferenceMarkersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReferenceMarkersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReferenceMarkersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReferenceMarkersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReferenceMarkersRequestValidationError{}

// Validate checks the field values on ReferenceMarker with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReferenceMarker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceMarker with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceMarkerMultiError, or nil if none found.
func (m *ReferenceMarker) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceMarker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefIdx

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceMarkerValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceMarkerValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceMarkerValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PaperId

	// no validation rules for RefContent

	// no validation rules for PageNum

	// no validation rules for RefRaw

	if len(errors) > 0 {
		return ReferenceMarkerMultiError(errors)
	}

	return nil
}

// ReferenceMarkerMultiError is an error wrapping multiple validation errors
// returned by ReferenceMarker.ValidateAll() if the designated constraints
// aren't met.
type ReferenceMarkerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceMarkerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceMarkerMultiError) AllErrors() []error { return m }

// ReferenceMarkerValidationError is the validation error returned by
// ReferenceMarker.Validate if the designated constraints aren't met.
type ReferenceMarkerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceMarkerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceMarkerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceMarkerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceMarkerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceMarkerValidationError) ErrorName() string { return "ReferenceMarkerValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceMarkerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceMarker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceMarkerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceMarkerValidationError{}

// Validate checks the field values on FigureAndTableReferenceMarker with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FigureAndTableReferenceMarker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FigureAndTableReferenceMarker with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FigureAndTableReferenceMarkerMultiError, or nil if none found.
func (m *FigureAndTableReferenceMarker) ValidateAll() error {
	return m.validate(true)
}

func (m *FigureAndTableReferenceMarker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FigureAndTableReferenceMarkerValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FigureAndTableReferenceMarkerValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FigureAndTableReferenceMarkerValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PageNum

	// no validation rules for RefContent

	// no validation rules for RefIdx

	if len(errors) > 0 {
		return FigureAndTableReferenceMarkerMultiError(errors)
	}

	return nil
}

// FigureAndTableReferenceMarkerMultiError is an error wrapping multiple
// validation errors returned by FigureAndTableReferenceMarker.ValidateAll()
// if the designated constraints aren't met.
type FigureAndTableReferenceMarkerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FigureAndTableReferenceMarkerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FigureAndTableReferenceMarkerMultiError) AllErrors() []error { return m }

// FigureAndTableReferenceMarkerValidationError is the validation error
// returned by FigureAndTableReferenceMarker.Validate if the designated
// constraints aren't met.
type FigureAndTableReferenceMarkerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FigureAndTableReferenceMarkerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FigureAndTableReferenceMarkerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FigureAndTableReferenceMarkerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FigureAndTableReferenceMarkerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FigureAndTableReferenceMarkerValidationError) ErrorName() string {
	return "FigureAndTableReferenceMarkerValidationError"
}

// Error satisfies the builtin error interface
func (e FigureAndTableReferenceMarkerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFigureAndTableReferenceMarker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FigureAndTableReferenceMarkerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FigureAndTableReferenceMarkerValidationError{}

// Validate checks the field values on GetReferenceMarkersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReferenceMarkersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReferenceMarkersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReferenceMarkersResponseMultiError, or nil if none found.
func (m *GetReferenceMarkersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReferenceMarkersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMarkers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReferenceMarkersResponseValidationError{
						field:  fmt.Sprintf("Markers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReferenceMarkersResponseValidationError{
						field:  fmt.Sprintf("Markers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReferenceMarkersResponseValidationError{
					field:  fmt.Sprintf("Markers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NeedFetch

	for idx, item := range m.GetFigureAndTableMarkers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReferenceMarkersResponseValidationError{
						field:  fmt.Sprintf("FigureAndTableMarkers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReferenceMarkersResponseValidationError{
						field:  fmt.Sprintf("FigureAndTableMarkers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReferenceMarkersResponseValidationError{
					field:  fmt.Sprintf("FigureAndTableMarkers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetReferenceMarkersResponseMultiError(errors)
	}

	return nil
}

// GetReferenceMarkersResponseMultiError is an error wrapping multiple
// validation errors returned by GetReferenceMarkersResponse.ValidateAll() if
// the designated constraints aren't met.
type GetReferenceMarkersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReferenceMarkersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReferenceMarkersResponseMultiError) AllErrors() []error { return m }

// GetReferenceMarkersResponseValidationError is the validation error returned
// by GetReferenceMarkersResponse.Validate if the designated constraints
// aren't met.
type GetReferenceMarkersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReferenceMarkersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReferenceMarkersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReferenceMarkersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReferenceMarkersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReferenceMarkersResponseValidationError) ErrorName() string {
	return "GetReferenceMarkersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReferenceMarkersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReferenceMarkersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReferenceMarkersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReferenceMarkersResponseValidationError{}

// Validate checks the field values on AsyncPdfCvParseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AsyncPdfCvParseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AsyncPdfCvParseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AsyncPdfCvParseRequestMultiError, or nil if none found.
func (m *AsyncPdfCvParseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AsyncPdfCvParseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for FileSHA256

	// no validation rules for Fulltext

	if len(errors) > 0 {
		return AsyncPdfCvParseRequestMultiError(errors)
	}

	return nil
}

// AsyncPdfCvParseRequestMultiError is an error wrapping multiple validation
// errors returned by AsyncPdfCvParseRequest.ValidateAll() if the designated
// constraints aren't met.
type AsyncPdfCvParseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AsyncPdfCvParseRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AsyncPdfCvParseRequestMultiError) AllErrors() []error { return m }

// AsyncPdfCvParseRequestValidationError is the validation error returned by
// AsyncPdfCvParseRequest.Validate if the designated constraints aren't met.
type AsyncPdfCvParseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AsyncPdfCvParseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AsyncPdfCvParseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AsyncPdfCvParseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AsyncPdfCvParseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AsyncPdfCvParseRequestValidationError) ErrorName() string {
	return "AsyncPdfCvParseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AsyncPdfCvParseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsyncPdfCvParseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AsyncPdfCvParseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AsyncPdfCvParseRequestValidationError{}

// Validate checks the field values on AsyncPdfCvParseResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AsyncPdfCvParseResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AsyncPdfCvParseResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AsyncPdfCvParseResponseMultiError, or nil if none found.
func (m *AsyncPdfCvParseResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AsyncPdfCvParseResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AsyncPdfCvParseResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AsyncPdfCvParseResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AsyncPdfCvParseResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ProcStatus

	if len(errors) > 0 {
		return AsyncPdfCvParseResponseMultiError(errors)
	}

	return nil
}

// AsyncPdfCvParseResponseMultiError is an error wrapping multiple validation
// errors returned by AsyncPdfCvParseResponse.ValidateAll() if the designated
// constraints aren't met.
type AsyncPdfCvParseResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AsyncPdfCvParseResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AsyncPdfCvParseResponseMultiError) AllErrors() []error { return m }

// AsyncPdfCvParseResponseValidationError is the validation error returned by
// AsyncPdfCvParseResponse.Validate if the designated constraints aren't met.
type AsyncPdfCvParseResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AsyncPdfCvParseResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AsyncPdfCvParseResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AsyncPdfCvParseResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AsyncPdfCvParseResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AsyncPdfCvParseResponseValidationError) ErrorName() string {
	return "AsyncPdfCvParseResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AsyncPdfCvParseResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsyncPdfCvParseResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AsyncPdfCvParseResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AsyncPdfCvParseResponseValidationError{}

// Validate checks the field values on GetCatalogueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCatalogueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCatalogueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCatalogueRequestMultiError, or nil if none found.
func (m *GetCatalogueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCatalogueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PdfId

	if len(errors) > 0 {
		return GetCatalogueRequestMultiError(errors)
	}

	return nil
}

// GetCatalogueRequestMultiError is an error wrapping multiple validation
// errors returned by GetCatalogueRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCatalogueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCatalogueRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCatalogueRequestMultiError) AllErrors() []error { return m }

// GetCatalogueRequestValidationError is the validation error returned by
// GetCatalogueRequest.Validate if the designated constraints aren't met.
type GetCatalogueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCatalogueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCatalogueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCatalogueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCatalogueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCatalogueRequestValidationError) ErrorName() string {
	return "GetCatalogueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCatalogueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCatalogueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCatalogueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCatalogueRequestValidationError{}

// Validate checks the field values on PdfCatalogueInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PdfCatalogueInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PdfCatalogueInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PdfCatalogueInfoMultiError, or nil if none found.
func (m *PdfCatalogueInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PdfCatalogueInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for PageNum

	for idx, item := range m.GetChild() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PdfCatalogueInfoValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PdfCatalogueInfoValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PdfCatalogueInfoValidationError{
					field:  fmt.Sprintf("Child[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetBbox()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PdfCatalogueInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PdfCatalogueInfoValidationError{
					field:  "Bbox",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBbox()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PdfCatalogueInfoValidationError{
				field:  "Bbox",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PdfCatalogueInfoMultiError(errors)
	}

	return nil
}

// PdfCatalogueInfoMultiError is an error wrapping multiple validation errors
// returned by PdfCatalogueInfo.ValidateAll() if the designated constraints
// aren't met.
type PdfCatalogueInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PdfCatalogueInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PdfCatalogueInfoMultiError) AllErrors() []error { return m }

// PdfCatalogueInfoValidationError is the validation error returned by
// PdfCatalogueInfo.Validate if the designated constraints aren't met.
type PdfCatalogueInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PdfCatalogueInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PdfCatalogueInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PdfCatalogueInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PdfCatalogueInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PdfCatalogueInfoValidationError) ErrorName() string { return "PdfCatalogueInfoValidationError" }

// Error satisfies the builtin error interface
func (e PdfCatalogueInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPdfCatalogueInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PdfCatalogueInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PdfCatalogueInfoValidationError{}

// Validate checks the field values on GetCatalogueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCatalogueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCatalogueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCatalogueResponseMultiError, or nil if none found.
func (m *GetCatalogueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCatalogueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NeedFetch

	if all {
		switch v := interface{}(m.GetPdfCatalogue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCatalogueResponseValidationError{
					field:  "PdfCatalogue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCatalogueResponseValidationError{
					field:  "PdfCatalogue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPdfCatalogue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCatalogueResponseValidationError{
				field:  "PdfCatalogue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCatalogueResponseMultiError(errors)
	}

	return nil
}

// GetCatalogueResponseMultiError is an error wrapping multiple validation
// errors returned by GetCatalogueResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCatalogueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCatalogueResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCatalogueResponseMultiError) AllErrors() []error { return m }

// GetCatalogueResponseValidationError is the validation error returned by
// GetCatalogueResponse.Validate if the designated constraints aren't met.
type GetCatalogueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCatalogueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCatalogueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCatalogueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCatalogueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCatalogueResponseValidationError) ErrorName() string {
	return "GetCatalogueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCatalogueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCatalogueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCatalogueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCatalogueResponseValidationError{}

// Validate checks the field values on PdfRefRematchReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PdfRefRematchReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PdfRefRematchReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PdfRefRematchReqMultiError, or nil if none found.
func (m *PdfRefRematchReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PdfRefRematchReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PdfRefRematchReqMultiError(errors)
	}

	return nil
}

// PdfRefRematchReqMultiError is an error wrapping multiple validation errors
// returned by PdfRefRematchReq.ValidateAll() if the designated constraints
// aren't met.
type PdfRefRematchReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PdfRefRematchReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PdfRefRematchReqMultiError) AllErrors() []error { return m }

// PdfRefRematchReqValidationError is the validation error returned by
// PdfRefRematchReq.Validate if the designated constraints aren't met.
type PdfRefRematchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PdfRefRematchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PdfRefRematchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PdfRefRematchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PdfRefRematchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PdfRefRematchReqValidationError) ErrorName() string { return "PdfRefRematchReqValidationError" }

// Error satisfies the builtin error interface
func (e PdfRefRematchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPdfRefRematchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PdfRefRematchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PdfRefRematchReqValidationError{}

// Validate checks the field values on PdfRefRematchResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PdfRefRematchResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PdfRefRematchResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PdfRefRematchRespMultiError, or nil if none found.
func (m *PdfRefRematchResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PdfRefRematchResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StatusCode

	// no validation rules for ErrMsg

	if len(errors) > 0 {
		return PdfRefRematchRespMultiError(errors)
	}

	return nil
}

// PdfRefRematchRespMultiError is an error wrapping multiple validation errors
// returned by PdfRefRematchResp.ValidateAll() if the designated constraints
// aren't met.
type PdfRefRematchRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PdfRefRematchRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PdfRefRematchRespMultiError) AllErrors() []error { return m }

// PdfRefRematchRespValidationError is the validation error returned by
// PdfRefRematchResp.Validate if the designated constraints aren't met.
type PdfRefRematchRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PdfRefRematchRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PdfRefRematchRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PdfRefRematchRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PdfRefRematchRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PdfRefRematchRespValidationError) ErrorName() string {
	return "PdfRefRematchRespValidationError"
}

// Error satisfies the builtin error interface
func (e PdfRefRematchRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPdfRefRematchResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PdfRefRematchRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PdfRefRematchRespValidationError{}
