// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/copilot/CustomQuestion.proto" (package "copilot", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @api_path: /api/customQuestion/getList
 * @method: GET
 * @content-type: application/json
 * @summary: 获取自定义问题列表
 *
 * @generated from protobuf message copilot.GetListReq
 */
export interface GetListReq {
    /**
     * @generated from protobuf field: copilot.CustomQuestionSortType sortType = 1
     */
    sortType: CustomQuestionSortType;
}
/**
 * @generated from protobuf message copilot.GetListResp
 */
export interface GetListResp {
    /**
     * @generated from protobuf field: repeated copilot.QuestionInfo questionList = 1
     */
    questionList: QuestionInfo[];
}
/**
 * @generated from protobuf message copilot.QuestionInfo
 */
export interface QuestionInfo {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * 问题内容
     *
     * @generated from protobuf field: string question = 2
     */
    question: string;
    /**
     * 提问次数
     *
     * @generated from protobuf field: int32 useCount = 3
     */
    useCount: number;
    /**
     * 是否是系统默认
     *
     * @generated from protobuf field: bool isSystemDefault = 4
     */
    isSystemDefault: boolean;
}
/**
 * *
 * 	接口描述:添加自定义问题
 * 	接口url:/customQuestion/add
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message copilot.AddQuestionReq
 */
export interface AddQuestionReq {
    /**
     * 问题内容
     *
     * @generated from protobuf field: string question = 1
     */
    question: string;
}
/**
 * @generated from protobuf message copilot.AddQuestionResponse
 */
export interface AddQuestionResponse {
    /**
     * 自定义问题id
     *
     * @generated from protobuf field: string questionId = 1
     */
    questionId: string;
}
/**
 * *
 * 	接口描述:删除自定义问题
 * 	接口url:/customQuestion/delete
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message copilot.DeleteQuestionReq
 */
export interface DeleteQuestionReq {
    /**
     * 自定义问题id
     *
     * @generated from protobuf field: string questionId = 1
     */
    questionId: string;
}
/**
 * *
 * 	接口描述:自定义问题提问计数
 * 	接口url:/customQuestion/useCount
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message copilot.QuestionUseCountReq
 */
export interface QuestionUseCountReq {
    /**
     * 自定义问题id
     *
     * @generated from protobuf field: string questionId = 1
     */
    questionId: string;
}
/**
 * @generated from protobuf enum copilot.CustomQuestionSortType
 */
export enum CustomQuestionSortType {
    /**
     * 最早添加
     *
     * @generated from protobuf enum value: EARLIEST = 0;
     */
    EARLIEST = 0,
    /**
     * 最常使用
     *
     * @generated from protobuf enum value: MOST_USE = 1;
     */
    MOST_USE = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class GetListReq$Type extends MessageType<GetListReq> {
    constructor() {
        super("copilot.GetListReq", [
            { no: 1, name: "sortType", kind: "enum", T: () => ["copilot.CustomQuestionSortType", CustomQuestionSortType] }
        ]);
    }
    create(value?: PartialMessage<GetListReq>): GetListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sortType = 0;
        if (value !== undefined)
            reflectionMergePartial<GetListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetListReq): GetListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* copilot.CustomQuestionSortType sortType */ 1:
                    message.sortType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* copilot.CustomQuestionSortType sortType = 1; */
        if (message.sortType !== 0)
            writer.tag(1, WireType.Varint).int32(message.sortType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.GetListReq
 */
export const GetListReq = new GetListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetListResp$Type extends MessageType<GetListResp> {
    constructor() {
        super("copilot.GetListResp", [
            { no: 1, name: "questionList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => QuestionInfo }
        ]);
    }
    create(value?: PartialMessage<GetListResp>): GetListResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.questionList = [];
        if (value !== undefined)
            reflectionMergePartial<GetListResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetListResp): GetListResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated copilot.QuestionInfo questionList */ 1:
                    message.questionList.push(QuestionInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetListResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated copilot.QuestionInfo questionList = 1; */
        for (let i = 0; i < message.questionList.length; i++)
            QuestionInfo.internalBinaryWrite(message.questionList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.GetListResp
 */
export const GetListResp = new GetListResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestionInfo$Type extends MessageType<QuestionInfo> {
    constructor() {
        super("copilot.QuestionInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "question", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "useCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "isSystemDefault", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QuestionInfo>): QuestionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.question = "";
        message.useCount = 0;
        message.isSystemDefault = false;
        if (value !== undefined)
            reflectionMergePartial<QuestionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestionInfo): QuestionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string question */ 2:
                    message.question = reader.string();
                    break;
                case /* int32 useCount */ 3:
                    message.useCount = reader.int32();
                    break;
                case /* bool isSystemDefault */ 4:
                    message.isSystemDefault = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string question = 2; */
        if (message.question !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.question);
        /* int32 useCount = 3; */
        if (message.useCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.useCount);
        /* bool isSystemDefault = 4; */
        if (message.isSystemDefault !== false)
            writer.tag(4, WireType.Varint).bool(message.isSystemDefault);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.QuestionInfo
 */
export const QuestionInfo = new QuestionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddQuestionReq$Type extends MessageType<AddQuestionReq> {
    constructor() {
        super("copilot.AddQuestionReq", [
            { no: 1, name: "question", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddQuestionReq>): AddQuestionReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.question = "";
        if (value !== undefined)
            reflectionMergePartial<AddQuestionReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddQuestionReq): AddQuestionReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string question */ 1:
                    message.question = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddQuestionReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string question = 1; */
        if (message.question !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.question);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.AddQuestionReq
 */
export const AddQuestionReq = new AddQuestionReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddQuestionResponse$Type extends MessageType<AddQuestionResponse> {
    constructor() {
        super("copilot.AddQuestionResponse", [
            { no: 1, name: "questionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddQuestionResponse>): AddQuestionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.questionId = "";
        if (value !== undefined)
            reflectionMergePartial<AddQuestionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddQuestionResponse): AddQuestionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string questionId */ 1:
                    message.questionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddQuestionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string questionId = 1; */
        if (message.questionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.questionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.AddQuestionResponse
 */
export const AddQuestionResponse = new AddQuestionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteQuestionReq$Type extends MessageType<DeleteQuestionReq> {
    constructor() {
        super("copilot.DeleteQuestionReq", [
            { no: 1, name: "questionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteQuestionReq>): DeleteQuestionReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.questionId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteQuestionReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteQuestionReq): DeleteQuestionReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string questionId */ 1:
                    message.questionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteQuestionReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string questionId = 1; */
        if (message.questionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.questionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.DeleteQuestionReq
 */
export const DeleteQuestionReq = new DeleteQuestionReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestionUseCountReq$Type extends MessageType<QuestionUseCountReq> {
    constructor() {
        super("copilot.QuestionUseCountReq", [
            { no: 1, name: "questionId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuestionUseCountReq>): QuestionUseCountReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.questionId = "";
        if (value !== undefined)
            reflectionMergePartial<QuestionUseCountReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestionUseCountReq): QuestionUseCountReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string questionId */ 1:
                    message.questionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestionUseCountReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string questionId = 1; */
        if (message.questionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.questionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message copilot.QuestionUseCountReq
 */
export const QuestionUseCountReq = new QuestionUseCountReq$Type();
