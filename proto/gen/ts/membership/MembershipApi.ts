// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/membership/MembershipApi.proto" (package "membership", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { User } from "../user/User";
/**
 * 订阅套餐信息
 *
 * @generated from protobuf message membership.SubInfo
 */
export interface SubInfo {
    /**
     * @generated from protobuf field: uint32 type = 1
     */
    type: number; // 订阅类型，对应constant.OrderType 1:Free, 2:PRO, 3:PRO_AddOnCredit
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string; // 订阅名称
    /**
     * @generated from protobuf field: uint64 price = 3
     */
    price: bigint; // 订阅价格
    /**
     * @generated from protobuf field: uint64 originalPrice = 4
     */
    originalPrice: bigint; // 原始订阅价格
    /**
     * @generated from protobuf field: string currency = 5
     */
    currency: string; // 货币单位
    /**
     * @generated from protobuf field: uint64 credit = 6
     */
    credit: bigint; // 积分值
    /**
     * @generated from protobuf field: uint64 originalCredit = 7
     */
    originalCredit: bigint; // 原始积分值
    /**
     * @generated from protobuf field: uint64 addOnCredit = 8
     */
    addOnCredit: bigint; // 附加积分值
    /**
     * @generated from protobuf field: uint32 duration = 9
     */
    duration: number; // 有效期（单位：月）
    /**
     * @generated from protobuf field: string stripePayMode = 10
     */
    stripePayMode: string; // stripe支付模式 payment: 一次性付款, subscription: 订阅
    /**
     * @generated from protobuf field: string stripePriceId = 11
     */
    stripePriceId: string; // stripe价格ID
}
/**
 * 基础权限
 *
 * @generated from protobuf message membership.BasePermission
 */
export interface BasePermission {
    /**
     * @generated from protobuf field: membership.SubInfo subInfo = 1
     */
    subInfo?: SubInfo; // 订阅套餐信息
    /**
     * @generated from protobuf field: bool isEnableAddOnCredit = 2
     */
    isEnableAddOnCredit: boolean; // 是否允许使用附加信用值
    /**
     * @generated from protobuf field: bool isEnableSubAddOnCredit = 3
     */
    isEnableSubAddOnCredit: boolean; // 是否允许订阅附加信用值
    /**
     * @generated from protobuf field: uint32 maxAddOnCreditSubCountOfMonth = 4
     */
    maxAddOnCreditSubCountOfMonth: number; // 每月最大附加订阅包数量
    /**
     * @generated from protobuf field: membership.SubInfo subAddOnCreditInfo = 5
     */
    subAddOnCreditInfo?: SubInfo; // 附加积分订阅套餐信息
}
/**
 * 文档权限
 *
 * @generated from protobuf message membership.DocsPermission
 */
export interface DocsPermission {
    /**
     * @generated from protobuf field: uint64 maxStorageCapacity = 1
     */
    maxStorageCapacity: bigint; // 最大存储容量（单位：MB）
    /**
     * @generated from protobuf field: uint64 maxStorageCapacityOriginal = 2
     */
    maxStorageCapacityOriginal: bigint; // 原始最大存储容量（单位：MB）
    /**
     * @generated from protobuf field: uint64 docUploadMaxSize = 3
     */
    docUploadMaxSize: bigint; // 文献上传文件最大值，单位（MB）
    /**
     * @generated from protobuf field: uint64 docUploadMaxSizeOriginal = 4
     */
    docUploadMaxSizeOriginal: bigint; // 原始文献上传文件最大值，单位（MB）
    /**
     * @generated from protobuf field: uint32 docUploadMaxPageCount = 5
     */
    docUploadMaxPageCount: number; // 文献上传文件最大页数
    /**
     * @generated from protobuf field: uint32 docUploadMaxPageCountOriginal = 6
     */
    docUploadMaxPageCountOriginal: number; // 原始文献上传文件最大页数
}
/**
 * 笔记权限
 *
 * @generated from protobuf message membership.NotePermission
 */
export interface NotePermission {
    /**
     * @generated from protobuf field: bool isNoteSummary = 1
     */
    isNoteSummary: boolean; // 是否开启笔记总结功能
    /**
     * @generated from protobuf field: bool isNoteWord = 2
     */
    isNoteWord: boolean; // 是否开启笔记Word功能
    /**
     * @generated from protobuf field: bool isNoteExtract = 3
     */
    isNoteExtract: boolean; // 是否开启笔记摘录功能
    /**
     * @generated from protobuf field: bool isNoteManage = 4
     */
    isNoteManage: boolean; // 是否开启笔记管理功能
    /**
     * @generated from protobuf field: bool isNotePdfDownload = 5
     */
    isNotePdfDownload: boolean; // 是否开启笔记PDF下载功能
}
/**
 * Copilot模型
 *
 * @generated from protobuf message membership.CopilotModel
 */
export interface CopilotModel {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string; // 模型key
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string; // 模型名称
    /**
     * @generated from protobuf field: bool isEnable = 3
     */
    isEnable: boolean; // 是否开启功能
    /**
     * @generated from protobuf field: bool isFree = 4
     */
    isFree: boolean; // 是否免费
    /**
     * @generated from protobuf field: uint64 creditCost = 5
     */
    creditCost: bigint; // 模型每次消耗信用值
}
/**
 * Copilot权限
 *
 * @generated from protobuf message membership.CopilotPermission
 */
export interface CopilotPermission {
    /**
     * @generated from protobuf field: bool isEnable = 1
     */
    isEnable: boolean; // 是否开启AI辅读
    /**
     * @generated from protobuf field: repeated membership.CopilotModel models = 2
     */
    models: CopilotModel[]; // Copilot模型
}
/**
 * AI权限
 *
 * @generated from protobuf message membership.AIPermission
 */
export interface AIPermission {
    /**
     * @generated from protobuf field: membership.CopilotPermission copilot = 1
     */
    copilot?: CopilotPermission; // Copilot权限
}
/**
 * 翻译权限
 *
 * @generated from protobuf message membership.TranslatePermission
 */
export interface TranslatePermission {
    /**
     * @generated from protobuf field: bool isOcr = 1
     */
    isOcr: boolean; // 是否开启OCR功能
    /**
     * @generated from protobuf field: uint64 ocrCreditCost = 2
     */
    ocrCreditCost: bigint; // 每次OCR消耗信用值
    /**
     * @generated from protobuf field: bool isWordTranslate = 3
     */
    isWordTranslate: boolean; // 是否开启Word翻译功能
    /**
     * @generated from protobuf field: uint64 wordTranslateCreditCost = 4
     */
    wordTranslateCreditCost: bigint; // 每次Word翻译消耗信用值
    /**
     * @generated from protobuf field: bool isFullTextTranslate = 5
     */
    isFullTextTranslate: boolean; // 是否开启全文翻译功能
    /**
     * @generated from protobuf field: uint64 fullTextTranslateCreditCost = 6
     */
    fullTextTranslateCreditCost: bigint; // 每次全文翻译消耗信用值
    /**
     * @generated from protobuf field: uint64 fullTextTranslateCreditCostOriginal = 7
     */
    fullTextTranslateCreditCostOriginal: bigint; // 原始每次全文翻译消耗信用值
    /**
     * @generated from protobuf field: uint64 fullTextTranslateMaxPageCount = 8
     */
    fullTextTranslateMaxPageCount: bigint; // 全文翻译最大页数
    /**
     * @generated from protobuf field: bool isAiTranslation = 9
     */
    isAiTranslation: boolean; // 是否开启AI翻译功能
    /**
     * @generated from protobuf field: uint64 aiTranslationCreditCost = 10
     */
    aiTranslationCreditCost: bigint; // 每次AI翻译消耗信用值
}
/**
 * 用户基础权限
 *
 * @generated from protobuf message membership.UserBasePermission
 */
export interface UserBasePermission {
    /**
     * @generated from protobuf field: bool isEnableAddOnCredit = 2
     */
    isEnableAddOnCredit: boolean; // 是否允许使用附加信用值
    /**
     * @generated from protobuf field: bool isEnableSubAddOnCredit = 3
     */
    isEnableSubAddOnCredit: boolean; // 是否允许订阅附加信用值
}
/**
 * 用户文档权限
 *
 * @generated from protobuf message membership.UserDocsPermission
 */
export interface UserDocsPermission {
    /**
     * @generated from protobuf field: uint64 maxStorageCapacity = 1
     */
    maxStorageCapacity: bigint; // 最大存储容量（单位：MB）
    /**
     * @generated from protobuf field: uint64 docUploadMaxSize = 2
     */
    docUploadMaxSize: bigint; // 文献上传文件最大值，单位（MB）
    /**
     * @generated from protobuf field: uint32 docUploadMaxPageCount = 3
     */
    docUploadMaxPageCount: number; // 文献上传文件最大页数
    /**
     * @generated from protobuf field: uint64 useStorageCapacity = 4
     */
    useStorageCapacity: bigint; // 已使用存储容量（单位：MB）
}
/**
 * 用户笔记权限
 *
 * @generated from protobuf message membership.UserNotePermission
 */
export interface UserNotePermission {
    /**
     * @generated from protobuf field: bool isNoteSummary = 1
     */
    isNoteSummary: boolean; // 是否开启笔记总结功能
    /**
     * @generated from protobuf field: bool isNoteWord = 2
     */
    isNoteWord: boolean; // 是否开启笔记Word功能
    /**
     * @generated from protobuf field: bool isNoteExtract = 3
     */
    isNoteExtract: boolean; // 是否开启笔记摘录功能
    /**
     * @generated from protobuf field: bool isNoteManage = 4
     */
    isNoteManage: boolean; // 是否开启笔记管理功能
    /**
     * @generated from protobuf field: bool isNotePdfDownload = 5
     */
    isNotePdfDownload: boolean; // 是否开启笔记PDF下载功能
}
/**
 * 用户AI权限
 *
 * @generated from protobuf message membership.UserAIPermission
 */
export interface UserAIPermission {
    /**
     * @generated from protobuf field: membership.CopilotPermission copilot = 1
     */
    copilot?: CopilotPermission; // Copilot权限
}
/**
 * 用户翻译权限
 *
 * @generated from protobuf message membership.UserTranslatePermission
 */
export interface UserTranslatePermission {
    /**
     * @generated from protobuf field: bool isOcr = 1
     */
    isOcr: boolean; // 是否开启OCR功能
    /**
     * @generated from protobuf field: uint64 ocrCreditCost = 2
     */
    ocrCreditCost: bigint; // 每次OCR消耗信用值
    /**
     * @generated from protobuf field: bool isWordTranslate = 3
     */
    isWordTranslate: boolean; // 是否开启Word翻译功能
    /**
     * @generated from protobuf field: uint64 wordTranslateCreditCost = 4
     */
    wordTranslateCreditCost: bigint; // 每次Word翻译消耗信用值
    /**
     * @generated from protobuf field: bool isFullTextTranslate = 5
     */
    isFullTextTranslate: boolean; // 是否开启全文翻译功能
    /**
     * @generated from protobuf field: uint64 fullTextTranslateCreditCost = 6
     */
    fullTextTranslateCreditCost: bigint; // 每次全文翻译消耗信用值
    /**
     * @generated from protobuf field: uint64 fullTextTranslateMaxPageCount = 7
     */
    fullTextTranslateMaxPageCount: bigint; // 全文翻译最大页数
    /**
     * @generated from protobuf field: bool isAiTranslation = 8
     */
    isAiTranslation: boolean; // 是否开启AI翻译功能
    /**
     * @generated from protobuf field: uint64 aiTranslationCreditCost = 9
     */
    aiTranslationCreditCost: bigint; // 每次AI翻译消耗信用值
}
/**
 * 会员订阅套餐信息
 *
 * @generated from protobuf message membership.MembershipSubPlanInfo
 */
export interface MembershipSubPlanInfo {
    /**
     * @generated from protobuf field: uint32 type = 1
     */
    type: number; // 会员类型，对应dto.MembershipType 0:Unknown, 1:Free, 2:PRO
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string; // 订阅名称
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string; // 订阅描述
    /**
     * @generated from protobuf field: bool isFree = 4
     */
    isFree: boolean; // 是否为免费
    /**
     * @generated from protobuf field: membership.BasePermission base = 5
     */
    base?: BasePermission; // 基础套餐
    /**
     * @generated from protobuf field: membership.DocsPermission docs = 6
     */
    docs?: DocsPermission; // 文档模块权限
    /**
     * @generated from protobuf field: membership.NotePermission note = 7
     */
    note?: NotePermission; // 笔记模块权限
    /**
     * @generated from protobuf field: membership.AIPermission ai = 8
     */
    ai?: AIPermission; // AI模块权限
    /**
     * @generated from protobuf field: membership.TranslatePermission translate = 9
     */
    translate?: TranslatePermission; // 翻译模块权限
}
/**
 * 用户会员基础信息Info
 *
 * @generated from protobuf message membership.UserMembershipBaseInfo
 */
export interface UserMembershipBaseInfo {
    /**
     * @generated from protobuf field: string userId = 1
     */
    userId: string; // 用户ID
    /**
     * @generated from protobuf field: uint32 type = 2
     */
    type: number; // 会员类型，对应dto.MembershipType 0:Unknown, 1:Free, 2:PRO
    /**
     * @generated from protobuf field: string typeName = 3
     */
    typeName: string; // 会员类型名称
    /**
     * @generated from protobuf field: uint64 credit = 4
     */
    credit: bigint; // 会员积分
    /**
     * @generated from protobuf field: uint64 addOnCredit = 5
     */
    addOnCredit: bigint; // 附加积分
    /**
     * @generated from protobuf field: bool isExpired = 6
     */
    isExpired: boolean; // 是否会员过期
    /**
     * @generated from protobuf field: uint32 expiredDay = 7
     */
    expiredDay: number; // 订阅剩余有效期（单位：天）
    /**
     * @generated from protobuf field: uint64 startAt = 8
     */
    startAt: bigint; // 订阅开始时间
    /**
     * @generated from protobuf field: uint64 endAt = 9
     */
    endAt: bigint; // 订阅结束时间
}
/**
 * 用户会员信息Info
 *
 * @generated from protobuf message membership.UserMembershipInfo
 */
export interface UserMembershipInfo {
    /**
     * @generated from protobuf field: membership.UserMembershipBaseInfo baseInfo = 1
     */
    baseInfo?: UserMembershipBaseInfo; // 用户会员基础信息
    /**
     * @generated from protobuf field: membership.UserPermission permission = 2
     */
    permission?: UserPermission; // 用户会员权限
}
/**
 * 用户会员权限
 *
 * @generated from protobuf message membership.UserPermission
 */
export interface UserPermission {
    /**
     * @generated from protobuf field: membership.UserBasePermission base = 1
     */
    base?: UserBasePermission; // 基础套餐
    /**
     * @generated from protobuf field: membership.UserDocsPermission docs = 2
     */
    docs?: UserDocsPermission; // 文档模块权限
    /**
     * @generated from protobuf field: membership.UserNotePermission note = 3
     */
    note?: UserNotePermission; // 笔记模块权限
    /**
     * @generated from protobuf field: membership.UserAIPermission ai = 4
     */
    ai?: UserAIPermission; // AI模块权限
    /**
     * @generated from protobuf field: membership.UserTranslatePermission translate = 5
     */
    translate?: UserTranslatePermission; // 翻译模块权限
}
/**
 * @api_path: /api/public/membership/get-subplan-infos
 * @method: GET
 * @content-type: application/json
 * @summary: 获取订阅套餐信息列表
 *
 * @generated from protobuf message membership.GetSubPlanInfosRequest
 */
export interface GetSubPlanInfosRequest {
}
/**
 * @generated from protobuf message membership.GetSubPlanInfosResponse
 */
export interface GetSubPlanInfosResponse {
    /**
     * @generated from protobuf field: repeated membership.MembershipSubPlanInfo subPlanInfos = 1
     */
    subPlanInfos: MembershipSubPlanInfo[];
}
/**
 * @api_path: /api/membership/get-base-info
 * @method: GET
 * @content-type: application/json
 * @summary: 获取用户会员基础信息
 *
 * @generated from protobuf message membership.GetBaseInfoRequest
 */
export interface GetBaseInfoRequest {
}
/**
 * @generated from protobuf message membership.GetBaseInfoResponse
 */
export interface GetBaseInfoResponse {
    /**
     * @generated from protobuf field: membership.UserMembershipBaseInfo baseInfo = 1
     */
    baseInfo?: UserMembershipBaseInfo;
}
/**
 * @api_path: /api/membership/get-info
 * @method: GET
 * @content-type: application/json
 * @summary: 获取用户会员信息
 *
 * @generated from protobuf message membership.GetInfoRequest
 */
export interface GetInfoRequest {
}
/**
 * @generated from protobuf message membership.GetInfoResponse
 */
export interface GetInfoResponse {
    /**
     * @generated from protobuf field: membership.UserMembershipInfo info = 1
     */
    info?: UserMembershipInfo;
}
/**
 * @api_path: /api/membership/user/profile
 * @method: GET
 * @content-type: application/json
 * @summary: 前端获取用户信息和会员信息
 *
 * @generated from protobuf message membership.GetMembershipProfileRequest
 */
export interface GetMembershipProfileRequest {
}
/**
 * @generated from protobuf message membership.GetMembershipProfileResponse
 */
export interface GetMembershipProfileResponse {
    /**
     * @generated from protobuf field: user.User user = 1
     */
    user?: User;
    /**
     * @generated from protobuf field: membership.UserMembershipInfo info = 2
     */
    info?: UserMembershipInfo;
}
/**
 * @api_path: /api/membership/get-login-page-config
 * @method: GET
 * @content-type: application/json
 * @summary: 获取登录页面配置
 *
 * @generated from protobuf message membership.GetLoginPageConfigRequest
 */
export interface GetLoginPageConfigRequest {
}
/**
 * @generated from protobuf message membership.GetLoginPageConfigResponse
 */
export interface GetLoginPageConfigResponse {
    /**
     * @generated from protobuf field: bool isGoogleLoginEnabled = 1
     */
    isGoogleLoginEnabled: boolean;
    /**
     * @generated from protobuf field: bool isUsernamePasswordLoginEnabled = 2
     */
    isUsernamePasswordLoginEnabled: boolean;
    /**
     * @generated from protobuf field: bool isRegisterEnabled = 3
     */
    isRegisterEnabled: boolean;
    /**
     * @generated from protobuf field: bool isForgetPasswordEnabled = 4
     */
    isForgetPasswordEnabled: boolean;
}
/**
 * @api_path: /api/membership/get-user-credit
 * @method: GET
 * @content-type: application/json
 * @summary: 获取用户积分
 *
 * @generated from protobuf message membership.GetUserCreditRequest
 */
export interface GetUserCreditRequest {
}
/**
 * @generated from protobuf message membership.GetUserCreditResponse
 */
export interface GetUserCreditResponse {
    /**
     * @generated from protobuf field: uint64 credit = 1
     */
    credit: bigint;
    /**
     * @generated from protobuf field: uint64 addOnCredit = 2
     */
    addOnCredit: bigint;
}
/**
 * MembershipType 会员类型
 *
 * @generated from protobuf enum membership.MembershipType
 */
export enum MembershipType {
    /**
     * 未知
     *
     * @generated from protobuf enum value: MEMBERSHIP_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Free
     *
     * @generated from protobuf enum value: MEMBERSHIP_TYPE_FREE = 1;
     */
    FREE = 1,
    /**
     * PRO
     *
     * @generated from protobuf enum value: MEMBERSHIP_TYPE_PRO = 2;
     */
    PRO = 2
}
/**
 * CreditType 积分类型
 *
 * @generated from protobuf enum membership.CreditType
 */
export enum CreditType {
    /**
     * 未知
     *
     * @generated from protobuf enum value: CREDIT_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * 积分
     *
     * @generated from protobuf enum value: CREDIT_TYPE_CREDIT = 1;
     */
    CREDIT = 1,
    /**
     * 附加积分
     *
     * @generated from protobuf enum value: CREDIT_TYPE_ADD_ON_CREDIT = 2;
     */
    ADD_ON_CREDIT = 2
}
/**
 * CreditInOutType 积分收支类型
 *
 * @generated from protobuf enum membership.CreditInOutType
 */
export enum CreditInOutType {
    /**
     * 未知
     *
     * @generated from protobuf enum value: CREDIT_IN_OUT_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * 收入
     *
     * @generated from protobuf enum value: CREDIT_IN_OUT_TYPE_INCOME = 1;
     */
    INCOME = 1,
    /**
     * 支出
     *
     * @generated from protobuf enum value: CREDIT_IN_OUT_TYPE_EXPENSE = 2;
     */
    EXPENSE = 2
}
/**
 * CreditPayType 积分支付类型
 *
 * @generated from protobuf enum membership.CreditPayType
 */
export enum CreditPayType {
    /**
     * 未知或者错误
     *
     * @generated from protobuf enum value: CREDIT_PAY_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * 系统操作与生命周期管理 (1-99)
     *
     * 积分过期
     *
     * @generated from protobuf enum value: CREDIT_PAY_TYPE_EXPIRED = 1;
     */
    EXPIRED = 1,
    /**
     * 会员订阅与套餐相关 (100-199)
     *
     * Free会员订阅
     *
     * @generated from protobuf enum value: CREDIT_PAY_TYPE_SUB_FREE = 101;
     */
    SUB_FREE = 101,
    /**
     * PRO会员订阅
     *
     * @generated from protobuf enum value: CREDIT_PAY_TYPE_SUB_PRO = 102;
     */
    SUB_PRO = 102,
    /**
     * PRO版附加积分包订阅
     *
     * @generated from protobuf enum value: CREDIT_PAY_TYPE_SUB_PRO_ADD_ON_CREDIT = 103;
     */
    SUB_PRO_ADD_ON_CREDIT = 103,
    /**
     * 功能服务消费使用 (200-299)
     *
     * 功能服务消费使用
     *
     * @generated from protobuf enum value: CREDIT_PAY_TYPE_SERVICE_COST = 201;
     */
    SERVICE_COST = 201,
    /**
     * 功能服务退还
     *
     * @generated from protobuf enum value: CREDIT_PAY_TYPE_SERVICE_RETRIEVE = 202;
     */
    SERVICE_RETRIEVE = 202
}
/**
 * CreditPaymentStatus 积分支付状态 (采用二阶段提交模式)
 *
 * @generated from protobuf enum membership.CreditPaymentStatus
 */
export enum CreditPaymentStatus {
    /**
     * 未知
     *
     * @generated from protobuf enum value: CREDIT_PAYMENT_STATUS_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * 待处理 (新创建)
     *
     * @generated from protobuf enum value: CREDIT_PAYMENT_STATUS_PAY_PENDING = 1;
     */
    PAY_PENDING = 1,
    /**
     * 等待业务确认 (积分已预扣)
     *
     * @generated from protobuf enum value: CREDIT_PAYMENT_STATUS_PAY_AWAITING_CONFIRMATION = 2;
     */
    PAY_AWAITING_CONFIRMATION = 2,
    /**
     * 支付成功(业务已确认)
     *
     * @generated from protobuf enum value: CREDIT_PAYMENT_STATUS_PAY_SUCCESS = 3;
     */
    PAY_SUCCESS = 3,
    /**
     * 支付失败(如积分不足导致预扣失败)
     *
     * @generated from protobuf enum value: CREDIT_PAYMENT_STATUS_PAY_FAILED = 4;
     */
    PAY_FAILED = 4,
    /**
     * 已取消(业务已回滚)
     *
     * @generated from protobuf enum value: CREDIT_PAYMENT_STATUS_PAY_CANCELLED = 5;
     */
    PAY_CANCELLED = 5
}
/**
 * CreditServiceType 积分功能类型
 *
 * @generated from protobuf enum membership.CreditServiceType
 */
export enum CreditServiceType {
    /**
     * 未知
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * 文档上传
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_DOCS_UPLOAD = 101;
     */
    DOCS_UPLOAD = 101,
    /**
     * 笔记功能
     *
     * 笔记总结功能
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_NOTE_SUMMARY = 201;
     */
    NOTE_SUMMARY = 201,
    /**
     * 笔记单词功能
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_NOTE_WORD = 202;
     */
    NOTE_WORD = 202,
    /**
     * 笔记标注功能
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_NOTE_EXTRACT = 203;
     */
    NOTE_EXTRACT = 203,
    /**
     * 笔记管理功能
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_NOTE_MANAGE = 204;
     */
    NOTE_MANAGE = 204,
    /**
     * 笔记PDF下载功能
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_NOTE_PDF_DOWNLOAD = 205;
     */
    NOTE_PDF_DOWNLOAD = 205,
    /**
     * AI功能
     *
     * AI辅读
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_AI_COPILOT = 301;
     */
    AI_COPILOT = 301,
    /**
     * 翻译功能
     *
     * OCR翻译
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_TRANSLATE_OCR = 401;
     */
    TRANSLATE_OCR = 401,
    /**
     * 单词翻译
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_TRANSLATE_WORD = 402;
     */
    TRANSLATE_WORD = 402,
    /**
     * 全文翻译
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_TRANSLATE_FULLTEXT = 403;
     */
    TRANSLATE_FULLTEXT = 403,
    /**
     * AI翻译
     *
     * @generated from protobuf enum value: CREDIT_SERVICE_TYPE_TRANSLATE_AI = 404;
     */
    TRANSLATE_AI = 404
}
// @generated message type with reflection information, may provide speed optimized methods
class SubInfo$Type extends MessageType<SubInfo> {
    constructor() {
        super("membership.SubInfo", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "price", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "originalPrice", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "credit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "originalCredit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "addOnCredit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "duration", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "stripePayMode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "stripePriceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubInfo>): SubInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.name = "";
        message.price = 0n;
        message.originalPrice = 0n;
        message.currency = "";
        message.credit = 0n;
        message.originalCredit = 0n;
        message.addOnCredit = 0n;
        message.duration = 0;
        message.stripePayMode = "";
        message.stripePriceId = "";
        if (value !== undefined)
            reflectionMergePartial<SubInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubInfo): SubInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* uint64 price */ 3:
                    message.price = reader.uint64().toBigInt();
                    break;
                case /* uint64 originalPrice */ 4:
                    message.originalPrice = reader.uint64().toBigInt();
                    break;
                case /* string currency */ 5:
                    message.currency = reader.string();
                    break;
                case /* uint64 credit */ 6:
                    message.credit = reader.uint64().toBigInt();
                    break;
                case /* uint64 originalCredit */ 7:
                    message.originalCredit = reader.uint64().toBigInt();
                    break;
                case /* uint64 addOnCredit */ 8:
                    message.addOnCredit = reader.uint64().toBigInt();
                    break;
                case /* uint32 duration */ 9:
                    message.duration = reader.uint32();
                    break;
                case /* string stripePayMode */ 10:
                    message.stripePayMode = reader.string();
                    break;
                case /* string stripePriceId */ 11:
                    message.stripePriceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* uint64 price = 3; */
        if (message.price !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.price);
        /* uint64 originalPrice = 4; */
        if (message.originalPrice !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.originalPrice);
        /* string currency = 5; */
        if (message.currency !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.currency);
        /* uint64 credit = 6; */
        if (message.credit !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.credit);
        /* uint64 originalCredit = 7; */
        if (message.originalCredit !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.originalCredit);
        /* uint64 addOnCredit = 8; */
        if (message.addOnCredit !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.addOnCredit);
        /* uint32 duration = 9; */
        if (message.duration !== 0)
            writer.tag(9, WireType.Varint).uint32(message.duration);
        /* string stripePayMode = 10; */
        if (message.stripePayMode !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.stripePayMode);
        /* string stripePriceId = 11; */
        if (message.stripePriceId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.stripePriceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.SubInfo
 */
export const SubInfo = new SubInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasePermission$Type extends MessageType<BasePermission> {
    constructor() {
        super("membership.BasePermission", [
            { no: 1, name: "subInfo", kind: "message", T: () => SubInfo },
            { no: 2, name: "isEnableAddOnCredit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "isEnableSubAddOnCredit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "maxAddOnCreditSubCountOfMonth", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "subAddOnCreditInfo", kind: "message", T: () => SubInfo }
        ]);
    }
    create(value?: PartialMessage<BasePermission>): BasePermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isEnableAddOnCredit = false;
        message.isEnableSubAddOnCredit = false;
        message.maxAddOnCreditSubCountOfMonth = 0;
        if (value !== undefined)
            reflectionMergePartial<BasePermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasePermission): BasePermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* membership.SubInfo subInfo */ 1:
                    message.subInfo = SubInfo.internalBinaryRead(reader, reader.uint32(), options, message.subInfo);
                    break;
                case /* bool isEnableAddOnCredit */ 2:
                    message.isEnableAddOnCredit = reader.bool();
                    break;
                case /* bool isEnableSubAddOnCredit */ 3:
                    message.isEnableSubAddOnCredit = reader.bool();
                    break;
                case /* uint32 maxAddOnCreditSubCountOfMonth */ 4:
                    message.maxAddOnCreditSubCountOfMonth = reader.uint32();
                    break;
                case /* membership.SubInfo subAddOnCreditInfo */ 5:
                    message.subAddOnCreditInfo = SubInfo.internalBinaryRead(reader, reader.uint32(), options, message.subAddOnCreditInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasePermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* membership.SubInfo subInfo = 1; */
        if (message.subInfo)
            SubInfo.internalBinaryWrite(message.subInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool isEnableAddOnCredit = 2; */
        if (message.isEnableAddOnCredit !== false)
            writer.tag(2, WireType.Varint).bool(message.isEnableAddOnCredit);
        /* bool isEnableSubAddOnCredit = 3; */
        if (message.isEnableSubAddOnCredit !== false)
            writer.tag(3, WireType.Varint).bool(message.isEnableSubAddOnCredit);
        /* uint32 maxAddOnCreditSubCountOfMonth = 4; */
        if (message.maxAddOnCreditSubCountOfMonth !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maxAddOnCreditSubCountOfMonth);
        /* membership.SubInfo subAddOnCreditInfo = 5; */
        if (message.subAddOnCreditInfo)
            SubInfo.internalBinaryWrite(message.subAddOnCreditInfo, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.BasePermission
 */
export const BasePermission = new BasePermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocsPermission$Type extends MessageType<DocsPermission> {
    constructor() {
        super("membership.DocsPermission", [
            { no: 1, name: "maxStorageCapacity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "maxStorageCapacityOriginal", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "docUploadMaxSize", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "docUploadMaxSizeOriginal", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "docUploadMaxPageCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "docUploadMaxPageCountOriginal", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DocsPermission>): DocsPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxStorageCapacity = 0n;
        message.maxStorageCapacityOriginal = 0n;
        message.docUploadMaxSize = 0n;
        message.docUploadMaxSizeOriginal = 0n;
        message.docUploadMaxPageCount = 0;
        message.docUploadMaxPageCountOriginal = 0;
        if (value !== undefined)
            reflectionMergePartial<DocsPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocsPermission): DocsPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 maxStorageCapacity */ 1:
                    message.maxStorageCapacity = reader.uint64().toBigInt();
                    break;
                case /* uint64 maxStorageCapacityOriginal */ 2:
                    message.maxStorageCapacityOriginal = reader.uint64().toBigInt();
                    break;
                case /* uint64 docUploadMaxSize */ 3:
                    message.docUploadMaxSize = reader.uint64().toBigInt();
                    break;
                case /* uint64 docUploadMaxSizeOriginal */ 4:
                    message.docUploadMaxSizeOriginal = reader.uint64().toBigInt();
                    break;
                case /* uint32 docUploadMaxPageCount */ 5:
                    message.docUploadMaxPageCount = reader.uint32();
                    break;
                case /* uint32 docUploadMaxPageCountOriginal */ 6:
                    message.docUploadMaxPageCountOriginal = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocsPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 maxStorageCapacity = 1; */
        if (message.maxStorageCapacity !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.maxStorageCapacity);
        /* uint64 maxStorageCapacityOriginal = 2; */
        if (message.maxStorageCapacityOriginal !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.maxStorageCapacityOriginal);
        /* uint64 docUploadMaxSize = 3; */
        if (message.docUploadMaxSize !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.docUploadMaxSize);
        /* uint64 docUploadMaxSizeOriginal = 4; */
        if (message.docUploadMaxSizeOriginal !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.docUploadMaxSizeOriginal);
        /* uint32 docUploadMaxPageCount = 5; */
        if (message.docUploadMaxPageCount !== 0)
            writer.tag(5, WireType.Varint).uint32(message.docUploadMaxPageCount);
        /* uint32 docUploadMaxPageCountOriginal = 6; */
        if (message.docUploadMaxPageCountOriginal !== 0)
            writer.tag(6, WireType.Varint).uint32(message.docUploadMaxPageCountOriginal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.DocsPermission
 */
export const DocsPermission = new DocsPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NotePermission$Type extends MessageType<NotePermission> {
    constructor() {
        super("membership.NotePermission", [
            { no: 1, name: "isNoteSummary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "isNoteWord", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "isNoteExtract", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "isNoteManage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "isNotePdfDownload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<NotePermission>): NotePermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isNoteSummary = false;
        message.isNoteWord = false;
        message.isNoteExtract = false;
        message.isNoteManage = false;
        message.isNotePdfDownload = false;
        if (value !== undefined)
            reflectionMergePartial<NotePermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NotePermission): NotePermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isNoteSummary */ 1:
                    message.isNoteSummary = reader.bool();
                    break;
                case /* bool isNoteWord */ 2:
                    message.isNoteWord = reader.bool();
                    break;
                case /* bool isNoteExtract */ 3:
                    message.isNoteExtract = reader.bool();
                    break;
                case /* bool isNoteManage */ 4:
                    message.isNoteManage = reader.bool();
                    break;
                case /* bool isNotePdfDownload */ 5:
                    message.isNotePdfDownload = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NotePermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isNoteSummary = 1; */
        if (message.isNoteSummary !== false)
            writer.tag(1, WireType.Varint).bool(message.isNoteSummary);
        /* bool isNoteWord = 2; */
        if (message.isNoteWord !== false)
            writer.tag(2, WireType.Varint).bool(message.isNoteWord);
        /* bool isNoteExtract = 3; */
        if (message.isNoteExtract !== false)
            writer.tag(3, WireType.Varint).bool(message.isNoteExtract);
        /* bool isNoteManage = 4; */
        if (message.isNoteManage !== false)
            writer.tag(4, WireType.Varint).bool(message.isNoteManage);
        /* bool isNotePdfDownload = 5; */
        if (message.isNotePdfDownload !== false)
            writer.tag(5, WireType.Varint).bool(message.isNotePdfDownload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.NotePermission
 */
export const NotePermission = new NotePermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopilotModel$Type extends MessageType<CopilotModel> {
    constructor() {
        super("membership.CopilotModel", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "isEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "isFree", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "creditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CopilotModel>): CopilotModel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.name = "";
        message.isEnable = false;
        message.isFree = false;
        message.creditCost = 0n;
        if (value !== undefined)
            reflectionMergePartial<CopilotModel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopilotModel): CopilotModel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool isEnable */ 3:
                    message.isEnable = reader.bool();
                    break;
                case /* bool isFree */ 4:
                    message.isFree = reader.bool();
                    break;
                case /* uint64 creditCost */ 5:
                    message.creditCost = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopilotModel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool isEnable = 3; */
        if (message.isEnable !== false)
            writer.tag(3, WireType.Varint).bool(message.isEnable);
        /* bool isFree = 4; */
        if (message.isFree !== false)
            writer.tag(4, WireType.Varint).bool(message.isFree);
        /* uint64 creditCost = 5; */
        if (message.creditCost !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.creditCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.CopilotModel
 */
export const CopilotModel = new CopilotModel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopilotPermission$Type extends MessageType<CopilotPermission> {
    constructor() {
        super("membership.CopilotPermission", [
            { no: 1, name: "isEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "models", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CopilotModel }
        ]);
    }
    create(value?: PartialMessage<CopilotPermission>): CopilotPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isEnable = false;
        message.models = [];
        if (value !== undefined)
            reflectionMergePartial<CopilotPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopilotPermission): CopilotPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isEnable */ 1:
                    message.isEnable = reader.bool();
                    break;
                case /* repeated membership.CopilotModel models */ 2:
                    message.models.push(CopilotModel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopilotPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isEnable = 1; */
        if (message.isEnable !== false)
            writer.tag(1, WireType.Varint).bool(message.isEnable);
        /* repeated membership.CopilotModel models = 2; */
        for (let i = 0; i < message.models.length; i++)
            CopilotModel.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.CopilotPermission
 */
export const CopilotPermission = new CopilotPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AIPermission$Type extends MessageType<AIPermission> {
    constructor() {
        super("membership.AIPermission", [
            { no: 1, name: "copilot", kind: "message", T: () => CopilotPermission }
        ]);
    }
    create(value?: PartialMessage<AIPermission>): AIPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AIPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AIPermission): AIPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* membership.CopilotPermission copilot */ 1:
                    message.copilot = CopilotPermission.internalBinaryRead(reader, reader.uint32(), options, message.copilot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AIPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* membership.CopilotPermission copilot = 1; */
        if (message.copilot)
            CopilotPermission.internalBinaryWrite(message.copilot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.AIPermission
 */
export const AIPermission = new AIPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslatePermission$Type extends MessageType<TranslatePermission> {
    constructor() {
        super("membership.TranslatePermission", [
            { no: 1, name: "isOcr", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "ocrCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "isWordTranslate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "wordTranslateCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "isFullTextTranslate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "fullTextTranslateCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "fullTextTranslateCreditCostOriginal", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "fullTextTranslateMaxPageCount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "isAiTranslation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "aiTranslationCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TranslatePermission>): TranslatePermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isOcr = false;
        message.ocrCreditCost = 0n;
        message.isWordTranslate = false;
        message.wordTranslateCreditCost = 0n;
        message.isFullTextTranslate = false;
        message.fullTextTranslateCreditCost = 0n;
        message.fullTextTranslateCreditCostOriginal = 0n;
        message.fullTextTranslateMaxPageCount = 0n;
        message.isAiTranslation = false;
        message.aiTranslationCreditCost = 0n;
        if (value !== undefined)
            reflectionMergePartial<TranslatePermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslatePermission): TranslatePermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isOcr */ 1:
                    message.isOcr = reader.bool();
                    break;
                case /* uint64 ocrCreditCost */ 2:
                    message.ocrCreditCost = reader.uint64().toBigInt();
                    break;
                case /* bool isWordTranslate */ 3:
                    message.isWordTranslate = reader.bool();
                    break;
                case /* uint64 wordTranslateCreditCost */ 4:
                    message.wordTranslateCreditCost = reader.uint64().toBigInt();
                    break;
                case /* bool isFullTextTranslate */ 5:
                    message.isFullTextTranslate = reader.bool();
                    break;
                case /* uint64 fullTextTranslateCreditCost */ 6:
                    message.fullTextTranslateCreditCost = reader.uint64().toBigInt();
                    break;
                case /* uint64 fullTextTranslateCreditCostOriginal */ 7:
                    message.fullTextTranslateCreditCostOriginal = reader.uint64().toBigInt();
                    break;
                case /* uint64 fullTextTranslateMaxPageCount */ 8:
                    message.fullTextTranslateMaxPageCount = reader.uint64().toBigInt();
                    break;
                case /* bool isAiTranslation */ 9:
                    message.isAiTranslation = reader.bool();
                    break;
                case /* uint64 aiTranslationCreditCost */ 10:
                    message.aiTranslationCreditCost = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslatePermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isOcr = 1; */
        if (message.isOcr !== false)
            writer.tag(1, WireType.Varint).bool(message.isOcr);
        /* uint64 ocrCreditCost = 2; */
        if (message.ocrCreditCost !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.ocrCreditCost);
        /* bool isWordTranslate = 3; */
        if (message.isWordTranslate !== false)
            writer.tag(3, WireType.Varint).bool(message.isWordTranslate);
        /* uint64 wordTranslateCreditCost = 4; */
        if (message.wordTranslateCreditCost !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.wordTranslateCreditCost);
        /* bool isFullTextTranslate = 5; */
        if (message.isFullTextTranslate !== false)
            writer.tag(5, WireType.Varint).bool(message.isFullTextTranslate);
        /* uint64 fullTextTranslateCreditCost = 6; */
        if (message.fullTextTranslateCreditCost !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.fullTextTranslateCreditCost);
        /* uint64 fullTextTranslateCreditCostOriginal = 7; */
        if (message.fullTextTranslateCreditCostOriginal !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.fullTextTranslateCreditCostOriginal);
        /* uint64 fullTextTranslateMaxPageCount = 8; */
        if (message.fullTextTranslateMaxPageCount !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.fullTextTranslateMaxPageCount);
        /* bool isAiTranslation = 9; */
        if (message.isAiTranslation !== false)
            writer.tag(9, WireType.Varint).bool(message.isAiTranslation);
        /* uint64 aiTranslationCreditCost = 10; */
        if (message.aiTranslationCreditCost !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.aiTranslationCreditCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.TranslatePermission
 */
export const TranslatePermission = new TranslatePermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserBasePermission$Type extends MessageType<UserBasePermission> {
    constructor() {
        super("membership.UserBasePermission", [
            { no: 2, name: "isEnableAddOnCredit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "isEnableSubAddOnCredit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UserBasePermission>): UserBasePermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isEnableAddOnCredit = false;
        message.isEnableSubAddOnCredit = false;
        if (value !== undefined)
            reflectionMergePartial<UserBasePermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserBasePermission): UserBasePermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isEnableAddOnCredit */ 2:
                    message.isEnableAddOnCredit = reader.bool();
                    break;
                case /* bool isEnableSubAddOnCredit */ 3:
                    message.isEnableSubAddOnCredit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserBasePermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isEnableAddOnCredit = 2; */
        if (message.isEnableAddOnCredit !== false)
            writer.tag(2, WireType.Varint).bool(message.isEnableAddOnCredit);
        /* bool isEnableSubAddOnCredit = 3; */
        if (message.isEnableSubAddOnCredit !== false)
            writer.tag(3, WireType.Varint).bool(message.isEnableSubAddOnCredit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserBasePermission
 */
export const UserBasePermission = new UserBasePermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocsPermission$Type extends MessageType<UserDocsPermission> {
    constructor() {
        super("membership.UserDocsPermission", [
            { no: 1, name: "maxStorageCapacity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "docUploadMaxSize", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "docUploadMaxPageCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "useStorageCapacity", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocsPermission>): UserDocsPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxStorageCapacity = 0n;
        message.docUploadMaxSize = 0n;
        message.docUploadMaxPageCount = 0;
        message.useStorageCapacity = 0n;
        if (value !== undefined)
            reflectionMergePartial<UserDocsPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocsPermission): UserDocsPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 maxStorageCapacity */ 1:
                    message.maxStorageCapacity = reader.uint64().toBigInt();
                    break;
                case /* uint64 docUploadMaxSize */ 2:
                    message.docUploadMaxSize = reader.uint64().toBigInt();
                    break;
                case /* uint32 docUploadMaxPageCount */ 3:
                    message.docUploadMaxPageCount = reader.uint32();
                    break;
                case /* uint64 useStorageCapacity */ 4:
                    message.useStorageCapacity = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocsPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 maxStorageCapacity = 1; */
        if (message.maxStorageCapacity !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.maxStorageCapacity);
        /* uint64 docUploadMaxSize = 2; */
        if (message.docUploadMaxSize !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.docUploadMaxSize);
        /* uint32 docUploadMaxPageCount = 3; */
        if (message.docUploadMaxPageCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.docUploadMaxPageCount);
        /* uint64 useStorageCapacity = 4; */
        if (message.useStorageCapacity !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.useStorageCapacity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserDocsPermission
 */
export const UserDocsPermission = new UserDocsPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserNotePermission$Type extends MessageType<UserNotePermission> {
    constructor() {
        super("membership.UserNotePermission", [
            { no: 1, name: "isNoteSummary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "isNoteWord", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "isNoteExtract", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "isNoteManage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "isNotePdfDownload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UserNotePermission>): UserNotePermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isNoteSummary = false;
        message.isNoteWord = false;
        message.isNoteExtract = false;
        message.isNoteManage = false;
        message.isNotePdfDownload = false;
        if (value !== undefined)
            reflectionMergePartial<UserNotePermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserNotePermission): UserNotePermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isNoteSummary */ 1:
                    message.isNoteSummary = reader.bool();
                    break;
                case /* bool isNoteWord */ 2:
                    message.isNoteWord = reader.bool();
                    break;
                case /* bool isNoteExtract */ 3:
                    message.isNoteExtract = reader.bool();
                    break;
                case /* bool isNoteManage */ 4:
                    message.isNoteManage = reader.bool();
                    break;
                case /* bool isNotePdfDownload */ 5:
                    message.isNotePdfDownload = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserNotePermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isNoteSummary = 1; */
        if (message.isNoteSummary !== false)
            writer.tag(1, WireType.Varint).bool(message.isNoteSummary);
        /* bool isNoteWord = 2; */
        if (message.isNoteWord !== false)
            writer.tag(2, WireType.Varint).bool(message.isNoteWord);
        /* bool isNoteExtract = 3; */
        if (message.isNoteExtract !== false)
            writer.tag(3, WireType.Varint).bool(message.isNoteExtract);
        /* bool isNoteManage = 4; */
        if (message.isNoteManage !== false)
            writer.tag(4, WireType.Varint).bool(message.isNoteManage);
        /* bool isNotePdfDownload = 5; */
        if (message.isNotePdfDownload !== false)
            writer.tag(5, WireType.Varint).bool(message.isNotePdfDownload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserNotePermission
 */
export const UserNotePermission = new UserNotePermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserAIPermission$Type extends MessageType<UserAIPermission> {
    constructor() {
        super("membership.UserAIPermission", [
            { no: 1, name: "copilot", kind: "message", T: () => CopilotPermission }
        ]);
    }
    create(value?: PartialMessage<UserAIPermission>): UserAIPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserAIPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserAIPermission): UserAIPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* membership.CopilotPermission copilot */ 1:
                    message.copilot = CopilotPermission.internalBinaryRead(reader, reader.uint32(), options, message.copilot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserAIPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* membership.CopilotPermission copilot = 1; */
        if (message.copilot)
            CopilotPermission.internalBinaryWrite(message.copilot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserAIPermission
 */
export const UserAIPermission = new UserAIPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserTranslatePermission$Type extends MessageType<UserTranslatePermission> {
    constructor() {
        super("membership.UserTranslatePermission", [
            { no: 1, name: "isOcr", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "ocrCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "isWordTranslate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "wordTranslateCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "isFullTextTranslate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "fullTextTranslateCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "fullTextTranslateMaxPageCount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "isAiTranslation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "aiTranslationCreditCost", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UserTranslatePermission>): UserTranslatePermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isOcr = false;
        message.ocrCreditCost = 0n;
        message.isWordTranslate = false;
        message.wordTranslateCreditCost = 0n;
        message.isFullTextTranslate = false;
        message.fullTextTranslateCreditCost = 0n;
        message.fullTextTranslateMaxPageCount = 0n;
        message.isAiTranslation = false;
        message.aiTranslationCreditCost = 0n;
        if (value !== undefined)
            reflectionMergePartial<UserTranslatePermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserTranslatePermission): UserTranslatePermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isOcr */ 1:
                    message.isOcr = reader.bool();
                    break;
                case /* uint64 ocrCreditCost */ 2:
                    message.ocrCreditCost = reader.uint64().toBigInt();
                    break;
                case /* bool isWordTranslate */ 3:
                    message.isWordTranslate = reader.bool();
                    break;
                case /* uint64 wordTranslateCreditCost */ 4:
                    message.wordTranslateCreditCost = reader.uint64().toBigInt();
                    break;
                case /* bool isFullTextTranslate */ 5:
                    message.isFullTextTranslate = reader.bool();
                    break;
                case /* uint64 fullTextTranslateCreditCost */ 6:
                    message.fullTextTranslateCreditCost = reader.uint64().toBigInt();
                    break;
                case /* uint64 fullTextTranslateMaxPageCount */ 7:
                    message.fullTextTranslateMaxPageCount = reader.uint64().toBigInt();
                    break;
                case /* bool isAiTranslation */ 8:
                    message.isAiTranslation = reader.bool();
                    break;
                case /* uint64 aiTranslationCreditCost */ 9:
                    message.aiTranslationCreditCost = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserTranslatePermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isOcr = 1; */
        if (message.isOcr !== false)
            writer.tag(1, WireType.Varint).bool(message.isOcr);
        /* uint64 ocrCreditCost = 2; */
        if (message.ocrCreditCost !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.ocrCreditCost);
        /* bool isWordTranslate = 3; */
        if (message.isWordTranslate !== false)
            writer.tag(3, WireType.Varint).bool(message.isWordTranslate);
        /* uint64 wordTranslateCreditCost = 4; */
        if (message.wordTranslateCreditCost !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.wordTranslateCreditCost);
        /* bool isFullTextTranslate = 5; */
        if (message.isFullTextTranslate !== false)
            writer.tag(5, WireType.Varint).bool(message.isFullTextTranslate);
        /* uint64 fullTextTranslateCreditCost = 6; */
        if (message.fullTextTranslateCreditCost !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.fullTextTranslateCreditCost);
        /* uint64 fullTextTranslateMaxPageCount = 7; */
        if (message.fullTextTranslateMaxPageCount !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.fullTextTranslateMaxPageCount);
        /* bool isAiTranslation = 8; */
        if (message.isAiTranslation !== false)
            writer.tag(8, WireType.Varint).bool(message.isAiTranslation);
        /* uint64 aiTranslationCreditCost = 9; */
        if (message.aiTranslationCreditCost !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.aiTranslationCreditCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserTranslatePermission
 */
export const UserTranslatePermission = new UserTranslatePermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MembershipSubPlanInfo$Type extends MessageType<MembershipSubPlanInfo> {
    constructor() {
        super("membership.MembershipSubPlanInfo", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isFree", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "base", kind: "message", T: () => BasePermission },
            { no: 6, name: "docs", kind: "message", T: () => DocsPermission },
            { no: 7, name: "note", kind: "message", T: () => NotePermission },
            { no: 8, name: "ai", kind: "message", T: () => AIPermission },
            { no: 9, name: "translate", kind: "message", T: () => TranslatePermission }
        ]);
    }
    create(value?: PartialMessage<MembershipSubPlanInfo>): MembershipSubPlanInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.name = "";
        message.description = "";
        message.isFree = false;
        if (value !== undefined)
            reflectionMergePartial<MembershipSubPlanInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MembershipSubPlanInfo): MembershipSubPlanInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* bool isFree */ 4:
                    message.isFree = reader.bool();
                    break;
                case /* membership.BasePermission base */ 5:
                    message.base = BasePermission.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* membership.DocsPermission docs */ 6:
                    message.docs = DocsPermission.internalBinaryRead(reader, reader.uint32(), options, message.docs);
                    break;
                case /* membership.NotePermission note */ 7:
                    message.note = NotePermission.internalBinaryRead(reader, reader.uint32(), options, message.note);
                    break;
                case /* membership.AIPermission ai */ 8:
                    message.ai = AIPermission.internalBinaryRead(reader, reader.uint32(), options, message.ai);
                    break;
                case /* membership.TranslatePermission translate */ 9:
                    message.translate = TranslatePermission.internalBinaryRead(reader, reader.uint32(), options, message.translate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MembershipSubPlanInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* bool isFree = 4; */
        if (message.isFree !== false)
            writer.tag(4, WireType.Varint).bool(message.isFree);
        /* membership.BasePermission base = 5; */
        if (message.base)
            BasePermission.internalBinaryWrite(message.base, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* membership.DocsPermission docs = 6; */
        if (message.docs)
            DocsPermission.internalBinaryWrite(message.docs, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* membership.NotePermission note = 7; */
        if (message.note)
            NotePermission.internalBinaryWrite(message.note, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* membership.AIPermission ai = 8; */
        if (message.ai)
            AIPermission.internalBinaryWrite(message.ai, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* membership.TranslatePermission translate = 9; */
        if (message.translate)
            TranslatePermission.internalBinaryWrite(message.translate, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.MembershipSubPlanInfo
 */
export const MembershipSubPlanInfo = new MembershipSubPlanInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserMembershipBaseInfo$Type extends MessageType<UserMembershipBaseInfo> {
    constructor() {
        super("membership.UserMembershipBaseInfo", [
            { no: 1, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "typeName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "credit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "addOnCredit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "isExpired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "expiredDay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "startAt", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "endAt", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UserMembershipBaseInfo>): UserMembershipBaseInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.type = 0;
        message.typeName = "";
        message.credit = 0n;
        message.addOnCredit = 0n;
        message.isExpired = false;
        message.expiredDay = 0;
        message.startAt = 0n;
        message.endAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<UserMembershipBaseInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserMembershipBaseInfo): UserMembershipBaseInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string userId */ 1:
                    message.userId = reader.string();
                    break;
                case /* uint32 type */ 2:
                    message.type = reader.uint32();
                    break;
                case /* string typeName */ 3:
                    message.typeName = reader.string();
                    break;
                case /* uint64 credit */ 4:
                    message.credit = reader.uint64().toBigInt();
                    break;
                case /* uint64 addOnCredit */ 5:
                    message.addOnCredit = reader.uint64().toBigInt();
                    break;
                case /* bool isExpired */ 6:
                    message.isExpired = reader.bool();
                    break;
                case /* uint32 expiredDay */ 7:
                    message.expiredDay = reader.uint32();
                    break;
                case /* uint64 startAt */ 8:
                    message.startAt = reader.uint64().toBigInt();
                    break;
                case /* uint64 endAt */ 9:
                    message.endAt = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserMembershipBaseInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string userId = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* uint32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).uint32(message.type);
        /* string typeName = 3; */
        if (message.typeName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.typeName);
        /* uint64 credit = 4; */
        if (message.credit !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.credit);
        /* uint64 addOnCredit = 5; */
        if (message.addOnCredit !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.addOnCredit);
        /* bool isExpired = 6; */
        if (message.isExpired !== false)
            writer.tag(6, WireType.Varint).bool(message.isExpired);
        /* uint32 expiredDay = 7; */
        if (message.expiredDay !== 0)
            writer.tag(7, WireType.Varint).uint32(message.expiredDay);
        /* uint64 startAt = 8; */
        if (message.startAt !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.startAt);
        /* uint64 endAt = 9; */
        if (message.endAt !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.endAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserMembershipBaseInfo
 */
export const UserMembershipBaseInfo = new UserMembershipBaseInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserMembershipInfo$Type extends MessageType<UserMembershipInfo> {
    constructor() {
        super("membership.UserMembershipInfo", [
            { no: 1, name: "baseInfo", kind: "message", T: () => UserMembershipBaseInfo },
            { no: 2, name: "permission", kind: "message", T: () => UserPermission }
        ]);
    }
    create(value?: PartialMessage<UserMembershipInfo>): UserMembershipInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserMembershipInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserMembershipInfo): UserMembershipInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* membership.UserMembershipBaseInfo baseInfo */ 1:
                    message.baseInfo = UserMembershipBaseInfo.internalBinaryRead(reader, reader.uint32(), options, message.baseInfo);
                    break;
                case /* membership.UserPermission permission */ 2:
                    message.permission = UserPermission.internalBinaryRead(reader, reader.uint32(), options, message.permission);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserMembershipInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* membership.UserMembershipBaseInfo baseInfo = 1; */
        if (message.baseInfo)
            UserMembershipBaseInfo.internalBinaryWrite(message.baseInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* membership.UserPermission permission = 2; */
        if (message.permission)
            UserPermission.internalBinaryWrite(message.permission, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserMembershipInfo
 */
export const UserMembershipInfo = new UserMembershipInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserPermission$Type extends MessageType<UserPermission> {
    constructor() {
        super("membership.UserPermission", [
            { no: 1, name: "base", kind: "message", T: () => UserBasePermission },
            { no: 2, name: "docs", kind: "message", T: () => UserDocsPermission },
            { no: 3, name: "note", kind: "message", T: () => UserNotePermission },
            { no: 4, name: "ai", kind: "message", T: () => UserAIPermission },
            { no: 5, name: "translate", kind: "message", T: () => UserTranslatePermission }
        ]);
    }
    create(value?: PartialMessage<UserPermission>): UserPermission {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserPermission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserPermission): UserPermission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* membership.UserBasePermission base */ 1:
                    message.base = UserBasePermission.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* membership.UserDocsPermission docs */ 2:
                    message.docs = UserDocsPermission.internalBinaryRead(reader, reader.uint32(), options, message.docs);
                    break;
                case /* membership.UserNotePermission note */ 3:
                    message.note = UserNotePermission.internalBinaryRead(reader, reader.uint32(), options, message.note);
                    break;
                case /* membership.UserAIPermission ai */ 4:
                    message.ai = UserAIPermission.internalBinaryRead(reader, reader.uint32(), options, message.ai);
                    break;
                case /* membership.UserTranslatePermission translate */ 5:
                    message.translate = UserTranslatePermission.internalBinaryRead(reader, reader.uint32(), options, message.translate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserPermission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* membership.UserBasePermission base = 1; */
        if (message.base)
            UserBasePermission.internalBinaryWrite(message.base, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* membership.UserDocsPermission docs = 2; */
        if (message.docs)
            UserDocsPermission.internalBinaryWrite(message.docs, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* membership.UserNotePermission note = 3; */
        if (message.note)
            UserNotePermission.internalBinaryWrite(message.note, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* membership.UserAIPermission ai = 4; */
        if (message.ai)
            UserAIPermission.internalBinaryWrite(message.ai, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* membership.UserTranslatePermission translate = 5; */
        if (message.translate)
            UserTranslatePermission.internalBinaryWrite(message.translate, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.UserPermission
 */
export const UserPermission = new UserPermission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubPlanInfosRequest$Type extends MessageType<GetSubPlanInfosRequest> {
    constructor() {
        super("membership.GetSubPlanInfosRequest", []);
    }
    create(value?: PartialMessage<GetSubPlanInfosRequest>): GetSubPlanInfosRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSubPlanInfosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubPlanInfosRequest): GetSubPlanInfosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubPlanInfosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetSubPlanInfosRequest
 */
export const GetSubPlanInfosRequest = new GetSubPlanInfosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubPlanInfosResponse$Type extends MessageType<GetSubPlanInfosResponse> {
    constructor() {
        super("membership.GetSubPlanInfosResponse", [
            { no: 1, name: "subPlanInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MembershipSubPlanInfo }
        ]);
    }
    create(value?: PartialMessage<GetSubPlanInfosResponse>): GetSubPlanInfosResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subPlanInfos = [];
        if (value !== undefined)
            reflectionMergePartial<GetSubPlanInfosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubPlanInfosResponse): GetSubPlanInfosResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated membership.MembershipSubPlanInfo subPlanInfos */ 1:
                    message.subPlanInfos.push(MembershipSubPlanInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubPlanInfosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated membership.MembershipSubPlanInfo subPlanInfos = 1; */
        for (let i = 0; i < message.subPlanInfos.length; i++)
            MembershipSubPlanInfo.internalBinaryWrite(message.subPlanInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetSubPlanInfosResponse
 */
export const GetSubPlanInfosResponse = new GetSubPlanInfosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBaseInfoRequest$Type extends MessageType<GetBaseInfoRequest> {
    constructor() {
        super("membership.GetBaseInfoRequest", []);
    }
    create(value?: PartialMessage<GetBaseInfoRequest>): GetBaseInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetBaseInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBaseInfoRequest): GetBaseInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBaseInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetBaseInfoRequest
 */
export const GetBaseInfoRequest = new GetBaseInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBaseInfoResponse$Type extends MessageType<GetBaseInfoResponse> {
    constructor() {
        super("membership.GetBaseInfoResponse", [
            { no: 1, name: "baseInfo", kind: "message", T: () => UserMembershipBaseInfo }
        ]);
    }
    create(value?: PartialMessage<GetBaseInfoResponse>): GetBaseInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetBaseInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBaseInfoResponse): GetBaseInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* membership.UserMembershipBaseInfo baseInfo */ 1:
                    message.baseInfo = UserMembershipBaseInfo.internalBinaryRead(reader, reader.uint32(), options, message.baseInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBaseInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* membership.UserMembershipBaseInfo baseInfo = 1; */
        if (message.baseInfo)
            UserMembershipBaseInfo.internalBinaryWrite(message.baseInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetBaseInfoResponse
 */
export const GetBaseInfoResponse = new GetBaseInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoRequest$Type extends MessageType<GetInfoRequest> {
    constructor() {
        super("membership.GetInfoRequest", []);
    }
    create(value?: PartialMessage<GetInfoRequest>): GetInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoRequest): GetInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetInfoRequest
 */
export const GetInfoRequest = new GetInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoResponse$Type extends MessageType<GetInfoResponse> {
    constructor() {
        super("membership.GetInfoResponse", [
            { no: 1, name: "info", kind: "message", T: () => UserMembershipInfo }
        ]);
    }
    create(value?: PartialMessage<GetInfoResponse>): GetInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoResponse): GetInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* membership.UserMembershipInfo info */ 1:
                    message.info = UserMembershipInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* membership.UserMembershipInfo info = 1; */
        if (message.info)
            UserMembershipInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetInfoResponse
 */
export const GetInfoResponse = new GetInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMembershipProfileRequest$Type extends MessageType<GetMembershipProfileRequest> {
    constructor() {
        super("membership.GetMembershipProfileRequest", []);
    }
    create(value?: PartialMessage<GetMembershipProfileRequest>): GetMembershipProfileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMembershipProfileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMembershipProfileRequest): GetMembershipProfileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMembershipProfileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetMembershipProfileRequest
 */
export const GetMembershipProfileRequest = new GetMembershipProfileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMembershipProfileResponse$Type extends MessageType<GetMembershipProfileResponse> {
    constructor() {
        super("membership.GetMembershipProfileResponse", [
            { no: 1, name: "user", kind: "message", T: () => User },
            { no: 2, name: "info", kind: "message", T: () => UserMembershipInfo }
        ]);
    }
    create(value?: PartialMessage<GetMembershipProfileResponse>): GetMembershipProfileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMembershipProfileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMembershipProfileResponse): GetMembershipProfileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* user.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* membership.UserMembershipInfo info */ 2:
                    message.info = UserMembershipInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMembershipProfileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* user.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* membership.UserMembershipInfo info = 2; */
        if (message.info)
            UserMembershipInfo.internalBinaryWrite(message.info, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetMembershipProfileResponse
 */
export const GetMembershipProfileResponse = new GetMembershipProfileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLoginPageConfigRequest$Type extends MessageType<GetLoginPageConfigRequest> {
    constructor() {
        super("membership.GetLoginPageConfigRequest", []);
    }
    create(value?: PartialMessage<GetLoginPageConfigRequest>): GetLoginPageConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetLoginPageConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLoginPageConfigRequest): GetLoginPageConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLoginPageConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetLoginPageConfigRequest
 */
export const GetLoginPageConfigRequest = new GetLoginPageConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLoginPageConfigResponse$Type extends MessageType<GetLoginPageConfigResponse> {
    constructor() {
        super("membership.GetLoginPageConfigResponse", [
            { no: 1, name: "isGoogleLoginEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "isUsernamePasswordLoginEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "isRegisterEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "isForgetPasswordEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetLoginPageConfigResponse>): GetLoginPageConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isGoogleLoginEnabled = false;
        message.isUsernamePasswordLoginEnabled = false;
        message.isRegisterEnabled = false;
        message.isForgetPasswordEnabled = false;
        if (value !== undefined)
            reflectionMergePartial<GetLoginPageConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLoginPageConfigResponse): GetLoginPageConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isGoogleLoginEnabled */ 1:
                    message.isGoogleLoginEnabled = reader.bool();
                    break;
                case /* bool isUsernamePasswordLoginEnabled */ 2:
                    message.isUsernamePasswordLoginEnabled = reader.bool();
                    break;
                case /* bool isRegisterEnabled */ 3:
                    message.isRegisterEnabled = reader.bool();
                    break;
                case /* bool isForgetPasswordEnabled */ 4:
                    message.isForgetPasswordEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLoginPageConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isGoogleLoginEnabled = 1; */
        if (message.isGoogleLoginEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.isGoogleLoginEnabled);
        /* bool isUsernamePasswordLoginEnabled = 2; */
        if (message.isUsernamePasswordLoginEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.isUsernamePasswordLoginEnabled);
        /* bool isRegisterEnabled = 3; */
        if (message.isRegisterEnabled !== false)
            writer.tag(3, WireType.Varint).bool(message.isRegisterEnabled);
        /* bool isForgetPasswordEnabled = 4; */
        if (message.isForgetPasswordEnabled !== false)
            writer.tag(4, WireType.Varint).bool(message.isForgetPasswordEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetLoginPageConfigResponse
 */
export const GetLoginPageConfigResponse = new GetLoginPageConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserCreditRequest$Type extends MessageType<GetUserCreditRequest> {
    constructor() {
        super("membership.GetUserCreditRequest", []);
    }
    create(value?: PartialMessage<GetUserCreditRequest>): GetUserCreditRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetUserCreditRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserCreditRequest): GetUserCreditRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserCreditRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetUserCreditRequest
 */
export const GetUserCreditRequest = new GetUserCreditRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserCreditResponse$Type extends MessageType<GetUserCreditResponse> {
    constructor() {
        super("membership.GetUserCreditResponse", [
            { no: 1, name: "credit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "addOnCredit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserCreditResponse>): GetUserCreditResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credit = 0n;
        message.addOnCredit = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetUserCreditResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserCreditResponse): GetUserCreditResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 credit */ 1:
                    message.credit = reader.uint64().toBigInt();
                    break;
                case /* uint64 addOnCredit */ 2:
                    message.addOnCredit = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserCreditResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 credit = 1; */
        if (message.credit !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.credit);
        /* uint64 addOnCredit = 2; */
        if (message.addOnCredit !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.addOnCredit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message membership.GetUserCreditResponse
 */
export const GetUserCreditResponse = new GetUserCreditResponse$Type();
