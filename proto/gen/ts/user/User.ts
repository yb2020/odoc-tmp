// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/user/User.proto" (package "user", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UserStatus } from "./UserStatus";
import { UserRole } from "./UserRole";
/**
 * 用户模型
 *
 * @generated from protobuf message user.User
 */
export interface User {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: string email = 3
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 4
     */
    password: string; // 注意：在实际响应中不会返回密码
    /**
     * @generated from protobuf field: string nickname = 5
     */
    nickname: string;
    /**
     * @generated from protobuf field: string avatar = 6
     */
    avatar: string;
    /**
     * @generated from protobuf field: repeated user.UserRole roles = 7
     */
    roles: UserRole[];
    /**
     * @generated from protobuf field: string accessToken = 8
     */
    accessToken: string;
    /**
     * @generated from protobuf field: uint64 accessTokenExpires = 9
     */
    accessTokenExpires: bigint;
    /**
     * @generated from protobuf field: string refreshToken = 10
     */
    refreshToken: string;
    /**
     * @generated from protobuf field: uint64 refreshTokenExpires = 11
     */
    refreshTokenExpires: bigint;
    /**
     * @generated from protobuf field: uint64 lastLogin = 12
     */
    lastLogin: bigint;
    /**
     * @generated from protobuf field: string googleOpenId = 13
     */
    googleOpenId: string;
    /**
     * @generated from protobuf field: user.UserStatus status = 14
     */
    status: UserStatus;
}
/**
 * @api_path: /api/user/profile
 * @method: GET
 * @content-type: application/json
 * @summary: 前端获取用户信息
 *
 * @generated from protobuf message user.GetProfileRequest
 */
export interface GetProfileRequest {
}
/**
 * @generated from protobuf message user.GetProfileResponse
 */
export interface GetProfileResponse {
    /**
     * @generated from protobuf field: user.User user = 1
     */
    user?: User;
}
/**
 * @api_path: /api/user/email/exists
 * @method: GET
 * @content-type: application/json
 * @summary: 检查用户是否存在
 *
 * @generated from protobuf message user.GetExistsByEmailRequest
 */
export interface GetExistsByEmailRequest {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string;
}
/**
 * @generated from protobuf message user.GetExistsByEmailResponse
 */
export interface GetExistsByEmailResponse {
    /**
     * @generated from protobuf field: bool exists = 1
     */
    exists: boolean;
}
/**
 * @api_path: /api/user/register
 * @method: POST
 * @content-type: application/json
 * @summary: 用户注册
 *
 * @generated from protobuf message user.RegisterRequest
 */
export interface RegisterRequest {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
}
/**
 * @generated from protobuf message user.RegisterResponse
 */
export interface RegisterResponse {
    /**
     * @generated from protobuf field: user.User user = 1
     */
    user?: User;
}
/**
 * @api_path: /api/user/profile/update
 * @method: POST
 * @content-type: application/json
 * @summary: 更新用户信息
 *
 * @generated from protobuf message user.UpdateProfileRequest
 */
export interface UpdateProfileRequest {
    /**
     * @generated from protobuf field: user.User user = 1
     */
    user?: User;
}
/**
 * @generated from protobuf message user.UpdateProfileResponse
 */
export interface UpdateProfileResponse {
    /**
     * @generated from protobuf field: user.User user = 1
     */
    user?: User;
}
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("user.User", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxLen: "50", pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]{4,48}[a-zA-Z0-9]$" } } } },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { email: true } } } },
            { no: 4, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxLen: "100" } } } },
            { no: 5, name: "nickname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "avatar", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "roles", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["user.UserRole", UserRole] },
            { no: 8, name: "accessToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "accessTokenExpires", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "refreshToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "refreshTokenExpires", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "lastLogin", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "googleOpenId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "status", kind: "enum", T: () => ["user.UserStatus", UserStatus] }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.username = "";
        message.email = "";
        message.password = "";
        message.nickname = "";
        message.avatar = "";
        message.roles = [];
        message.accessToken = "";
        message.accessTokenExpires = 0n;
        message.refreshToken = "";
        message.refreshTokenExpires = 0n;
        message.lastLogin = 0n;
        message.googleOpenId = "";
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* string password */ 4:
                    message.password = reader.string();
                    break;
                case /* string nickname */ 5:
                    message.nickname = reader.string();
                    break;
                case /* string avatar */ 6:
                    message.avatar = reader.string();
                    break;
                case /* repeated user.UserRole roles */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.roles.push(reader.int32());
                    else
                        message.roles.push(reader.int32());
                    break;
                case /* string accessToken */ 8:
                    message.accessToken = reader.string();
                    break;
                case /* uint64 accessTokenExpires */ 9:
                    message.accessTokenExpires = reader.uint64().toBigInt();
                    break;
                case /* string refreshToken */ 10:
                    message.refreshToken = reader.string();
                    break;
                case /* uint64 refreshTokenExpires */ 11:
                    message.refreshTokenExpires = reader.uint64().toBigInt();
                    break;
                case /* uint64 lastLogin */ 12:
                    message.lastLogin = reader.uint64().toBigInt();
                    break;
                case /* string googleOpenId */ 13:
                    message.googleOpenId = reader.string();
                    break;
                case /* user.UserStatus status */ 14:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* string password = 4; */
        if (message.password !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.password);
        /* string nickname = 5; */
        if (message.nickname !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nickname);
        /* string avatar = 6; */
        if (message.avatar !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.avatar);
        /* repeated user.UserRole roles = 7; */
        if (message.roles.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.roles.length; i++)
                writer.int32(message.roles[i]);
            writer.join();
        }
        /* string accessToken = 8; */
        if (message.accessToken !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.accessToken);
        /* uint64 accessTokenExpires = 9; */
        if (message.accessTokenExpires !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.accessTokenExpires);
        /* string refreshToken = 10; */
        if (message.refreshToken !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.refreshToken);
        /* uint64 refreshTokenExpires = 11; */
        if (message.refreshTokenExpires !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.refreshTokenExpires);
        /* uint64 lastLogin = 12; */
        if (message.lastLogin !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.lastLogin);
        /* string googleOpenId = 13; */
        if (message.googleOpenId !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.googleOpenId);
        /* user.UserStatus status = 14; */
        if (message.status !== 0)
            writer.tag(14, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProfileRequest$Type extends MessageType<GetProfileRequest> {
    constructor() {
        super("user.GetProfileRequest", []);
    }
    create(value?: PartialMessage<GetProfileRequest>): GetProfileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProfileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProfileRequest): GetProfileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProfileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.GetProfileRequest
 */
export const GetProfileRequest = new GetProfileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProfileResponse$Type extends MessageType<GetProfileResponse> {
    constructor() {
        super("user.GetProfileResponse", [
            { no: 1, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<GetProfileResponse>): GetProfileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProfileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProfileResponse): GetProfileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* user.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProfileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* user.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.GetProfileResponse
 */
export const GetProfileResponse = new GetProfileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExistsByEmailRequest$Type extends MessageType<GetExistsByEmailRequest> {
    constructor() {
        super("user.GetExistsByEmailRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { email: true } } } }
        ]);
    }
    create(value?: PartialMessage<GetExistsByEmailRequest>): GetExistsByEmailRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<GetExistsByEmailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExistsByEmailRequest): GetExistsByEmailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetExistsByEmailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.GetExistsByEmailRequest
 */
export const GetExistsByEmailRequest = new GetExistsByEmailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExistsByEmailResponse$Type extends MessageType<GetExistsByEmailResponse> {
    constructor() {
        super("user.GetExistsByEmailResponse", [
            { no: 1, name: "exists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetExistsByEmailResponse>): GetExistsByEmailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.exists = false;
        if (value !== undefined)
            reflectionMergePartial<GetExistsByEmailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExistsByEmailResponse): GetExistsByEmailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool exists */ 1:
                    message.exists = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetExistsByEmailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool exists = 1; */
        if (message.exists !== false)
            writer.tag(1, WireType.Varint).bool(message.exists);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.GetExistsByEmailResponse
 */
export const GetExistsByEmailResponse = new GetExistsByEmailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRequest$Type extends MessageType<RegisterRequest> {
    constructor() {
        super("user.RegisterRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { email: true } } } },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "6", maxLen: "100" } } } }
        ]);
    }
    create(value?: PartialMessage<RegisterRequest>): RegisterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<RegisterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterRequest): RegisterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.RegisterRequest
 */
export const RegisterRequest = new RegisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterResponse$Type extends MessageType<RegisterResponse> {
    constructor() {
        super("user.RegisterResponse", [
            { no: 1, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<RegisterResponse>): RegisterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RegisterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterResponse): RegisterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* user.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* user.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.RegisterResponse
 */
export const RegisterResponse = new RegisterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProfileRequest$Type extends MessageType<UpdateProfileRequest> {
    constructor() {
        super("user.UpdateProfileRequest", [
            { no: 1, name: "user", kind: "message", T: () => User, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<UpdateProfileRequest>): UpdateProfileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateProfileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProfileRequest): UpdateProfileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* user.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProfileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* user.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UpdateProfileRequest
 */
export const UpdateProfileRequest = new UpdateProfileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProfileResponse$Type extends MessageType<UpdateProfileResponse> {
    constructor() {
        super("user.UpdateProfileResponse", [
            { no: 1, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<UpdateProfileResponse>): UpdateProfileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateProfileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProfileResponse): UpdateProfileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* user.User user */ 1:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProfileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* user.User user = 1; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message user.UpdateProfileResponse
 */
export const UpdateProfileResponse = new UpdateProfileResponse$Type();
