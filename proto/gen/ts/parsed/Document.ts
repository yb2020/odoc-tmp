// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/parsed/Document.proto" (package "parsed", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * BBox 表示文档中元素的边界框
 *
 * @generated from protobuf message parsed.BBox
 */
export interface BBox {
    /**
     * @generated from protobuf field: double x0 = 1
     */
    x0: number;
    /**
     * @generated from protobuf field: double y0 = 2
     */
    y0: number;
    /**
     * @generated from protobuf field: double x1 = 3
     */
    x1: number;
    /**
     * @generated from protobuf field: double y1 = 4
     */
    y1: number;
    /**
     * @generated from protobuf field: double origin_height = 5
     */
    origin_height: number;
    /**
     * @generated from protobuf field: double origin_width = 6
     */
    origin_width: number;
    /**
     * @generated from protobuf field: int32 page_number = 7
     */
    page_number: number; // 页码，可选
}
/**
 * PageInfo 表示文档的页面信息
 *
 * @generated from protobuf message parsed.PageInfo
 */
export interface PageInfo {
    /**
     * @generated from protobuf field: int32 page_number = 1
     */
    page_number: number;
    /**
     * @generated from protobuf field: double width = 2
     */
    width: number;
    /**
     * @generated from protobuf field: double height = 3
     */
    height: number;
}
/**
 * Author 表示文档的作者信息
 *
 * @generated from protobuf message parsed.Author
 */
export interface Author {
    /**
     * @generated from protobuf field: string full_name = 1
     */
    full_name: string;
    /**
     * @generated from protobuf field: string given_name = 2
     */
    given_name: string;
    /**
     * @generated from protobuf field: string surname = 3
     */
    surname: string;
    /**
     * @generated from protobuf field: string email = 4
     */
    email: string;
    /**
     * @generated from protobuf field: parsed.BBox bbox = 5
     */
    bbox?: BBox; // 可选
}
/**
 * CatalogueItem 表示目录中的一个条目
 *
 * @generated from protobuf message parsed.CatalogueItem
 */
export interface CatalogueItem {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string; // 章节标题
    /**
     * @generated from protobuf field: string formatted_title = 2
     */
    formatted_title: string; // 格式化章节标题
    /**
     * @generated from protobuf field: repeated parsed.CatalogueItem child = 3
     */
    child: CatalogueItem[]; // 子章节列表
    /**
     * @generated from protobuf field: parsed.BBox bbox = 4
     */
    bbox?: BBox; // 章节标题的边界框，可选
    /**
     * @generated from protobuf field: string level = 5
     */
    level: string; // 章节层级，如1、1.1、1.1.1等，可选
    /**
     * @generated from protobuf field: string title_order = 6
     */
    title_order: string; // 章节序号，如1、2、3等，可选
    /**
     * @generated from protobuf field: int32 order = 7
     */
    order: number; // 原始解析顺序，可选
}
/**
 * Reference 表示文档中的引用
 *
 * @generated from protobuf message parsed.Reference
 */
export interface Reference {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string; // 引用的标题
    /**
     * @generated from protobuf field: parsed.BBox bbox = 2
     */
    bbox?: BBox; // 引用的边界框
    /**
     * @generated from protobuf field: string ref_idx = 3
     */
    ref_idx: string; // 引用的索引标识
    /**
     * @generated from protobuf field: string publish_date = 4
     */
    publish_date: string; // 发布日期
    /**
     * @generated from protobuf field: string search_key = 5
     */
    search_key: string; // 搜索关键词
    /**
     * @generated from protobuf field: repeated parsed.Author authors = 6
     */
    authors: Author[]; // 作者列表
    /**
     * @generated from protobuf field: string content_text = 7
     */
    content_text: string; // 引用的原始文本内容
    /**
     * @generated from protobuf field: string arxiv_id = 8
     */
    arxiv_id: string; // arXiv ID
}
/**
 * RefMarker 表示文档中的引用标记
 *
 * @generated from protobuf message parsed.RefMarker
 */
export interface RefMarker {
    /**
     * @generated from protobuf field: string ref_idx = 1
     */
    ref_idx: string;
    /**
     * @generated from protobuf field: parsed.BBox bbox = 2
     */
    bbox?: BBox;
    /**
     * @generated from protobuf field: string ref_content = 3
     */
    ref_content: string;
}
/**
 * FigureTable 表示文档中的图表标记
 *
 * @generated from protobuf message parsed.FigureTable
 */
export interface FigureTable {
    /**
     * @generated from protobuf field: parsed.BBox bbox = 1
     */
    bbox?: BBox;
    /**
     * @generated from protobuf field: string ref_content = 2
     */
    ref_content: string;
    /**
     * @generated from protobuf field: parsed.BBox ref_bbox = 3
     */
    ref_bbox?: BBox;
    /**
     * @generated from protobuf field: string ref_idx = 4
     */
    ref_idx: string;
    /**
     * 图表类型，如 figure、table 等
     *
     * @generated from protobuf field: string type = 5
     */
    type: string;
    /**
     * @generated from protobuf field: string id = 6
     */
    id: string;
    /**
     * 属于目录id
     *
     * @generated from protobuf field: string section_id = 7
     */
    section_id: string;
    /**
     * @generated from protobuf field: string section_title = 8
     */
    section_title: string;
}
/**
 * content_list.json 中的 title
 *
 * @generated from protobuf message parsed.ContentTitle
 */
export interface ContentTitle {
    /**
     * 文本
     *
     * @generated from protobuf field: string text = 1
     */
    text: string;
    /**
     * 标题级别
     *
     * @generated from protobuf field: int32 level = 2
     */
    level: number;
    /**
     * 页码
     *
     * @generated from protobuf field: int32 page_number = 3
     */
    page_number: number;
}
/**
 * Formula 表示文档中的公式
 *
 * @generated from protobuf message parsed.Formula
 */
export interface Formula {
    /**
     * @generated from protobuf field: parsed.BBox bbox = 1
     */
    bbox?: BBox;
    /**
     * @generated from protobuf field: string ref_content = 2
     */
    ref_content: string;
    /**
     * @generated from protobuf field: string ref_idx = 3
     */
    ref_idx: string;
    /**
     * @generated from protobuf field: string id = 4
     */
    id: string;
    /**
     * 属于目录id
     *
     * @generated from protobuf field: string section_id = 5
     */
    section_id: string;
    /**
     * @generated from protobuf field: string section_title = 6
     */
    section_title: string;
}
/**
 * @generated from protobuf message parsed.Doi
 */
export interface Doi {
    /**
     * @generated from protobuf field: string doi = 1
     */
    doi: string;
    /**
     * @generated from protobuf field: string type = 2
     */
    type: string;
}
/**
 * RefInfo 表示引用信息
 *
 * @generated from protobuf message parsed.RefInfo
 */
export interface RefInfo {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string; // 引用的显示文本，如 [13]
    /**
     * @generated from protobuf field: string target = 2
     */
    target: string; // 引用的目标ID，如 b12
    /**
     * @generated from protobuf field: parsed.BBox bbox = 3
     */
    bbox?: BBox; // 引用的边界框，可选
}
/**
 * Paragraph 表示文档中的一个段落  段落不包含摘要 致谢 标题 等
 *
 * @generated from protobuf message parsed.Paragraph
 */
export interface Paragraph {
    /**
     * @generated from protobuf field: parsed.ParagraphType type = 1
     */
    type: ParagraphType; // 段落类型（正文、引用、标题等），可选
    /**
     * @generated from protobuf field: string section_title = 2
     */
    section_title: string; // 所属章节标题，可选
    /**
     * @generated from protobuf field: string section_id = 3
     */
    section_id: string; // 所属章节ID，用于关联到目录结构，可选
    /**
     * @generated from protobuf field: repeated parsed.RefInfo references = 4
     */
    references: RefInfo[]; // 段落中的引用信息，可选
    /**
     * @generated from protobuf field: parsed.Text text = 5
     */
    text?: Text;
    /**
     * @generated from protobuf field: parsed.Formula formula = 6
     */
    formula?: Formula; // 段落中的公式文本，可选
    /**
     * @generated from protobuf field: parsed.FigureTable figure_table = 7
     */
    figure_table?: FigureTable; // 段落中的图表文本，可选
    /**
     * @generated from protobuf field: int32 order = 8
     */
    order: number; // 段落的原始解析顺序，可选
}
/**
 * @generated from protobuf message parsed.Text
 */
export interface Text {
    /**
     * @generated from protobuf field: parsed.BBox bbox = 1
     */
    bbox?: BBox;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
    /**
     * @generated from protobuf field: repeated parsed.Sentence sentences = 3
     */
    sentences: Sentence[];
}
/**
 * @generated from protobuf message parsed.Abstract
 */
export interface Abstract {
    /**
     * @generated from protobuf field: parsed.BBox bbox = 1
     */
    bbox?: BBox;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message parsed.Acknowledgment
 */
export interface Acknowledgment {
    /**
     * @generated from protobuf field: parsed.BBox bbox = 1
     */
    bbox?: BBox;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * @generated from protobuf message parsed.Title
 */
export interface Title {
    /**
     * @generated from protobuf field: parsed.BBox bbox = 1
     */
    bbox?: BBox;
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string;
}
/**
 * 句子
 *
 * @generated from protobuf message parsed.Sentence
 */
export interface Sentence {
    /**
     * @generated from protobuf field: int32 index = 1
     */
    index: number; // 句子在段落中的索引
    /**
     * @generated from protobuf field: string text = 2
     */
    text: string; // 句子的文本内容
    /**
     * @generated from protobuf field: parsed.BBox bbox = 3
     */
    bbox?: BBox; // 句子的边界框，可选
}
/**
 * DocumentMeta 是文档的元数据，包含元数据、位置信息
 *
 * @generated from protobuf message parsed.DocumentMetadata
 */
export interface DocumentMetadata {
    /**
     * @generated from protobuf field: string grobid_version = 1
     */
    grobid_version: string; // GROBID处理引擎的版本号
    /**
     * @generated from protobuf field: string grobid_ts = 2
     */
    grobid_ts: string; // GROBID处理的时间戳
    /**
     * @generated from protobuf field: repeated parsed.Author authors = 3
     */
    authors: Author[];
    /**
     * @generated from protobuf field: string date = 4
     */
    date: string;
    /**
     * @generated from protobuf field: repeated parsed.Doi dois = 5
     */
    dois: Doi[];
    /**
     * @generated from protobuf field: string fileSHA256 = 6
     */
    fileSHA256: string; // 原始PDF文件的SHA256哈希值，用于唯一标识
    /**
     * @generated from protobuf field: string lang = 7
     */
    lang: string; // 文档的主要语言代码
    /**
     * @generated from protobuf field: parsed.Abstract abstract = 8
     */
    abstract?: Abstract; // 文档的摘要内容
    /**
     * @generated from protobuf field: parsed.Title title = 9
     */
    title?: Title; // 文档的标题
    /**
     * @generated from protobuf field: parsed.Acknowledgment acknowledgment = 10
     */
    acknowledgment?: Acknowledgment; // 文档的致谢内容
    /**
     * @generated from protobuf field: repeated parsed.CatalogueItem catalogue = 11
     */
    catalogue: CatalogueItem[]; // 文档的目录结构信息，包含章节层次
    /**
     * @generated from protobuf field: repeated parsed.Reference references = 12
     */
    references: Reference[]; // 文档中的参考文献列表
    /**
     * @generated from protobuf field: repeated parsed.RefMarker reference_markers = 13
     */
    reference_markers: RefMarker[]; // 文档中的引用标记，如[1]、[Smith et al.]等
    /**
     * @generated from protobuf field: repeated parsed.FigureTable figures_and_tables = 14
     */
    figures_and_tables: FigureTable[]; // 文档中的图表标记，如Figure 1、Table 2等
    /**
     * @generated from protobuf field: repeated parsed.RefMarker figure_and_table_markers = 15
     */
    figure_and_table_markers: RefMarker[]; // 文档中的图表引用标记
    /**
     * @generated from protobuf field: repeated parsed.PageInfo pages = 16
     */
    pages: PageInfo[]; // 文档的页面信息，包含每页的尺寸和编号，可选
    /**
     * @generated from protobuf field: repeated parsed.Formula formulas = 17
     */
    formulas: Formula[]; // 文档的公式列表
}
/**
 * DocumentHeader 是文档的头部信息，包含元数据、位置信息
 *
 * @generated from protobuf message parsed.DocumentHeader
 */
export interface DocumentHeader {
    /**
     * @generated from protobuf field: string grobid_version = 1
     */
    grobid_version: string; // GROBID处理引擎的版本号
    /**
     * @generated from protobuf field: string grobid_ts = 2
     */
    grobid_ts: string; // GROBID处理的时间戳
    /**
     * @generated from protobuf field: parsed.Abstract abstract = 3
     */
    abstract?: Abstract; // 文档的摘要内容
    /**
     * @generated from protobuf field: parsed.Title title = 4
     */
    title?: Title; // 文档的标题
    /**
     * @generated from protobuf field: string fileSHA256 = 5
     */
    fileSHA256: string; // 原始PDF文件的SHA256哈希值，用于唯一标识
    /**
     * @generated from protobuf field: string lang = 6
     */
    lang: string; // 文档的主要语言代码
    /**
     * @generated from protobuf field: string date = 7
     */
    date: string; // 文档的日期
    /**
     * @generated from protobuf field: repeated parsed.Doi dois = 8
     */
    dois: Doi[];
    /**
     * @generated from protobuf field: repeated parsed.Author authors = 9
     */
    authors: Author[];
}
/**
 * FullDocument 是完整的文档
 *
 * @generated from protobuf message parsed.FullDocument
 */
export interface FullDocument {
    /**
     * @generated from protobuf field: repeated parsed.Paragraph paragraphs = 1
     */
    paragraphs: Paragraph[];
}
/**
 * 页面块的行文本内容
 *
 * @generated from protobuf message parsed.BlockText
 */
export interface BlockText {
    /**
     * 坐标
     *
     * @generated from protobuf field: parsed.BBox bbox = 1
     */
    bbox?: BBox;
    /**
     * 文本内容
     *
     * @generated from protobuf field: string text = 2
     */
    text: string;
    /**
     * 是否跨页
     *
     * @generated from protobuf field: bool cross_page = 3
     */
    cross_page: boolean;
}
/**
 * 页面块
 *
 * @generated from protobuf message parsed.PageBlock
 */
export interface PageBlock {
    /**
     * 块类型
     *
     * @generated from protobuf field: parsed.PageBlockType type = 1
     */
    type: PageBlockType;
    /**
     * 块的边界框
     *
     * @generated from protobuf field: parsed.BBox bbox = 2
     */
    bbox?: BBox;
    /**
     * 块的文本内容 文本内容是一个数组
     *
     * @generated from protobuf field: repeated parsed.BlockText texts = 3
     */
    texts: BlockText[];
    /**
     * 块的index序号
     *
     * @generated from protobuf field: int32 index = 4
     */
    index: number;
    /**
     * 是否删除行（这里的意思代表的是，当前块是属于第一页段落中的内容，内容跨页了，需要删除，这里的坐标代表了跨页的文本行）
     *
     * @generated from protobuf field: bool lines_deleted = 5
     */
    lines_deleted: boolean;
    /**
     * 级别（当块类型是标题时，这里才设置级别）
     *
     * @generated from protobuf field: int32 level = 6
     */
    level: number;
}
/**
 * 页面块存储的数据结构
 *
 * @generated from protobuf message parsed.PageBlockData
 */
export interface PageBlockData {
    /**
     * 页面的序号
     *
     * @generated from protobuf field: int32 page_index = 1
     */
    page_index: number;
    /**
     * 块的内容
     *
     * @generated from protobuf field: repeated parsed.PageBlock page_blocks = 2
     */
    page_blocks: PageBlock[];
}
/**
 * 段落类型的枚举
 *
 * @generated from protobuf enum parsed.ParagraphType
 */
export enum ParagraphType {
    /**
     * @generated from protobuf enum value: UNKOWN = 0;
     */
    UNKOWN = 0,
    /**
     * @generated from protobuf enum value: TEXT = 1;
     */
    TEXT = 1,
    /**
     * @generated from protobuf enum value: IMAGE = 2;
     */
    IMAGE = 2,
    /**
     * @generated from protobuf enum value: FORMULA = 3;
     */
    FORMULA = 3,
    /**
     * @generated from protobuf enum value: TABLE = 4;
     */
    TABLE = 4
}
/**
 * 页面块类型
 *
 * @generated from protobuf enum parsed.PageBlockType
 */
export enum PageBlockType {
    /**
     * 默认
     *
     * @generated from protobuf enum value: PAGE_BLOCK_DEFAULT = 0;
     */
    PAGE_BLOCK_DEFAULT = 0,
    /**
     * 标题
     *
     * @generated from protobuf enum value: PAGE_BLOCK_TITLE = 1;
     */
    PAGE_BLOCK_TITLE = 1,
    /**
     * 文本
     *
     * @generated from protobuf enum value: PAGE_BLOCK_PLAIN_TEXT = 2;
     */
    PAGE_BLOCK_PLAIN_TEXT = 2,
    /**
     * 包括页眉页脚页码和页面注释
     *
     * @generated from protobuf enum value: PAGE_BLOCK_ABANDON = 3;
     */
    PAGE_BLOCK_ABANDON = 3,
    /**
     * 图片
     *
     * @generated from protobuf enum value: PAGE_BLOCK_FIGURE = 4;
     */
    PAGE_BLOCK_FIGURE = 4,
    /**
     * 图片描述
     *
     * @generated from protobuf enum value: PAGE_BLOCK_FIGURE_CAPTION = 5;
     */
    PAGE_BLOCK_FIGURE_CAPTION = 5,
    /**
     * 表格
     *
     * @generated from protobuf enum value: PAGE_BLOCK_TABLE = 6;
     */
    PAGE_BLOCK_TABLE = 6,
    /**
     * 表格描述
     *
     * @generated from protobuf enum value: PAGE_BLOCK_TABLE_CAPTION = 7;
     */
    PAGE_BLOCK_TABLE_CAPTION = 7,
    /**
     * 表格注释
     *
     * @generated from protobuf enum value: PAGE_BLOCK_TABLE_FOOTNOTE = 8;
     */
    PAGE_BLOCK_TABLE_FOOTNOTE = 8,
    /**
     * 行间公式
     *
     * @generated from protobuf enum value: PAGE_BLOCK_ISOLATE_FORMULA = 9;
     */
    PAGE_BLOCK_ISOLATE_FORMULA = 9,
    /**
     * 行间公式的标号
     *
     * @generated from protobuf enum value: PAGE_BLOCK_FORMULA_CAPTION = 10;
     */
    PAGE_BLOCK_FORMULA_CAPTION = 10,
    /**
     * 行内公式
     *
     * @generated from protobuf enum value: PAGE_BLOCK_EMBEDDING = 11;
     */
    PAGE_BLOCK_EMBEDDING = 11,
    /**
     * 行间公式
     *
     * @generated from protobuf enum value: PAGE_BLOCK_ISOLATED = 12;
     */
    PAGE_BLOCK_ISOLATED = 12,
    /**
     * OCR 识别结果
     *
     * @generated from protobuf enum value: PAGE_BLOCK_TEXT = 13;
     */
    PAGE_BLOCK_TEXT = 13
}
// @generated message type with reflection information, may provide speed optimized methods
class BBox$Type extends MessageType<BBox> {
    constructor() {
        super("parsed.BBox", [
            { no: 1, name: "x0", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y0", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "x1", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "y1", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "origin_height", kind: "scalar", localName: "origin_height", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "origin_width", kind: "scalar", localName: "origin_width", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "page_number", kind: "scalar", localName: "page_number", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BBox>): BBox {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x0 = 0;
        message.y0 = 0;
        message.x1 = 0;
        message.y1 = 0;
        message.origin_height = 0;
        message.origin_width = 0;
        message.page_number = 0;
        if (value !== undefined)
            reflectionMergePartial<BBox>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BBox): BBox {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x0 */ 1:
                    message.x0 = reader.double();
                    break;
                case /* double y0 */ 2:
                    message.y0 = reader.double();
                    break;
                case /* double x1 */ 3:
                    message.x1 = reader.double();
                    break;
                case /* double y1 */ 4:
                    message.y1 = reader.double();
                    break;
                case /* double origin_height */ 5:
                    message.origin_height = reader.double();
                    break;
                case /* double origin_width */ 6:
                    message.origin_width = reader.double();
                    break;
                case /* int32 page_number */ 7:
                    message.page_number = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BBox, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x0 = 1; */
        if (message.x0 !== 0)
            writer.tag(1, WireType.Bit64).double(message.x0);
        /* double y0 = 2; */
        if (message.y0 !== 0)
            writer.tag(2, WireType.Bit64).double(message.y0);
        /* double x1 = 3; */
        if (message.x1 !== 0)
            writer.tag(3, WireType.Bit64).double(message.x1);
        /* double y1 = 4; */
        if (message.y1 !== 0)
            writer.tag(4, WireType.Bit64).double(message.y1);
        /* double origin_height = 5; */
        if (message.origin_height !== 0)
            writer.tag(5, WireType.Bit64).double(message.origin_height);
        /* double origin_width = 6; */
        if (message.origin_width !== 0)
            writer.tag(6, WireType.Bit64).double(message.origin_width);
        /* int32 page_number = 7; */
        if (message.page_number !== 0)
            writer.tag(7, WireType.Varint).int32(message.page_number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.BBox
 */
export const BBox = new BBox$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PageInfo$Type extends MessageType<PageInfo> {
    constructor() {
        super("parsed.PageInfo", [
            { no: 1, name: "page_number", kind: "scalar", localName: "page_number", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<PageInfo>): PageInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page_number = 0;
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<PageInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PageInfo): PageInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_number */ 1:
                    message.page_number = reader.int32();
                    break;
                case /* double width */ 2:
                    message.width = reader.double();
                    break;
                case /* double height */ 3:
                    message.height = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PageInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_number = 1; */
        if (message.page_number !== 0)
            writer.tag(1, WireType.Varint).int32(message.page_number);
        /* double width = 2; */
        if (message.width !== 0)
            writer.tag(2, WireType.Bit64).double(message.width);
        /* double height = 3; */
        if (message.height !== 0)
            writer.tag(3, WireType.Bit64).double(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.PageInfo
 */
export const PageInfo = new PageInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Author$Type extends MessageType<Author> {
    constructor() {
        super("parsed.Author", [
            { no: 1, name: "full_name", kind: "scalar", localName: "full_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "given_name", kind: "scalar", localName: "given_name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "surname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "bbox", kind: "message", T: () => BBox }
        ]);
    }
    create(value?: PartialMessage<Author>): Author {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.full_name = "";
        message.given_name = "";
        message.surname = "";
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<Author>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Author): Author {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string full_name */ 1:
                    message.full_name = reader.string();
                    break;
                case /* string given_name */ 2:
                    message.given_name = reader.string();
                    break;
                case /* string surname */ 3:
                    message.surname = reader.string();
                    break;
                case /* string email */ 4:
                    message.email = reader.string();
                    break;
                case /* parsed.BBox bbox */ 5:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Author, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string full_name = 1; */
        if (message.full_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.full_name);
        /* string given_name = 2; */
        if (message.given_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.given_name);
        /* string surname = 3; */
        if (message.surname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.surname);
        /* string email = 4; */
        if (message.email !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.email);
        /* parsed.BBox bbox = 5; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Author
 */
export const Author = new Author$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogueItem$Type extends MessageType<CatalogueItem> {
    constructor() {
        super("parsed.CatalogueItem", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "formatted_title", kind: "scalar", localName: "formatted_title", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "child", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CatalogueItem },
            { no: 4, name: "bbox", kind: "message", T: () => BBox },
            { no: 5, name: "level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "title_order", kind: "scalar", localName: "title_order", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "order", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CatalogueItem>): CatalogueItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.formatted_title = "";
        message.child = [];
        message.level = "";
        message.title_order = "";
        message.order = 0;
        if (value !== undefined)
            reflectionMergePartial<CatalogueItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CatalogueItem): CatalogueItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string formatted_title */ 2:
                    message.formatted_title = reader.string();
                    break;
                case /* repeated parsed.CatalogueItem child */ 3:
                    message.child.push(CatalogueItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* parsed.BBox bbox */ 4:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string level */ 5:
                    message.level = reader.string();
                    break;
                case /* string title_order */ 6:
                    message.title_order = reader.string();
                    break;
                case /* int32 order */ 7:
                    message.order = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CatalogueItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string formatted_title = 2; */
        if (message.formatted_title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.formatted_title);
        /* repeated parsed.CatalogueItem child = 3; */
        for (let i = 0; i < message.child.length; i++)
            CatalogueItem.internalBinaryWrite(message.child[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* parsed.BBox bbox = 4; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string level = 5; */
        if (message.level !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.level);
        /* string title_order = 6; */
        if (message.title_order !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.title_order);
        /* int32 order = 7; */
        if (message.order !== 0)
            writer.tag(7, WireType.Varint).int32(message.order);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.CatalogueItem
 */
export const CatalogueItem = new CatalogueItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reference$Type extends MessageType<Reference> {
    constructor() {
        super("parsed.Reference", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bbox", kind: "message", T: () => BBox },
            { no: 3, name: "ref_idx", kind: "scalar", localName: "ref_idx", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "publish_date", kind: "scalar", localName: "publish_date", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "search_key", kind: "scalar", localName: "search_key", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "authors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Author },
            { no: 7, name: "content_text", kind: "scalar", localName: "content_text", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "arxiv_id", kind: "scalar", localName: "arxiv_id", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Reference>): Reference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.ref_idx = "";
        message.publish_date = "";
        message.search_key = "";
        message.authors = [];
        message.content_text = "";
        message.arxiv_id = "";
        if (value !== undefined)
            reflectionMergePartial<Reference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reference): Reference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* parsed.BBox bbox */ 2:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string ref_idx */ 3:
                    message.ref_idx = reader.string();
                    break;
                case /* string publish_date */ 4:
                    message.publish_date = reader.string();
                    break;
                case /* string search_key */ 5:
                    message.search_key = reader.string();
                    break;
                case /* repeated parsed.Author authors */ 6:
                    message.authors.push(Author.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string content_text */ 7:
                    message.content_text = reader.string();
                    break;
                case /* string arxiv_id */ 8:
                    message.arxiv_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* parsed.BBox bbox = 2; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string ref_idx = 3; */
        if (message.ref_idx !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ref_idx);
        /* string publish_date = 4; */
        if (message.publish_date !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.publish_date);
        /* string search_key = 5; */
        if (message.search_key !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.search_key);
        /* repeated parsed.Author authors = 6; */
        for (let i = 0; i < message.authors.length; i++)
            Author.internalBinaryWrite(message.authors[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string content_text = 7; */
        if (message.content_text !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.content_text);
        /* string arxiv_id = 8; */
        if (message.arxiv_id !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.arxiv_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Reference
 */
export const Reference = new Reference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefMarker$Type extends MessageType<RefMarker> {
    constructor() {
        super("parsed.RefMarker", [
            { no: 1, name: "ref_idx", kind: "scalar", localName: "ref_idx", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bbox", kind: "message", T: () => BBox },
            { no: 3, name: "ref_content", kind: "scalar", localName: "ref_content", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefMarker>): RefMarker {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ref_idx = "";
        message.ref_content = "";
        if (value !== undefined)
            reflectionMergePartial<RefMarker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefMarker): RefMarker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ref_idx */ 1:
                    message.ref_idx = reader.string();
                    break;
                case /* parsed.BBox bbox */ 2:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string ref_content */ 3:
                    message.ref_content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefMarker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ref_idx = 1; */
        if (message.ref_idx !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ref_idx);
        /* parsed.BBox bbox = 2; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string ref_content = 3; */
        if (message.ref_content !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ref_content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.RefMarker
 */
export const RefMarker = new RefMarker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FigureTable$Type extends MessageType<FigureTable> {
    constructor() {
        super("parsed.FigureTable", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "ref_content", kind: "scalar", localName: "ref_content", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ref_bbox", kind: "message", localName: "ref_bbox", T: () => BBox },
            { no: 4, name: "ref_idx", kind: "scalar", localName: "ref_idx", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "section_id", kind: "scalar", localName: "section_id", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "section_title", kind: "scalar", localName: "section_title", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FigureTable>): FigureTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ref_content = "";
        message.ref_idx = "";
        message.type = "";
        message.id = "";
        message.section_id = "";
        message.section_title = "";
        if (value !== undefined)
            reflectionMergePartial<FigureTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FigureTable): FigureTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string ref_content */ 2:
                    message.ref_content = reader.string();
                    break;
                case /* parsed.BBox ref_bbox */ 3:
                    message.ref_bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.ref_bbox);
                    break;
                case /* string ref_idx */ 4:
                    message.ref_idx = reader.string();
                    break;
                case /* string type */ 5:
                    message.type = reader.string();
                    break;
                case /* string id */ 6:
                    message.id = reader.string();
                    break;
                case /* string section_id */ 7:
                    message.section_id = reader.string();
                    break;
                case /* string section_title */ 8:
                    message.section_title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FigureTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string ref_content = 2; */
        if (message.ref_content !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ref_content);
        /* parsed.BBox ref_bbox = 3; */
        if (message.ref_bbox)
            BBox.internalBinaryWrite(message.ref_bbox, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string ref_idx = 4; */
        if (message.ref_idx !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ref_idx);
        /* string type = 5; */
        if (message.type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.type);
        /* string id = 6; */
        if (message.id !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.id);
        /* string section_id = 7; */
        if (message.section_id !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.section_id);
        /* string section_title = 8; */
        if (message.section_title !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.section_title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.FigureTable
 */
export const FigureTable = new FigureTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContentTitle$Type extends MessageType<ContentTitle> {
    constructor() {
        super("parsed.ContentTitle", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page_number", kind: "scalar", localName: "page_number", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ContentTitle>): ContentTitle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.level = 0;
        message.page_number = 0;
        if (value !== undefined)
            reflectionMergePartial<ContentTitle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContentTitle): ContentTitle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* int32 page_number */ 3:
                    message.page_number = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContentTitle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* int32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* int32 page_number = 3; */
        if (message.page_number !== 0)
            writer.tag(3, WireType.Varint).int32(message.page_number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.ContentTitle
 */
export const ContentTitle = new ContentTitle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Formula$Type extends MessageType<Formula> {
    constructor() {
        super("parsed.Formula", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "ref_content", kind: "scalar", localName: "ref_content", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ref_idx", kind: "scalar", localName: "ref_idx", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "section_id", kind: "scalar", localName: "section_id", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "section_title", kind: "scalar", localName: "section_title", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Formula>): Formula {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ref_content = "";
        message.ref_idx = "";
        message.id = "";
        message.section_id = "";
        message.section_title = "";
        if (value !== undefined)
            reflectionMergePartial<Formula>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Formula): Formula {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string ref_content */ 2:
                    message.ref_content = reader.string();
                    break;
                case /* string ref_idx */ 3:
                    message.ref_idx = reader.string();
                    break;
                case /* string id */ 4:
                    message.id = reader.string();
                    break;
                case /* string section_id */ 5:
                    message.section_id = reader.string();
                    break;
                case /* string section_title */ 6:
                    message.section_title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Formula, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string ref_content = 2; */
        if (message.ref_content !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ref_content);
        /* string ref_idx = 3; */
        if (message.ref_idx !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ref_idx);
        /* string id = 4; */
        if (message.id !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.id);
        /* string section_id = 5; */
        if (message.section_id !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.section_id);
        /* string section_title = 6; */
        if (message.section_title !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.section_title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Formula
 */
export const Formula = new Formula$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Doi$Type extends MessageType<Doi> {
    constructor() {
        super("parsed.Doi", [
            { no: 1, name: "doi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Doi>): Doi {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.doi = "";
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<Doi>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Doi): Doi {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string doi */ 1:
                    message.doi = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Doi, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string doi = 1; */
        if (message.doi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.doi);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Doi
 */
export const Doi = new Doi$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefInfo$Type extends MessageType<RefInfo> {
    constructor() {
        super("parsed.RefInfo", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bbox", kind: "message", T: () => BBox }
        ]);
    }
    create(value?: PartialMessage<RefInfo>): RefInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.target = "";
        if (value !== undefined)
            reflectionMergePartial<RefInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefInfo): RefInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* string target */ 2:
                    message.target = reader.string();
                    break;
                case /* parsed.BBox bbox */ 3:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* string target = 2; */
        if (message.target !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target);
        /* parsed.BBox bbox = 3; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.RefInfo
 */
export const RefInfo = new RefInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Paragraph$Type extends MessageType<Paragraph> {
    constructor() {
        super("parsed.Paragraph", [
            { no: 1, name: "type", kind: "enum", T: () => ["parsed.ParagraphType", ParagraphType] },
            { no: 2, name: "section_title", kind: "scalar", localName: "section_title", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "section_id", kind: "scalar", localName: "section_id", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "references", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RefInfo },
            { no: 5, name: "text", kind: "message", T: () => Text },
            { no: 6, name: "formula", kind: "message", T: () => Formula },
            { no: 7, name: "figure_table", kind: "message", localName: "figure_table", T: () => FigureTable },
            { no: 8, name: "order", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Paragraph>): Paragraph {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.section_title = "";
        message.section_id = "";
        message.references = [];
        message.order = 0;
        if (value !== undefined)
            reflectionMergePartial<Paragraph>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Paragraph): Paragraph {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.ParagraphType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string section_title */ 2:
                    message.section_title = reader.string();
                    break;
                case /* string section_id */ 3:
                    message.section_id = reader.string();
                    break;
                case /* repeated parsed.RefInfo references */ 4:
                    message.references.push(RefInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* parsed.Text text */ 5:
                    message.text = Text.internalBinaryRead(reader, reader.uint32(), options, message.text);
                    break;
                case /* parsed.Formula formula */ 6:
                    message.formula = Formula.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                case /* parsed.FigureTable figure_table */ 7:
                    message.figure_table = FigureTable.internalBinaryRead(reader, reader.uint32(), options, message.figure_table);
                    break;
                case /* int32 order */ 8:
                    message.order = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Paragraph, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.ParagraphType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string section_title = 2; */
        if (message.section_title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.section_title);
        /* string section_id = 3; */
        if (message.section_id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.section_id);
        /* repeated parsed.RefInfo references = 4; */
        for (let i = 0; i < message.references.length; i++)
            RefInfo.internalBinaryWrite(message.references[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* parsed.Text text = 5; */
        if (message.text)
            Text.internalBinaryWrite(message.text, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* parsed.Formula formula = 6; */
        if (message.formula)
            Formula.internalBinaryWrite(message.formula, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* parsed.FigureTable figure_table = 7; */
        if (message.figure_table)
            FigureTable.internalBinaryWrite(message.figure_table, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* int32 order = 8; */
        if (message.order !== 0)
            writer.tag(8, WireType.Varint).int32(message.order);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Paragraph
 */
export const Paragraph = new Paragraph$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Text$Type extends MessageType<Text> {
    constructor() {
        super("parsed.Text", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sentences", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Sentence }
        ]);
    }
    create(value?: PartialMessage<Text>): Text {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.sentences = [];
        if (value !== undefined)
            reflectionMergePartial<Text>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Text): Text {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                case /* repeated parsed.Sentence sentences */ 3:
                    message.sentences.push(Sentence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Text, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        /* repeated parsed.Sentence sentences = 3; */
        for (let i = 0; i < message.sentences.length; i++)
            Sentence.internalBinaryWrite(message.sentences[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Text
 */
export const Text = new Text$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Abstract$Type extends MessageType<Abstract> {
    constructor() {
        super("parsed.Abstract", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Abstract>): Abstract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Abstract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Abstract): Abstract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Abstract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Abstract
 */
export const Abstract = new Abstract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Acknowledgment$Type extends MessageType<Acknowledgment> {
    constructor() {
        super("parsed.Acknowledgment", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Acknowledgment>): Acknowledgment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Acknowledgment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Acknowledgment): Acknowledgment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Acknowledgment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Acknowledgment
 */
export const Acknowledgment = new Acknowledgment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Title$Type extends MessageType<Title> {
    constructor() {
        super("parsed.Title", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Title>): Title {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Title>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Title): Title {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Title, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Title
 */
export const Title = new Title$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sentence$Type extends MessageType<Sentence> {
    constructor() {
        super("parsed.Sentence", [
            { no: 1, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bbox", kind: "message", T: () => BBox }
        ]);
    }
    create(value?: PartialMessage<Sentence>): Sentence {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<Sentence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sentence): Sentence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 index */ 1:
                    message.index = reader.int32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                case /* parsed.BBox bbox */ 3:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sentence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).int32(message.index);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        /* parsed.BBox bbox = 3; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.Sentence
 */
export const Sentence = new Sentence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentMetadata$Type extends MessageType<DocumentMetadata> {
    constructor() {
        super("parsed.DocumentMetadata", [
            { no: 1, name: "grobid_version", kind: "scalar", localName: "grobid_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grobid_ts", kind: "scalar", localName: "grobid_ts", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "authors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Author },
            { no: 4, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dois", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Doi },
            { no: 6, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "lang", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "abstract", kind: "message", T: () => Abstract },
            { no: 9, name: "title", kind: "message", T: () => Title },
            { no: 10, name: "acknowledgment", kind: "message", T: () => Acknowledgment },
            { no: 11, name: "catalogue", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CatalogueItem },
            { no: 12, name: "references", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Reference },
            { no: 13, name: "reference_markers", kind: "message", localName: "reference_markers", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RefMarker },
            { no: 14, name: "figures_and_tables", kind: "message", localName: "figures_and_tables", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FigureTable },
            { no: 15, name: "figure_and_table_markers", kind: "message", localName: "figure_and_table_markers", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RefMarker },
            { no: 16, name: "pages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PageInfo },
            { no: 17, name: "formulas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Formula }
        ]);
    }
    create(value?: PartialMessage<DocumentMetadata>): DocumentMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grobid_version = "";
        message.grobid_ts = "";
        message.authors = [];
        message.date = "";
        message.dois = [];
        message.fileSHA256 = "";
        message.lang = "";
        message.catalogue = [];
        message.references = [];
        message.reference_markers = [];
        message.figures_and_tables = [];
        message.figure_and_table_markers = [];
        message.pages = [];
        message.formulas = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentMetadata): DocumentMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grobid_version */ 1:
                    message.grobid_version = reader.string();
                    break;
                case /* string grobid_ts */ 2:
                    message.grobid_ts = reader.string();
                    break;
                case /* repeated parsed.Author authors */ 3:
                    message.authors.push(Author.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string date */ 4:
                    message.date = reader.string();
                    break;
                case /* repeated parsed.Doi dois */ 5:
                    message.dois.push(Doi.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string fileSHA256 */ 6:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string lang */ 7:
                    message.lang = reader.string();
                    break;
                case /* parsed.Abstract abstract */ 8:
                    message.abstract = Abstract.internalBinaryRead(reader, reader.uint32(), options, message.abstract);
                    break;
                case /* parsed.Title title */ 9:
                    message.title = Title.internalBinaryRead(reader, reader.uint32(), options, message.title);
                    break;
                case /* parsed.Acknowledgment acknowledgment */ 10:
                    message.acknowledgment = Acknowledgment.internalBinaryRead(reader, reader.uint32(), options, message.acknowledgment);
                    break;
                case /* repeated parsed.CatalogueItem catalogue */ 11:
                    message.catalogue.push(CatalogueItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.Reference references */ 12:
                    message.references.push(Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.RefMarker reference_markers */ 13:
                    message.reference_markers.push(RefMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.FigureTable figures_and_tables */ 14:
                    message.figures_and_tables.push(FigureTable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.RefMarker figure_and_table_markers */ 15:
                    message.figure_and_table_markers.push(RefMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.PageInfo pages */ 16:
                    message.pages.push(PageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.Formula formulas */ 17:
                    message.formulas.push(Formula.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grobid_version = 1; */
        if (message.grobid_version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grobid_version);
        /* string grobid_ts = 2; */
        if (message.grobid_ts !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.grobid_ts);
        /* repeated parsed.Author authors = 3; */
        for (let i = 0; i < message.authors.length; i++)
            Author.internalBinaryWrite(message.authors[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string date = 4; */
        if (message.date !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.date);
        /* repeated parsed.Doi dois = 5; */
        for (let i = 0; i < message.dois.length; i++)
            Doi.internalBinaryWrite(message.dois[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string fileSHA256 = 6; */
        if (message.fileSHA256 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fileSHA256);
        /* string lang = 7; */
        if (message.lang !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.lang);
        /* parsed.Abstract abstract = 8; */
        if (message.abstract)
            Abstract.internalBinaryWrite(message.abstract, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* parsed.Title title = 9; */
        if (message.title)
            Title.internalBinaryWrite(message.title, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* parsed.Acknowledgment acknowledgment = 10; */
        if (message.acknowledgment)
            Acknowledgment.internalBinaryWrite(message.acknowledgment, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.CatalogueItem catalogue = 11; */
        for (let i = 0; i < message.catalogue.length; i++)
            CatalogueItem.internalBinaryWrite(message.catalogue[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.Reference references = 12; */
        for (let i = 0; i < message.references.length; i++)
            Reference.internalBinaryWrite(message.references[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.RefMarker reference_markers = 13; */
        for (let i = 0; i < message.reference_markers.length; i++)
            RefMarker.internalBinaryWrite(message.reference_markers[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.FigureTable figures_and_tables = 14; */
        for (let i = 0; i < message.figures_and_tables.length; i++)
            FigureTable.internalBinaryWrite(message.figures_and_tables[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.RefMarker figure_and_table_markers = 15; */
        for (let i = 0; i < message.figure_and_table_markers.length; i++)
            RefMarker.internalBinaryWrite(message.figure_and_table_markers[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.PageInfo pages = 16; */
        for (let i = 0; i < message.pages.length; i++)
            PageInfo.internalBinaryWrite(message.pages[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.Formula formulas = 17; */
        for (let i = 0; i < message.formulas.length; i++)
            Formula.internalBinaryWrite(message.formulas[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.DocumentMetadata
 */
export const DocumentMetadata = new DocumentMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentHeader$Type extends MessageType<DocumentHeader> {
    constructor() {
        super("parsed.DocumentHeader", [
            { no: 1, name: "grobid_version", kind: "scalar", localName: "grobid_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grobid_ts", kind: "scalar", localName: "grobid_ts", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "abstract", kind: "message", T: () => Abstract },
            { no: 4, name: "title", kind: "message", T: () => Title },
            { no: 5, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "lang", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "dois", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Doi },
            { no: 9, name: "authors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Author }
        ]);
    }
    create(value?: PartialMessage<DocumentHeader>): DocumentHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grobid_version = "";
        message.grobid_ts = "";
        message.fileSHA256 = "";
        message.lang = "";
        message.date = "";
        message.dois = [];
        message.authors = [];
        if (value !== undefined)
            reflectionMergePartial<DocumentHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocumentHeader): DocumentHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string grobid_version */ 1:
                    message.grobid_version = reader.string();
                    break;
                case /* string grobid_ts */ 2:
                    message.grobid_ts = reader.string();
                    break;
                case /* parsed.Abstract abstract */ 3:
                    message.abstract = Abstract.internalBinaryRead(reader, reader.uint32(), options, message.abstract);
                    break;
                case /* parsed.Title title */ 4:
                    message.title = Title.internalBinaryRead(reader, reader.uint32(), options, message.title);
                    break;
                case /* string fileSHA256 */ 5:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string lang */ 6:
                    message.lang = reader.string();
                    break;
                case /* string date */ 7:
                    message.date = reader.string();
                    break;
                case /* repeated parsed.Doi dois */ 8:
                    message.dois.push(Doi.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated parsed.Author authors */ 9:
                    message.authors.push(Author.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocumentHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string grobid_version = 1; */
        if (message.grobid_version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.grobid_version);
        /* string grobid_ts = 2; */
        if (message.grobid_ts !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.grobid_ts);
        /* parsed.Abstract abstract = 3; */
        if (message.abstract)
            Abstract.internalBinaryWrite(message.abstract, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* parsed.Title title = 4; */
        if (message.title)
            Title.internalBinaryWrite(message.title, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string fileSHA256 = 5; */
        if (message.fileSHA256 !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.fileSHA256);
        /* string lang = 6; */
        if (message.lang !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.lang);
        /* string date = 7; */
        if (message.date !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.date);
        /* repeated parsed.Doi dois = 8; */
        for (let i = 0; i < message.dois.length; i++)
            Doi.internalBinaryWrite(message.dois[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.Author authors = 9; */
        for (let i = 0; i < message.authors.length; i++)
            Author.internalBinaryWrite(message.authors[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.DocumentHeader
 */
export const DocumentHeader = new DocumentHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullDocument$Type extends MessageType<FullDocument> {
    constructor() {
        super("parsed.FullDocument", [
            { no: 1, name: "paragraphs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Paragraph }
        ]);
    }
    create(value?: PartialMessage<FullDocument>): FullDocument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paragraphs = [];
        if (value !== undefined)
            reflectionMergePartial<FullDocument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullDocument): FullDocument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated parsed.Paragraph paragraphs */ 1:
                    message.paragraphs.push(Paragraph.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullDocument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated parsed.Paragraph paragraphs = 1; */
        for (let i = 0; i < message.paragraphs.length; i++)
            Paragraph.internalBinaryWrite(message.paragraphs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.FullDocument
 */
export const FullDocument = new FullDocument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockText$Type extends MessageType<BlockText> {
    constructor() {
        super("parsed.BlockText", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cross_page", kind: "scalar", localName: "cross_page", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BlockText>): BlockText {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.cross_page = false;
        if (value !== undefined)
            reflectionMergePartial<BlockText>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockText): BlockText {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                case /* bool cross_page */ 3:
                    message.cross_page = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockText, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        /* bool cross_page = 3; */
        if (message.cross_page !== false)
            writer.tag(3, WireType.Varint).bool(message.cross_page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.BlockText
 */
export const BlockText = new BlockText$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PageBlock$Type extends MessageType<PageBlock> {
    constructor() {
        super("parsed.PageBlock", [
            { no: 1, name: "type", kind: "enum", T: () => ["parsed.PageBlockType", PageBlockType] },
            { no: 2, name: "bbox", kind: "message", T: () => BBox },
            { no: 3, name: "texts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockText },
            { no: 4, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "lines_deleted", kind: "scalar", localName: "lines_deleted", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PageBlock>): PageBlock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.texts = [];
        message.index = 0;
        message.lines_deleted = false;
        message.level = 0;
        if (value !== undefined)
            reflectionMergePartial<PageBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PageBlock): PageBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* parsed.PageBlockType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* parsed.BBox bbox */ 2:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* repeated parsed.BlockText texts */ 3:
                    message.texts.push(BlockText.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 index */ 4:
                    message.index = reader.int32();
                    break;
                case /* bool lines_deleted */ 5:
                    message.lines_deleted = reader.bool();
                    break;
                case /* int32 level */ 6:
                    message.level = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PageBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* parsed.PageBlockType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* parsed.BBox bbox = 2; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated parsed.BlockText texts = 3; */
        for (let i = 0; i < message.texts.length; i++)
            BlockText.internalBinaryWrite(message.texts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 index = 4; */
        if (message.index !== 0)
            writer.tag(4, WireType.Varint).int32(message.index);
        /* bool lines_deleted = 5; */
        if (message.lines_deleted !== false)
            writer.tag(5, WireType.Varint).bool(message.lines_deleted);
        /* int32 level = 6; */
        if (message.level !== 0)
            writer.tag(6, WireType.Varint).int32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.PageBlock
 */
export const PageBlock = new PageBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PageBlockData$Type extends MessageType<PageBlockData> {
    constructor() {
        super("parsed.PageBlockData", [
            { no: 1, name: "page_index", kind: "scalar", localName: "page_index", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_blocks", kind: "message", localName: "page_blocks", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PageBlock }
        ]);
    }
    create(value?: PartialMessage<PageBlockData>): PageBlockData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.page_index = 0;
        message.page_blocks = [];
        if (value !== undefined)
            reflectionMergePartial<PageBlockData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PageBlockData): PageBlockData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_index */ 1:
                    message.page_index = reader.int32();
                    break;
                case /* repeated parsed.PageBlock page_blocks */ 2:
                    message.page_blocks.push(PageBlock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PageBlockData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_index = 1; */
        if (message.page_index !== 0)
            writer.tag(1, WireType.Varint).int32(message.page_index);
        /* repeated parsed.PageBlock page_blocks = 2; */
        for (let i = 0; i < message.page_blocks.length; i++)
            PageBlock.internalBinaryWrite(message.page_blocks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message parsed.PageBlockData
 */
export const PageBlockData = new PageBlockData$Type();
