// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/doc/UserDocManage.proto" (package "doc", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UserDocParsedStatusEnum } from "./UserDocParsedStatus";
/**
 * *
 * 	接口描述: 手动更新文献引用信息
 * 	接口url: /userDoc/manualUpdateDocCiteInfo
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.ManualUpdateDocCiteInfoReq
 */
export interface ManualUpdateDocCiteInfoReq {
    /**
     * paperId和pdfId不能全为空
     *
     * @generated from protobuf field: optional string paperId = 1
     */
    paperId?: string;
    /**
     * paperId和pdfId不能全为空
     *
     * @generated from protobuf field: optional string pdfId = 2
     */
    pdfId?: string;
    /**
     * 文献标题
     *
     * @generated from protobuf field: optional string docName = 3
     */
    docName?: string;
    /**
     * 作者(新增的作者名称传入literal字段)
     *
     * @generated from protobuf field: repeated doc.UserDocAuthorInfo authorList = 4
     */
    authorList: UserDocAuthorInfo[];
    /**
     * doi
     *
     * @generated from protobuf field: optional string doi = 5
     */
    doi?: string;
    /**
     * 发布时间,yyyy-MM-dd
     *
     * @generated from protobuf field: optional string publishDate = 6
     */
    publishDate?: string;
    /**
     * 收录情况
     *
     * @generated from protobuf field: optional string venue = 7
     */
    venue?: string;
    /**
     * 分区信息
     *
     * @generated from protobuf field: optional string partition = 8
     */
    partition?: string;
    /**
     * 文献类型
     *
     * @generated from protobuf field: optional string docType = 9
     */
    docType?: string;
    /**
     * 卷次
     *
     * @generated from protobuf field: optional string volume = 10
     */
    volume?: string;
    /**
     * 期号
     *
     * @generated from protobuf field: optional string issue = 11
     */
    issue?: string;
    /**
     * 页码
     *
     * @generated from protobuf field: optional string page = 12
     */
    page?: string;
    /**
     * @generated from protobuf field: optional string userId = 13
     */
    userId?: string;
}
/**
 * *
 * 	接口描述: 检索更新文献引用信息
 * 	接口url: /userDoc/searchUpdateDocCiteInfo
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.SearchUpdateDocCiteInfoReq
 */
export interface SearchUpdateDocCiteInfoReq {
    /**
     * paperId和pdfId不能全为空
     *
     * @generated from protobuf field: optional string paperId = 1
     */
    paperId?: string;
    /**
     * paperId和pdfId不能全为空
     *
     * @generated from protobuf field: optional string pdfId = 2
     */
    pdfId?: string;
    /**
     * 文献标题
     *
     * @generated from protobuf field: optional string docName = 3
     */
    docName?: string;
    /**
     * 作者(新增的作者名称传入literal字段)
     *
     * @generated from protobuf field: repeated doc.UserDocAuthorInfo authorList = 4
     */
    authorList: UserDocAuthorInfo[];
    /**
     * doi
     *
     * @generated from protobuf field: optional string doi = 5
     */
    doi?: string;
    /**
     * 发布时间,yyyy-MM-dd
     *
     * @generated from protobuf field: optional string publishDate = 6
     */
    publishDate?: string;
    /**
     * 收录情况
     *
     * @generated from protobuf field: optional string venue = 7
     */
    venue?: string;
    /**
     * 分区信息
     *
     * @generated from protobuf field: optional string partition = 8
     */
    partition?: string;
    /**
     * 文献类型
     *
     * @generated from protobuf field: optional string docType = 9
     */
    docType?: string;
    /**
     * 卷次
     *
     * @generated from protobuf field: optional string volume = 10
     */
    volume?: string;
    /**
     * 期号
     *
     * @generated from protobuf field: optional string issue = 11
     */
    issue?: string;
    /**
     * 页码
     *
     * @generated from protobuf field: optional string page = 12
     */
    page?: string;
    /**
     * @generated from protobuf field: optional string userId = 13
     */
    userId?: string;
}
/**
 * @generated from protobuf message doc.UpdateDocCiteInfoResponse
 */
export interface UpdateDocCiteInfoResponse {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: string data = 3
     */
    data: string;
}
/**
 * *
 * 	接口描述: 获取用户文献相关的作者列表
 * 	接口url: /userDoc/getDocRelatedAuthorList
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetDocRelatedAuthorListReq
 */
export interface GetDocRelatedAuthorListReq {
    /**
     * 文件夹id
     *
     * @generated from protobuf field: optional string folderId = 1
     */
    folderId?: string;
    /**
     * @generated from protobuf field: optional string userId = 2
     */
    userId?: string;
}
/**
 * @generated from protobuf message doc.GetDocRelatedAuthorListResponse
 */
export interface GetDocRelatedAuthorListResponse {
    /**
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
    /**
     * @generated from protobuf field: repeated string authorInfos = 2
     */
    authorInfos: string[];
}
/**
 * *
 * 	接口描述: 获取用户文献相关的标签列表
 * 	接口url: /userDoc/getDocRelatedClassifyList
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetDocRelatedClassifyListReq
 */
export interface GetDocRelatedClassifyListReq {
    /**
     * 文件夹id
     *
     * @generated from protobuf field: optional string folderId = 1
     */
    folderId?: string;
    /**
     * @generated from protobuf field: optional string userId = 2
     */
    userId?: string;
}
/**
 * @generated from protobuf message doc.GetDocRelatedClassifyListResponse
 */
export interface GetDocRelatedClassifyListResponse {
    /**
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
    /**
     * @generated from protobuf field: repeated doc.UserDocClassifyInfo classifyInfos = 2
     */
    classifyInfos: UserDocClassifyInfo[];
}
/**
 * *
 * 	接口描述: 获取用户文献相关的收录情况列表
 * 	接口url: /userDoc/getDocRelatedVenueList
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetDocRelatedVenueListReq
 */
export interface GetDocRelatedVenueListReq {
    /**
     * 文件夹id
     *
     * @generated from protobuf field: optional string folderId = 1
     */
    folderId?: string;
    /**
     * @generated from protobuf field: optional string userId = 2
     */
    userId?: string;
}
/**
 * @generated from protobuf message doc.GetDocRelatedVenueListResponse
 */
export interface GetDocRelatedVenueListResponse {
    /**
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
    /**
     * @generated from protobuf field: repeated string venueInfos = 2
     */
    venueInfos: string[];
}
/**
 * *
 * 	接口描述: 获取用户文献数量
 * 	接口url: /userDoc/getDocCount
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetDocCountReq
 */
export interface GetDocCountReq {
}
/**
 * @generated from protobuf message doc.GetDocCountResponse
 */
export interface GetDocCountResponse {
    /**
     * @generated from protobuf field: uint32 count = 1
     */
    count: number;
}
/**
 * *
 * 	接口描述: 获取用户单个文献详细信息
 * 	接口url: /userDoc/getSingleDocInfo
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *  返回UserDocManage.UserDocInfo
 *
 * @generated from protobuf message doc.GetSingleDocInfoReq
 */
export interface GetSingleDocInfoReq {
    /**
     * 文献id
     *
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: optional string userId = 2
     */
    userId?: string;
}
/**
 * @generated from protobuf message doc.GetSingleDocInfoResponse
 */
export interface GetSingleDocInfoResponse {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: doc.UserDocInfo data = 3
     */
    data?: UserDocInfo;
}
/**
 * *
 * 	接口描述: 获取用户文献列表
 * 	接口url: /userDoc/getDocList
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetDocListReq
 */
export interface GetDocListReq {
    /**
     * @generated from protobuf field: optional doc.UserDocListSortType sortType = 1
     */
    sortType?: UserDocListSortType;
    /**
     * 是否升序
     *
     * @generated from protobuf field: optional bool ascSort = 2
     */
    ascSort?: boolean;
    /**
     * 标签id
     *
     * @generated from protobuf field: repeated string classifyIds = 3
     */
    classifyIds: string[];
    /**
     * 筛选的作者信息
     *
     * @generated from protobuf field: repeated string authorInfos = 4
     */
    authorInfos: string[];
    /**
     * 筛选的收录情况
     *
     * @generated from protobuf field: repeated string venueInfos = 5
     */
    venueInfos: string[];
    /**
     * @generated from protobuf field: optional uint32 pageSize = 6
     */
    pageSize?: number;
    /**
     * @generated from protobuf field: optional uint32 currentPage = 7
     */
    currentPage?: number;
    /**
     * @generated from protobuf field: optional string userId = 8
     */
    userId?: string;
    /**
     * @generated from protobuf field: optional string folderId = 9
     */
    folderId?: string;
    /**
     * @generated from protobuf field: optional string searchContent = 10
     */
    searchContent?: string;
    /**
     * @generated from protobuf field: optional bool extMeta = 11
     */
    extMeta?: boolean;
    /**
     * @generated from protobuf field: repeated string jcrPartions = 12
     */
    jcrPartions: string[];
    /**
     * @generated from protobuf field: repeated float impactOfFactorRange = 13
     */
    impactOfFactorRange: number[];
    /**
     * @generated from protobuf field: bool onlyShowDocsWithImpactOfFactor = 14
     */
    onlyShowDocsWithImpactOfFactor: boolean;
    /**
     * 只看有pdf的数据
     *
     * @generated from protobuf field: optional bool onlyPdf = 15
     */
    onlyPdf?: boolean;
}
/**
 * @generated from protobuf message doc.GetDocListResponse
 */
export interface GetDocListResponse {
    /**
     * @generated from protobuf field: uint32 total = 1
     */
    total: number;
    /**
     * @generated from protobuf field: repeated doc.UserDocInfo docList = 2
     */
    docList: UserDocInfo[];
}
/**
 * *
 * 文献列表左侧-获取文件夹列表和文献列表
 * url: /userDoc/getDocIndex
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetDocIndexReq
 */
export interface GetDocIndexReq {
    /**
     * @generated from protobuf field: optional string userId = 1
     */
    userId?: string;
}
/**
 * @generated from protobuf message doc.UserDocInfo
 */
export interface UserDocInfo {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
    /**
     * @generated from protobuf field: uint32 sort = 3
     */
    sort: number;
    /**
     * @generated from protobuf field: string paperId = 4
     */
    paperId: string;
    /**
     * @generated from protobuf field: optional string pdfId = 5
     */
    pdfId?: string;
    /**
     * @generated from protobuf field: optional string remark = 6
     */
    remark?: string;
    /**
     * @generated from protobuf field: uint64 createDate = 7
     */
    createDate: bigint;
    /**
     * @generated from protobuf field: optional uint64 lastReadTime = 8
     */
    lastReadTime?: bigint;
    /**
     * @generated from protobuf field: bool isLatestRead = 9
     */
    isLatestRead: boolean;
    /**
     * @generated from protobuf field: optional string noteId = 10
     */
    noteId?: string;
    /**
     * @generated from protobuf field: bool newPaper = 11
     */
    newPaper: boolean;
    /**
     * @generated from protobuf field: repeated doc.UserDocClassifyInfo classifyInfos = 12
     */
    classifyInfos: UserDocClassifyInfo[];
    /**
     * @generated from protobuf field: doc.PaperRepositoryStatus paperRepositoryStatus = 13
     */
    paperRepositoryStatus: PaperRepositoryStatus;
    /**
     * @generated from protobuf field: doc.UserDocDisplayAuthor displayAuthor = 14
     */
    displayAuthor?: UserDocDisplayAuthor;
    /**
     * @generated from protobuf field: doc.UserDocDisplayVenue displayVenue = 15
     */
    displayVenue?: UserDocDisplayVenue;
    /**
     * @generated from protobuf field: doc.UserDocDisplayPublishDate displayPublishDate = 16
     */
    displayPublishDate?: UserDocDisplayPublishDate;
    /**
     * meta信息
     *
     * @generated from protobuf field: optional doc.UserDocDisplayPage displayPage = 17
     */
    displayPage?: UserDocDisplayPage;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayDocType displayDocType = 18
     */
    displayDocType?: UserDocDisplayDocType;
    /**
     * 会议
     *
     * @generated from protobuf field: optional doc.UserDocDisplayEventInfo displayEventInfo = 19
     */
    displayEventInfo?: UserDocDisplayEventInfo;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayUrl displayUrl = 20
     */
    displayUrl?: UserDocDisplayUrl;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayLanguage displayLanguage = 21
     */
    displayLanguage?: UserDocDisplayLanguage;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayDoi displayDoi = 22
     */
    displayDoi?: UserDocDisplayDoi;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayVolume displayVolume = 23
     */
    displayVolume?: UserDocDisplayVolume;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayIssue displayIssue = 24
     */
    displayIssue?: UserDocDisplayIssue;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayPartition displayPartition = 25
     */
    displayPartition?: UserDocDisplayPartition;
    /**
     * @generated from protobuf field: optional doc.DocSearchResult searchResult = 26
     */
    searchResult?: DocSearchResult;
    /**
     * 是否有附件
     *
     * @generated from protobuf field: bool hasAttachment = 27
     */
    hasAttachment: boolean;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayJcrVenuePartion jcrVenuePartion = 28
     */
    jcrVenuePartion?: UserDocDisplayJcrVenuePartion;
    /**
     * @generated from protobuf field: int32 importantanceScore = 29
     */
    importantanceScore: number;
    /**
     * @generated from protobuf field: optional doc.UserDocDisplayJcrImpactFactor impactOfFactor = 30
     */
    impactOfFactor?: UserDocDisplayJcrImpactFactor;
    /**
     * @generated from protobuf field: doc.DocReadingStatus docReadingStatus = 31
     */
    docReadingStatus: DocReadingStatus;
    /**
     * @generated from protobuf field: optional int32 progress = 32
     */
    progress?: number;
    /**
     * @generated from protobuf field: bool fillExtMeta = 33
     */
    fillExtMeta: boolean;
    /**
     * 解析状态
     *
     * @generated from protobuf field: doc.UserDocParsedStatusEnum parsedStatus = 34
     */
    parsedStatus: UserDocParsedStatusEnum;
    /**
     * Embedding状态
     *
     * @generated from protobuf field: doc.UserDocParsedStatusEnum embeddingStatus = 35
     */
    embeddingStatus: UserDocParsedStatusEnum;
    /**
     * 解析总体进度比
     *
     * @generated from protobuf field: optional string parsedProgress = 36
     */
    parsedProgress?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayJcrVenuePartion
 */
export interface UserDocDisplayJcrVenuePartion {
    /**
     * @generated from protobuf field: optional string jcrVenuePartion = 1
     */
    jcrVenuePartion?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originJcrVenuePartion = 3
     */
    originJcrVenuePartion?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayJcrImpactFactor
 */
export interface UserDocDisplayJcrImpactFactor {
    /**
     * @generated from protobuf field: optional float impactOfFactor = 1
     */
    impactOfFactor?: number;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional float originImpactOfFactor = 3
     */
    originImpactOfFactor?: number;
}
/**
 * @generated from protobuf message doc.DocSearchResult
 */
export interface DocSearchResult {
    /**
     * 搜索命中的文献名称
     *
     * @generated from protobuf field: optional string hitDocName = 1
     */
    hitDocName?: string;
    /**
     * 搜索命中的笔记内容  这个目前没用
     *
     * @generated from protobuf field: optional string hitNote = 2
     */
    hitNote?: string;
    /**
     * //搜索命中的文献备注
     *
     * @generated from protobuf field: optional string hitRemark = 3
     */
    hitRemark?: string;
    /**
     * 搜索命中的发布日期
     *
     * @generated from protobuf field: optional string hitPublishDate = 4
     */
    hitPublishDate?: string;
    /**
     * 搜索命中的作者
     *
     * @generated from protobuf field: optional string hitAuthor = 5
     */
    hitAuthor?: string;
    /**
     * 搜索命中的收录情况
     *
     * @generated from protobuf field: optional string hitVenue = 6
     */
    hitVenue?: string;
    /**
     * 搜索命中的jcr分区
     *
     * @generated from protobuf field: optional string hitJcrVenuePartion = 7
     */
    hitJcrVenuePartion?: string;
}
/**
 * @generated from protobuf message doc.UserDocClassifyInfo
 */
export interface UserDocClassifyInfo {
    /**
     * @generated from protobuf field: string classifyId = 1
     */
    classifyId: string;
    /**
     * @generated from protobuf field: string classifyName = 2
     */
    classifyName: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayVolume
 */
export interface UserDocDisplayVolume {
    /**
     * @generated from protobuf field: optional string volume = 1
     */
    volume?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originVolume = 3
     */
    originVolume?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayIssue
 */
export interface UserDocDisplayIssue {
    /**
     * @generated from protobuf field: optional string issue = 1
     */
    issue?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originIssue = 3
     */
    originIssue?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayPartition
 */
export interface UserDocDisplayPartition {
    /**
     * @generated from protobuf field: optional string partition = 1
     */
    partition?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originPartition = 3
     */
    originPartition?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayDoi
 */
export interface UserDocDisplayDoi {
    /**
     * @generated from protobuf field: optional string doi = 1
     */
    doi?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originDoi = 3
     */
    originDoi?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayUrl
 */
export interface UserDocDisplayUrl {
    /**
     * @generated from protobuf field: optional string url = 1
     */
    url?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originUrl = 3
     */
    originUrl?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayLanguage
 */
export interface UserDocDisplayLanguage {
    /**
     * @generated from protobuf field: optional string language = 1
     */
    language?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originLanguage = 3
     */
    originLanguage?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayEventInfo
 */
export interface UserDocDisplayEventInfo {
    /**
     * @generated from protobuf field: optional doc.EventInfo eventInfo = 1
     */
    eventInfo?: EventInfo;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional doc.EventInfo originEventInfo = 3
     */
    originEventInfo?: EventInfo;
}
/**
 * @generated from protobuf message doc.EventInfo
 */
export interface EventInfo {
    /**
     * @generated from protobuf field: optional string eventTitle = 1
     */
    eventTitle?: string;
    /**
     * @generated from protobuf field: optional string eventPlace = 2
     */
    eventPlace?: string;
    /**
     * @generated from protobuf field: repeated string eventDate = 3
     */
    eventDate: string[];
}
/**
 * @generated from protobuf message doc.UserDocDisplayPage
 */
export interface UserDocDisplayPage {
    /**
     * @generated from protobuf field: optional string page = 1
     */
    page?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originPage = 3
     */
    originPage?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayDocType
 */
export interface UserDocDisplayDocType {
    /**
     * @generated from protobuf field: optional string docType = 1
     */
    docType?: string;
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: optional bool userEdited = 2
     */
    userEdited?: boolean;
    /**
     * @generated from protobuf field: optional string originDocType = 3
     */
    originDocType?: string;
}
/**
 * @generated from protobuf message doc.UserDocDisplayVenue
 */
export interface UserDocDisplayVenue {
    /**
     * @generated from protobuf field: repeated string venueInfos = 1
     */
    venueInfos: string[];
    /**
     * 用户是否编辑过
     *
     * @generated from protobuf field: bool userEdited = 2
     */
    userEdited: boolean;
    /**
     * @generated from protobuf field: repeated string originVenueInfos = 3
     */
    originVenueInfos: string[];
}
/**
 * @generated from protobuf message doc.UserDocDisplayAuthor
 */
export interface UserDocDisplayAuthor {
    /**
     * @generated from protobuf field: repeated doc.UserDocAuthorInfo authorInfos = 1
     */
    authorInfos: UserDocAuthorInfo[];
    /**
     * @generated from protobuf field: bool userEdited = 2
     */
    userEdited: boolean;
    /**
     * @generated from protobuf field: repeated doc.UserDocAuthorInfo originAuthorInfos = 3
     */
    originAuthorInfos: UserDocAuthorInfo[];
}
/**
 * @generated from protobuf message doc.UserDocAuthorInfo
 */
export interface UserDocAuthorInfo {
    /**
     * @generated from protobuf field: optional string id = 1
     */
    id?: string;
    /**
     * @generated from protobuf field: optional string given = 2
     */
    given?: string;
    /**
     * @generated from protobuf field: optional string family = 3
     */
    family?: string;
    /**
     * 作者名(全称)
     *
     * @generated from protobuf field: string literal = 4
     */
    literal: string;
    /**
     * @generated from protobuf field: bool isAuthentication = 5
     */
    isAuthentication: boolean;
}
/**
 * @generated from protobuf message doc.UserDocDisplayPublishDate
 */
export interface UserDocDisplayPublishDate {
    /**
     * @generated from protobuf field: string publishDate = 1
     */
    publishDate: string;
    /**
     * @generated from protobuf field: bool userEdited = 2
     */
    userEdited: boolean;
    /**
     * @generated from protobuf field: string originPublishDate = 3
     */
    originPublishDate: string;
}
/**
 * *
 * 	接口描述: 标记已读
 * 	接口url: /userDoc/mark/finish
 * 	接口请求方式: PUT
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.MarkFinishReq
 */
export interface MarkFinishReq {
    /**
     * @generated from protobuf field: optional string paperId = 1
     */
    paperId?: string;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
}
/**
 * *
 * 	接口描述: 按重要性打分
 * 	接口url: /userDoc/importance/score
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.ImportanceScoreReq
 */
export interface ImportanceScoreReq {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: int32 score = 4
     */
    score: number;
}
/**
 * *
 * 	接口描述: 获取当前目录下的所有jcr分区
 * 	接口url: /userDoc/jcr/partions
 * 	接口请求方式: GET
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.JcrPartionsReq
 */
export interface JcrPartionsReq {
    /**
     * @generated from protobuf field: string folderId = 1
     */
    folderId: string;
}
/**
 * @generated from protobuf message doc.JcrPartionsResponse
 */
export interface JcrPartionsResponse {
    /**
     * @generated from protobuf field: repeated string jcrPartions = 1
     */
    jcrPartions: string[];
}
/**
 * *
 * 	接口描述: 修改影响因子
 * 	接口url: /userDoc/impact/factor
 * 	接口请求方式: PUT
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.ImpactFactorReq
 */
export interface ImpactFactorReq {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: optional float impactOfFactor = 2
     */
    impactOfFactor?: number;
}
/**
 * @generated from protobuf message doc.ImpactFactorResponse
 */
export interface ImpactFactorResponse {
    /**
     * @generated from protobuf field: float originalImpactOfFactor = 1
     */
    originalImpactOfFactor: number;
    /**
     * @generated from protobuf field: bool rollbackEnable = 2
     */
    rollbackEnable: boolean;
    /**
     * @generated from protobuf field: float currentImpactOfFactor = 3
     */
    currentImpactOfFactor: number;
}
/**
 * *
 * 	接口描述: 修改jcr分区
 * 	接口url: /userDoc/update/jcr/partion
 * 	接口请求方式: PUT
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.JcrPartionUpdateReq
 */
export interface JcrPartionUpdateReq {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string jcrPartion = 2
     */
    jcrPartion: string;
}
/**
 * @generated from protobuf message doc.JcrPartionUpdateResponse
 */
export interface JcrPartionUpdateResponse {
    /**
     * @generated from protobuf field: string originalJcrPartion = 1
     */
    originalJcrPartion: string;
    /**
     * @generated from protobuf field: bool rollbackEnable = 2
     */
    rollbackEnable: boolean;
    /**
     * @generated from protobuf field: string currentJcrPartion = 3
     */
    currentJcrPartion: string;
}
/**
 * *
 * 	接口描述: 修改备注
 * 	接口url: /userDoc/updateDocRemark
 * 	接口请求方式: PUT
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.UpdateDocRemarkReq
 */
export interface UpdateDocRemarkReq {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string remark = 2
     */
    remark: string;
}
/**
 * *
 * 	接口描述: 更新阅读状态
 * 	接口url: /userDoc/updateReadStatus
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.UpdateReadStatusRequest
 */
export interface UpdateReadStatusRequest {
    /**
     * @generated from protobuf field: optional string paperId = 1
     */
    paperId?: string;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * @generated from protobuf field: optional doc.DocReadingStatus status = 3
     */
    status?: DocReadingStatus;
    /**
     * @generated from protobuf field: optional int32 progress = 4
     */
    progress?: number;
}
/**
 * *
 * 	接口描述: 删除分类
 * 	接口url: /userDoc/deleteClassify
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.DeleteClassifyReq
 */
export interface DeleteClassifyReq {
    /**
     * @generated from protobuf field: string classifyId = 1
     */
    classifyId: string;
}
/**
 * *
 * 	接口描述: 更新分类
 * 	接口url: /userDoc/updateClassify
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.UpdateClassifyReq
 */
export interface UpdateClassifyReq {
    /**
     * @generated from protobuf field: string classifyId = 1
     */
    classifyId: string;
    /**
     * @generated from protobuf field: string classifyName = 2
     */
    classifyName: string;
    /**
     * @generated from protobuf field: string remark = 3
     */
    remark: string;
}
/**
 * *
 * 	接口描述: 新增分类
 * 	接口url: /userDoc/addClassify
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *  返回通用的状态码
 *
 * @generated from protobuf message doc.AddClassifyReq
 */
export interface AddClassifyReq {
    /**
     * @generated from protobuf field: string classifyName = 1
     */
    classifyName: string;
    /**
     * @generated from protobuf field: string remark = 2
     */
    remark: string;
}
/**
 * @generated from protobuf message doc.AddClassifyResponse
 */
export interface AddClassifyResponse {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string classifyId = 2
     */
    classifyId: string;
    /**
     * @generated from protobuf field: string classifyName = 3
     */
    classifyName: string;
}
/**
 * *
 * 	接口描述: 修改文献的分类
 * 	接口url: /userDoc/attachDocToClassify
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.AttachDocToClassifyReq
 */
export interface AttachDocToClassifyReq {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string classifyId = 2
     */
    classifyId: string;
    /**
     * @generated from protobuf field: string classifyName = 3
     */
    classifyName: string;
}
/**
 * *
 *  接口描述: 删除文献的分类
 *  接口url: /userDoc/removeDocFromClassify
 *  接口请求方式: POST
 *  参数格式:application/json
 *
 * @generated from protobuf message doc.DeleteDocClassifyReq
 */
export interface DeleteDocClassifyReq {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: string classifyId = 2
     */
    classifyId: string;
}
/**
 * @generated from protobuf enum doc.DocReadingStatus
 */
export enum DocReadingStatus {
    /**
     * 未读
     *
     * @generated from protobuf enum value: UNREAD = 0;
     */
    UNREAD = 0,
    /**
     * 正在读
     *
     * @generated from protobuf enum value: READING = 1;
     */
    READING = 1,
    /**
     * 已读
     *
     * @generated from protobuf enum value: READ = 2;
     */
    READ = 2
}
/**
 * @generated from protobuf enum doc.PaperRepositoryStatus
 */
export enum PaperRepositoryStatus {
    /**
     * 这是一篇论文, IAG中也存在这边论文的信息
     *
     * @generated from protobuf enum value: IN_REPOSITORY = 0;
     */
    IN_REPOSITORY = 0,
    /**
     * 这不是一篇论文, 或者IAG没有论文的相关信息
     *
     * @generated from protobuf enum value: NOT_IN_REPOSITORY = 1;
     */
    NOT_IN_REPOSITORY = 1
}
/**
 * @generated from protobuf enum doc.UserDocListSortType
 */
export enum UserDocListSortType {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * 最近阅读
     *
     * @generated from protobuf enum value: LAST_READ = 1;
     */
    LAST_READ = 1,
    /**
     * 最近添加
     *
     * @generated from protobuf enum value: LAST_ADD = 2;
     */
    LAST_ADD = 2,
    /**
     * 文献名
     *
     * @generated from protobuf enum value: DOC_NAME = 3;
     */
    DOC_NAME = 3,
    /**
     * 发布日期
     *
     * @generated from protobuf enum value: PUBLISH_DATE = 4;
     */
    PUBLISH_DATE = 4,
    /**
     * 自定义排序
     *
     * @generated from protobuf enum value: CUSTOM_SORT = 5;
     */
    CUSTOM_SORT = 5,
    /**
     * 按重要性打分
     *
     * @generated from protobuf enum value: IMPORTANCE_SCORE = 6;
     */
    IMPORTANCE_SCORE = 6,
    /**
     * 按影响因子排序
     *
     * @generated from protobuf enum value: IMPACT_OF_FACTOR = 7;
     */
    IMPACT_OF_FACTOR = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class ManualUpdateDocCiteInfoReq$Type extends MessageType<ManualUpdateDocCiteInfoReq> {
    constructor() {
        super("doc.ManualUpdateDocCiteInfoReq", [
            { no: 1, name: "paperId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pdfId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "docName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "authorList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocAuthorInfo },
            { no: 5, name: "doi", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "publishDate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "venue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "partition", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "docType", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "volume", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "issue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "page", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ManualUpdateDocCiteInfoReq>): ManualUpdateDocCiteInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorList = [];
        if (value !== undefined)
            reflectionMergePartial<ManualUpdateDocCiteInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ManualUpdateDocCiteInfoReq): ManualUpdateDocCiteInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* optional string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* optional string docName */ 3:
                    message.docName = reader.string();
                    break;
                case /* repeated doc.UserDocAuthorInfo authorList */ 4:
                    message.authorList.push(UserDocAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string doi */ 5:
                    message.doi = reader.string();
                    break;
                case /* optional string publishDate */ 6:
                    message.publishDate = reader.string();
                    break;
                case /* optional string venue */ 7:
                    message.venue = reader.string();
                    break;
                case /* optional string partition */ 8:
                    message.partition = reader.string();
                    break;
                case /* optional string docType */ 9:
                    message.docType = reader.string();
                    break;
                case /* optional string volume */ 10:
                    message.volume = reader.string();
                    break;
                case /* optional string issue */ 11:
                    message.issue = reader.string();
                    break;
                case /* optional string page */ 12:
                    message.page = reader.string();
                    break;
                case /* optional string userId */ 13:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ManualUpdateDocCiteInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string paperId = 1; */
        if (message.paperId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* optional string pdfId = 2; */
        if (message.pdfId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* optional string docName = 3; */
        if (message.docName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.docName);
        /* repeated doc.UserDocAuthorInfo authorList = 4; */
        for (let i = 0; i < message.authorList.length; i++)
            UserDocAuthorInfo.internalBinaryWrite(message.authorList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string doi = 5; */
        if (message.doi !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.doi);
        /* optional string publishDate = 6; */
        if (message.publishDate !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.publishDate);
        /* optional string venue = 7; */
        if (message.venue !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.venue);
        /* optional string partition = 8; */
        if (message.partition !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.partition);
        /* optional string docType = 9; */
        if (message.docType !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.docType);
        /* optional string volume = 10; */
        if (message.volume !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.volume);
        /* optional string issue = 11; */
        if (message.issue !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.issue);
        /* optional string page = 12; */
        if (message.page !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.page);
        /* optional string userId = 13; */
        if (message.userId !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.ManualUpdateDocCiteInfoReq
 */
export const ManualUpdateDocCiteInfoReq = new ManualUpdateDocCiteInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchUpdateDocCiteInfoReq$Type extends MessageType<SearchUpdateDocCiteInfoReq> {
    constructor() {
        super("doc.SearchUpdateDocCiteInfoReq", [
            { no: 1, name: "paperId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pdfId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "docName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "authorList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocAuthorInfo },
            { no: 5, name: "doi", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "publishDate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "venue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "partition", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "docType", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "volume", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "issue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "page", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SearchUpdateDocCiteInfoReq>): SearchUpdateDocCiteInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorList = [];
        if (value !== undefined)
            reflectionMergePartial<SearchUpdateDocCiteInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchUpdateDocCiteInfoReq): SearchUpdateDocCiteInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* optional string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* optional string docName */ 3:
                    message.docName = reader.string();
                    break;
                case /* repeated doc.UserDocAuthorInfo authorList */ 4:
                    message.authorList.push(UserDocAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string doi */ 5:
                    message.doi = reader.string();
                    break;
                case /* optional string publishDate */ 6:
                    message.publishDate = reader.string();
                    break;
                case /* optional string venue */ 7:
                    message.venue = reader.string();
                    break;
                case /* optional string partition */ 8:
                    message.partition = reader.string();
                    break;
                case /* optional string docType */ 9:
                    message.docType = reader.string();
                    break;
                case /* optional string volume */ 10:
                    message.volume = reader.string();
                    break;
                case /* optional string issue */ 11:
                    message.issue = reader.string();
                    break;
                case /* optional string page */ 12:
                    message.page = reader.string();
                    break;
                case /* optional string userId */ 13:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchUpdateDocCiteInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string paperId = 1; */
        if (message.paperId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* optional string pdfId = 2; */
        if (message.pdfId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* optional string docName = 3; */
        if (message.docName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.docName);
        /* repeated doc.UserDocAuthorInfo authorList = 4; */
        for (let i = 0; i < message.authorList.length; i++)
            UserDocAuthorInfo.internalBinaryWrite(message.authorList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string doi = 5; */
        if (message.doi !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.doi);
        /* optional string publishDate = 6; */
        if (message.publishDate !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.publishDate);
        /* optional string venue = 7; */
        if (message.venue !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.venue);
        /* optional string partition = 8; */
        if (message.partition !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.partition);
        /* optional string docType = 9; */
        if (message.docType !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.docType);
        /* optional string volume = 10; */
        if (message.volume !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.volume);
        /* optional string issue = 11; */
        if (message.issue !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.issue);
        /* optional string page = 12; */
        if (message.page !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.page);
        /* optional string userId = 13; */
        if (message.userId !== undefined)
            writer.tag(13, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.SearchUpdateDocCiteInfoReq
 */
export const SearchUpdateDocCiteInfoReq = new SearchUpdateDocCiteInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDocCiteInfoResponse$Type extends MessageType<UpdateDocCiteInfoResponse> {
    constructor() {
        super("doc.UpdateDocCiteInfoResponse", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateDocCiteInfoResponse>): UpdateDocCiteInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.message = "";
        message.data = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateDocCiteInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDocCiteInfoResponse): UpdateDocCiteInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* string data */ 3:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateDocCiteInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* string data = 3; */
        if (message.data !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateDocCiteInfoResponse
 */
export const UpdateDocCiteInfoResponse = new UpdateDocCiteInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocRelatedAuthorListReq$Type extends MessageType<GetDocRelatedAuthorListReq> {
    constructor() {
        super("doc.GetDocRelatedAuthorListReq", [
            { no: 1, name: "folderId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocRelatedAuthorListReq>): GetDocRelatedAuthorListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDocRelatedAuthorListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocRelatedAuthorListReq): GetDocRelatedAuthorListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* optional string userId */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocRelatedAuthorListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string folderId = 1; */
        if (message.folderId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* optional string userId = 2; */
        if (message.userId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocRelatedAuthorListReq
 */
export const GetDocRelatedAuthorListReq = new GetDocRelatedAuthorListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocRelatedAuthorListResponse$Type extends MessageType<GetDocRelatedAuthorListResponse> {
    constructor() {
        super("doc.GetDocRelatedAuthorListResponse", [
            { no: 1, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "authorInfos", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocRelatedAuthorListResponse>): GetDocRelatedAuthorListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0;
        message.authorInfos = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocRelatedAuthorListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocRelatedAuthorListResponse): GetDocRelatedAuthorListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                case /* repeated string authorInfos */ 2:
                    message.authorInfos.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocRelatedAuthorListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total = 1; */
        if (message.total !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total);
        /* repeated string authorInfos = 2; */
        for (let i = 0; i < message.authorInfos.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.authorInfos[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocRelatedAuthorListResponse
 */
export const GetDocRelatedAuthorListResponse = new GetDocRelatedAuthorListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocRelatedClassifyListReq$Type extends MessageType<GetDocRelatedClassifyListReq> {
    constructor() {
        super("doc.GetDocRelatedClassifyListReq", [
            { no: 1, name: "folderId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocRelatedClassifyListReq>): GetDocRelatedClassifyListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDocRelatedClassifyListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocRelatedClassifyListReq): GetDocRelatedClassifyListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* optional string userId */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocRelatedClassifyListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string folderId = 1; */
        if (message.folderId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* optional string userId = 2; */
        if (message.userId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocRelatedClassifyListReq
 */
export const GetDocRelatedClassifyListReq = new GetDocRelatedClassifyListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocRelatedClassifyListResponse$Type extends MessageType<GetDocRelatedClassifyListResponse> {
    constructor() {
        super("doc.GetDocRelatedClassifyListResponse", [
            { no: 1, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "classifyInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocClassifyInfo }
        ]);
    }
    create(value?: PartialMessage<GetDocRelatedClassifyListResponse>): GetDocRelatedClassifyListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0;
        message.classifyInfos = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocRelatedClassifyListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocRelatedClassifyListResponse): GetDocRelatedClassifyListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                case /* repeated doc.UserDocClassifyInfo classifyInfos */ 2:
                    message.classifyInfos.push(UserDocClassifyInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocRelatedClassifyListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total = 1; */
        if (message.total !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total);
        /* repeated doc.UserDocClassifyInfo classifyInfos = 2; */
        for (let i = 0; i < message.classifyInfos.length; i++)
            UserDocClassifyInfo.internalBinaryWrite(message.classifyInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocRelatedClassifyListResponse
 */
export const GetDocRelatedClassifyListResponse = new GetDocRelatedClassifyListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocRelatedVenueListReq$Type extends MessageType<GetDocRelatedVenueListReq> {
    constructor() {
        super("doc.GetDocRelatedVenueListReq", [
            { no: 1, name: "folderId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocRelatedVenueListReq>): GetDocRelatedVenueListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDocRelatedVenueListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocRelatedVenueListReq): GetDocRelatedVenueListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                case /* optional string userId */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocRelatedVenueListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string folderId = 1; */
        if (message.folderId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        /* optional string userId = 2; */
        if (message.userId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocRelatedVenueListReq
 */
export const GetDocRelatedVenueListReq = new GetDocRelatedVenueListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocRelatedVenueListResponse$Type extends MessageType<GetDocRelatedVenueListResponse> {
    constructor() {
        super("doc.GetDocRelatedVenueListResponse", [
            { no: 1, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "venueInfos", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocRelatedVenueListResponse>): GetDocRelatedVenueListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0;
        message.venueInfos = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocRelatedVenueListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocRelatedVenueListResponse): GetDocRelatedVenueListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                case /* repeated string venueInfos */ 2:
                    message.venueInfos.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocRelatedVenueListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total = 1; */
        if (message.total !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total);
        /* repeated string venueInfos = 2; */
        for (let i = 0; i < message.venueInfos.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.venueInfos[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocRelatedVenueListResponse
 */
export const GetDocRelatedVenueListResponse = new GetDocRelatedVenueListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocCountReq$Type extends MessageType<GetDocCountReq> {
    constructor() {
        super("doc.GetDocCountReq", []);
    }
    create(value?: PartialMessage<GetDocCountReq>): GetDocCountReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDocCountReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocCountReq): GetDocCountReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocCountReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocCountReq
 */
export const GetDocCountReq = new GetDocCountReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocCountResponse$Type extends MessageType<GetDocCountResponse> {
    constructor() {
        super("doc.GetDocCountResponse", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocCountResponse>): GetDocCountResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<GetDocCountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocCountResponse): GetDocCountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocCountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocCountResponse
 */
export const GetDocCountResponse = new GetDocCountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSingleDocInfoReq$Type extends MessageType<GetSingleDocInfoReq> {
    constructor() {
        super("doc.GetSingleDocInfoReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSingleDocInfoReq>): GetSingleDocInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSingleDocInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSingleDocInfoReq): GetSingleDocInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* optional string userId */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSingleDocInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* optional string userId = 2; */
        if (message.userId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetSingleDocInfoReq
 */
export const GetSingleDocInfoReq = new GetSingleDocInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSingleDocInfoResponse$Type extends MessageType<GetSingleDocInfoResponse> {
    constructor() {
        super("doc.GetSingleDocInfoResponse", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "message", T: () => UserDocInfo }
        ]);
    }
    create(value?: PartialMessage<GetSingleDocInfoResponse>): GetSingleDocInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<GetSingleDocInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSingleDocInfoResponse): GetSingleDocInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* doc.UserDocInfo data */ 3:
                    message.data = UserDocInfo.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSingleDocInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* doc.UserDocInfo data = 3; */
        if (message.data)
            UserDocInfo.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetSingleDocInfoResponse
 */
export const GetSingleDocInfoResponse = new GetSingleDocInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocListReq$Type extends MessageType<GetDocListReq> {
    constructor() {
        super("doc.GetDocListReq", [
            { no: 1, name: "sortType", kind: "enum", opt: true, T: () => ["doc.UserDocListSortType", UserDocListSortType] },
            { no: 2, name: "ascSort", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "classifyIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "authorInfos", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "venueInfos", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "pageSize", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "currentPage", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "folderId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "searchContent", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "extMeta", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "jcrPartions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "impactOfFactorRange", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "onlyShowDocsWithImpactOfFactor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "onlyPdf", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocListReq>): GetDocListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classifyIds = [];
        message.authorInfos = [];
        message.venueInfos = [];
        message.jcrPartions = [];
        message.impactOfFactorRange = [];
        message.onlyShowDocsWithImpactOfFactor = false;
        if (value !== undefined)
            reflectionMergePartial<GetDocListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocListReq): GetDocListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional doc.UserDocListSortType sortType */ 1:
                    message.sortType = reader.int32();
                    break;
                case /* optional bool ascSort */ 2:
                    message.ascSort = reader.bool();
                    break;
                case /* repeated string classifyIds */ 3:
                    message.classifyIds.push(reader.string());
                    break;
                case /* repeated string authorInfos */ 4:
                    message.authorInfos.push(reader.string());
                    break;
                case /* repeated string venueInfos */ 5:
                    message.venueInfos.push(reader.string());
                    break;
                case /* optional uint32 pageSize */ 6:
                    message.pageSize = reader.uint32();
                    break;
                case /* optional uint32 currentPage */ 7:
                    message.currentPage = reader.uint32();
                    break;
                case /* optional string userId */ 8:
                    message.userId = reader.string();
                    break;
                case /* optional string folderId */ 9:
                    message.folderId = reader.string();
                    break;
                case /* optional string searchContent */ 10:
                    message.searchContent = reader.string();
                    break;
                case /* optional bool extMeta */ 11:
                    message.extMeta = reader.bool();
                    break;
                case /* repeated string jcrPartions */ 12:
                    message.jcrPartions.push(reader.string());
                    break;
                case /* repeated float impactOfFactorRange */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.impactOfFactorRange.push(reader.float());
                    else
                        message.impactOfFactorRange.push(reader.float());
                    break;
                case /* bool onlyShowDocsWithImpactOfFactor */ 14:
                    message.onlyShowDocsWithImpactOfFactor = reader.bool();
                    break;
                case /* optional bool onlyPdf */ 15:
                    message.onlyPdf = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional doc.UserDocListSortType sortType = 1; */
        if (message.sortType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.sortType);
        /* optional bool ascSort = 2; */
        if (message.ascSort !== undefined)
            writer.tag(2, WireType.Varint).bool(message.ascSort);
        /* repeated string classifyIds = 3; */
        for (let i = 0; i < message.classifyIds.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.classifyIds[i]);
        /* repeated string authorInfos = 4; */
        for (let i = 0; i < message.authorInfos.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.authorInfos[i]);
        /* repeated string venueInfos = 5; */
        for (let i = 0; i < message.venueInfos.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.venueInfos[i]);
        /* optional uint32 pageSize = 6; */
        if (message.pageSize !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.pageSize);
        /* optional uint32 currentPage = 7; */
        if (message.currentPage !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.currentPage);
        /* optional string userId = 8; */
        if (message.userId !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.userId);
        /* optional string folderId = 9; */
        if (message.folderId !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.folderId);
        /* optional string searchContent = 10; */
        if (message.searchContent !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.searchContent);
        /* optional bool extMeta = 11; */
        if (message.extMeta !== undefined)
            writer.tag(11, WireType.Varint).bool(message.extMeta);
        /* repeated string jcrPartions = 12; */
        for (let i = 0; i < message.jcrPartions.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.jcrPartions[i]);
        /* repeated float impactOfFactorRange = 13; */
        if (message.impactOfFactorRange.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.impactOfFactorRange.length; i++)
                writer.float(message.impactOfFactorRange[i]);
            writer.join();
        }
        /* bool onlyShowDocsWithImpactOfFactor = 14; */
        if (message.onlyShowDocsWithImpactOfFactor !== false)
            writer.tag(14, WireType.Varint).bool(message.onlyShowDocsWithImpactOfFactor);
        /* optional bool onlyPdf = 15; */
        if (message.onlyPdf !== undefined)
            writer.tag(15, WireType.Varint).bool(message.onlyPdf);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocListReq
 */
export const GetDocListReq = new GetDocListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocListResponse$Type extends MessageType<GetDocListResponse> {
    constructor() {
        super("doc.GetDocListResponse", [
            { no: 1, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "docList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocInfo }
        ]);
    }
    create(value?: PartialMessage<GetDocListResponse>): GetDocListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total = 0;
        message.docList = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocListResponse): GetDocListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total */ 1:
                    message.total = reader.uint32();
                    break;
                case /* repeated doc.UserDocInfo docList */ 2:
                    message.docList.push(UserDocInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total = 1; */
        if (message.total !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total);
        /* repeated doc.UserDocInfo docList = 2; */
        for (let i = 0; i < message.docList.length; i++)
            UserDocInfo.internalBinaryWrite(message.docList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocListResponse
 */
export const GetDocListResponse = new GetDocListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocIndexReq$Type extends MessageType<GetDocIndexReq> {
    constructor() {
        super("doc.GetDocIndexReq", [
            { no: 1, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDocIndexReq>): GetDocIndexReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDocIndexReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocIndexReq): GetDocIndexReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string userId */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocIndexReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string userId = 1; */
        if (message.userId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocIndexReq
 */
export const GetDocIndexReq = new GetDocIndexReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocInfo$Type extends MessageType<UserDocInfo> {
    constructor() {
        super("doc.UserDocInfo", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "pdfId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "remark", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "createDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "lastReadTime", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "isLatestRead", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "noteId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "newPaper", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "classifyInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocClassifyInfo },
            { no: 13, name: "paperRepositoryStatus", kind: "enum", T: () => ["doc.PaperRepositoryStatus", PaperRepositoryStatus] },
            { no: 14, name: "displayAuthor", kind: "message", T: () => UserDocDisplayAuthor },
            { no: 15, name: "displayVenue", kind: "message", T: () => UserDocDisplayVenue },
            { no: 16, name: "displayPublishDate", kind: "message", T: () => UserDocDisplayPublishDate },
            { no: 17, name: "displayPage", kind: "message", T: () => UserDocDisplayPage },
            { no: 18, name: "displayDocType", kind: "message", T: () => UserDocDisplayDocType },
            { no: 19, name: "displayEventInfo", kind: "message", T: () => UserDocDisplayEventInfo },
            { no: 20, name: "displayUrl", kind: "message", T: () => UserDocDisplayUrl },
            { no: 21, name: "displayLanguage", kind: "message", T: () => UserDocDisplayLanguage },
            { no: 22, name: "displayDoi", kind: "message", T: () => UserDocDisplayDoi },
            { no: 23, name: "displayVolume", kind: "message", T: () => UserDocDisplayVolume },
            { no: 24, name: "displayIssue", kind: "message", T: () => UserDocDisplayIssue },
            { no: 25, name: "displayPartition", kind: "message", T: () => UserDocDisplayPartition },
            { no: 26, name: "searchResult", kind: "message", T: () => DocSearchResult },
            { no: 27, name: "hasAttachment", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "jcrVenuePartion", kind: "message", T: () => UserDocDisplayJcrVenuePartion },
            { no: 29, name: "importantanceScore", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 30, name: "impactOfFactor", kind: "message", T: () => UserDocDisplayJcrImpactFactor },
            { no: 31, name: "docReadingStatus", kind: "enum", T: () => ["doc.DocReadingStatus", DocReadingStatus] },
            { no: 32, name: "progress", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 33, name: "fillExtMeta", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "parsedStatus", kind: "enum", T: () => ["doc.UserDocParsedStatusEnum", UserDocParsedStatusEnum] },
            { no: 35, name: "embeddingStatus", kind: "enum", T: () => ["doc.UserDocParsedStatusEnum", UserDocParsedStatusEnum] },
            { no: 36, name: "parsedProgress", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocInfo>): UserDocInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.docName = "";
        message.sort = 0;
        message.paperId = "";
        message.createDate = 0n;
        message.isLatestRead = false;
        message.newPaper = false;
        message.classifyInfos = [];
        message.paperRepositoryStatus = 0;
        message.hasAttachment = false;
        message.importantanceScore = 0;
        message.docReadingStatus = 0;
        message.fillExtMeta = false;
        message.parsedStatus = 0;
        message.embeddingStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<UserDocInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocInfo): UserDocInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                case /* uint32 sort */ 3:
                    message.sort = reader.uint32();
                    break;
                case /* string paperId */ 4:
                    message.paperId = reader.string();
                    break;
                case /* optional string pdfId */ 5:
                    message.pdfId = reader.string();
                    break;
                case /* optional string remark */ 6:
                    message.remark = reader.string();
                    break;
                case /* uint64 createDate */ 7:
                    message.createDate = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 lastReadTime */ 8:
                    message.lastReadTime = reader.uint64().toBigInt();
                    break;
                case /* bool isLatestRead */ 9:
                    message.isLatestRead = reader.bool();
                    break;
                case /* optional string noteId */ 10:
                    message.noteId = reader.string();
                    break;
                case /* bool newPaper */ 11:
                    message.newPaper = reader.bool();
                    break;
                case /* repeated doc.UserDocClassifyInfo classifyInfos */ 12:
                    message.classifyInfos.push(UserDocClassifyInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* doc.PaperRepositoryStatus paperRepositoryStatus */ 13:
                    message.paperRepositoryStatus = reader.int32();
                    break;
                case /* doc.UserDocDisplayAuthor displayAuthor */ 14:
                    message.displayAuthor = UserDocDisplayAuthor.internalBinaryRead(reader, reader.uint32(), options, message.displayAuthor);
                    break;
                case /* doc.UserDocDisplayVenue displayVenue */ 15:
                    message.displayVenue = UserDocDisplayVenue.internalBinaryRead(reader, reader.uint32(), options, message.displayVenue);
                    break;
                case /* doc.UserDocDisplayPublishDate displayPublishDate */ 16:
                    message.displayPublishDate = UserDocDisplayPublishDate.internalBinaryRead(reader, reader.uint32(), options, message.displayPublishDate);
                    break;
                case /* optional doc.UserDocDisplayPage displayPage */ 17:
                    message.displayPage = UserDocDisplayPage.internalBinaryRead(reader, reader.uint32(), options, message.displayPage);
                    break;
                case /* optional doc.UserDocDisplayDocType displayDocType */ 18:
                    message.displayDocType = UserDocDisplayDocType.internalBinaryRead(reader, reader.uint32(), options, message.displayDocType);
                    break;
                case /* optional doc.UserDocDisplayEventInfo displayEventInfo */ 19:
                    message.displayEventInfo = UserDocDisplayEventInfo.internalBinaryRead(reader, reader.uint32(), options, message.displayEventInfo);
                    break;
                case /* optional doc.UserDocDisplayUrl displayUrl */ 20:
                    message.displayUrl = UserDocDisplayUrl.internalBinaryRead(reader, reader.uint32(), options, message.displayUrl);
                    break;
                case /* optional doc.UserDocDisplayLanguage displayLanguage */ 21:
                    message.displayLanguage = UserDocDisplayLanguage.internalBinaryRead(reader, reader.uint32(), options, message.displayLanguage);
                    break;
                case /* optional doc.UserDocDisplayDoi displayDoi */ 22:
                    message.displayDoi = UserDocDisplayDoi.internalBinaryRead(reader, reader.uint32(), options, message.displayDoi);
                    break;
                case /* optional doc.UserDocDisplayVolume displayVolume */ 23:
                    message.displayVolume = UserDocDisplayVolume.internalBinaryRead(reader, reader.uint32(), options, message.displayVolume);
                    break;
                case /* optional doc.UserDocDisplayIssue displayIssue */ 24:
                    message.displayIssue = UserDocDisplayIssue.internalBinaryRead(reader, reader.uint32(), options, message.displayIssue);
                    break;
                case /* optional doc.UserDocDisplayPartition displayPartition */ 25:
                    message.displayPartition = UserDocDisplayPartition.internalBinaryRead(reader, reader.uint32(), options, message.displayPartition);
                    break;
                case /* optional doc.DocSearchResult searchResult */ 26:
                    message.searchResult = DocSearchResult.internalBinaryRead(reader, reader.uint32(), options, message.searchResult);
                    break;
                case /* bool hasAttachment */ 27:
                    message.hasAttachment = reader.bool();
                    break;
                case /* optional doc.UserDocDisplayJcrVenuePartion jcrVenuePartion */ 28:
                    message.jcrVenuePartion = UserDocDisplayJcrVenuePartion.internalBinaryRead(reader, reader.uint32(), options, message.jcrVenuePartion);
                    break;
                case /* int32 importantanceScore */ 29:
                    message.importantanceScore = reader.int32();
                    break;
                case /* optional doc.UserDocDisplayJcrImpactFactor impactOfFactor */ 30:
                    message.impactOfFactor = UserDocDisplayJcrImpactFactor.internalBinaryRead(reader, reader.uint32(), options, message.impactOfFactor);
                    break;
                case /* doc.DocReadingStatus docReadingStatus */ 31:
                    message.docReadingStatus = reader.int32();
                    break;
                case /* optional int32 progress */ 32:
                    message.progress = reader.int32();
                    break;
                case /* bool fillExtMeta */ 33:
                    message.fillExtMeta = reader.bool();
                    break;
                case /* doc.UserDocParsedStatusEnum parsedStatus */ 34:
                    message.parsedStatus = reader.int32();
                    break;
                case /* doc.UserDocParsedStatusEnum embeddingStatus */ 35:
                    message.embeddingStatus = reader.int32();
                    break;
                case /* optional string parsedProgress */ 36:
                    message.parsedProgress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        /* uint32 sort = 3; */
        if (message.sort !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sort);
        /* string paperId = 4; */
        if (message.paperId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.paperId);
        /* optional string pdfId = 5; */
        if (message.pdfId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.pdfId);
        /* optional string remark = 6; */
        if (message.remark !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.remark);
        /* uint64 createDate = 7; */
        if (message.createDate !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.createDate);
        /* optional uint64 lastReadTime = 8; */
        if (message.lastReadTime !== undefined)
            writer.tag(8, WireType.Varint).uint64(message.lastReadTime);
        /* bool isLatestRead = 9; */
        if (message.isLatestRead !== false)
            writer.tag(9, WireType.Varint).bool(message.isLatestRead);
        /* optional string noteId = 10; */
        if (message.noteId !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.noteId);
        /* bool newPaper = 11; */
        if (message.newPaper !== false)
            writer.tag(11, WireType.Varint).bool(message.newPaper);
        /* repeated doc.UserDocClassifyInfo classifyInfos = 12; */
        for (let i = 0; i < message.classifyInfos.length; i++)
            UserDocClassifyInfo.internalBinaryWrite(message.classifyInfos[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* doc.PaperRepositoryStatus paperRepositoryStatus = 13; */
        if (message.paperRepositoryStatus !== 0)
            writer.tag(13, WireType.Varint).int32(message.paperRepositoryStatus);
        /* doc.UserDocDisplayAuthor displayAuthor = 14; */
        if (message.displayAuthor)
            UserDocDisplayAuthor.internalBinaryWrite(message.displayAuthor, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* doc.UserDocDisplayVenue displayVenue = 15; */
        if (message.displayVenue)
            UserDocDisplayVenue.internalBinaryWrite(message.displayVenue, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* doc.UserDocDisplayPublishDate displayPublishDate = 16; */
        if (message.displayPublishDate)
            UserDocDisplayPublishDate.internalBinaryWrite(message.displayPublishDate, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayPage displayPage = 17; */
        if (message.displayPage)
            UserDocDisplayPage.internalBinaryWrite(message.displayPage, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayDocType displayDocType = 18; */
        if (message.displayDocType)
            UserDocDisplayDocType.internalBinaryWrite(message.displayDocType, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayEventInfo displayEventInfo = 19; */
        if (message.displayEventInfo)
            UserDocDisplayEventInfo.internalBinaryWrite(message.displayEventInfo, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayUrl displayUrl = 20; */
        if (message.displayUrl)
            UserDocDisplayUrl.internalBinaryWrite(message.displayUrl, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayLanguage displayLanguage = 21; */
        if (message.displayLanguage)
            UserDocDisplayLanguage.internalBinaryWrite(message.displayLanguage, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayDoi displayDoi = 22; */
        if (message.displayDoi)
            UserDocDisplayDoi.internalBinaryWrite(message.displayDoi, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayVolume displayVolume = 23; */
        if (message.displayVolume)
            UserDocDisplayVolume.internalBinaryWrite(message.displayVolume, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayIssue displayIssue = 24; */
        if (message.displayIssue)
            UserDocDisplayIssue.internalBinaryWrite(message.displayIssue, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.UserDocDisplayPartition displayPartition = 25; */
        if (message.displayPartition)
            UserDocDisplayPartition.internalBinaryWrite(message.displayPartition, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* optional doc.DocSearchResult searchResult = 26; */
        if (message.searchResult)
            DocSearchResult.internalBinaryWrite(message.searchResult, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* bool hasAttachment = 27; */
        if (message.hasAttachment !== false)
            writer.tag(27, WireType.Varint).bool(message.hasAttachment);
        /* optional doc.UserDocDisplayJcrVenuePartion jcrVenuePartion = 28; */
        if (message.jcrVenuePartion)
            UserDocDisplayJcrVenuePartion.internalBinaryWrite(message.jcrVenuePartion, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* int32 importantanceScore = 29; */
        if (message.importantanceScore !== 0)
            writer.tag(29, WireType.Varint).int32(message.importantanceScore);
        /* optional doc.UserDocDisplayJcrImpactFactor impactOfFactor = 30; */
        if (message.impactOfFactor)
            UserDocDisplayJcrImpactFactor.internalBinaryWrite(message.impactOfFactor, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* doc.DocReadingStatus docReadingStatus = 31; */
        if (message.docReadingStatus !== 0)
            writer.tag(31, WireType.Varint).int32(message.docReadingStatus);
        /* optional int32 progress = 32; */
        if (message.progress !== undefined)
            writer.tag(32, WireType.Varint).int32(message.progress);
        /* bool fillExtMeta = 33; */
        if (message.fillExtMeta !== false)
            writer.tag(33, WireType.Varint).bool(message.fillExtMeta);
        /* doc.UserDocParsedStatusEnum parsedStatus = 34; */
        if (message.parsedStatus !== 0)
            writer.tag(34, WireType.Varint).int32(message.parsedStatus);
        /* doc.UserDocParsedStatusEnum embeddingStatus = 35; */
        if (message.embeddingStatus !== 0)
            writer.tag(35, WireType.Varint).int32(message.embeddingStatus);
        /* optional string parsedProgress = 36; */
        if (message.parsedProgress !== undefined)
            writer.tag(36, WireType.LengthDelimited).string(message.parsedProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocInfo
 */
export const UserDocInfo = new UserDocInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayJcrVenuePartion$Type extends MessageType<UserDocDisplayJcrVenuePartion> {
    constructor() {
        super("doc.UserDocDisplayJcrVenuePartion", [
            { no: 1, name: "jcrVenuePartion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originJcrVenuePartion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayJcrVenuePartion>): UserDocDisplayJcrVenuePartion {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayJcrVenuePartion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayJcrVenuePartion): UserDocDisplayJcrVenuePartion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string jcrVenuePartion */ 1:
                    message.jcrVenuePartion = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originJcrVenuePartion */ 3:
                    message.originJcrVenuePartion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayJcrVenuePartion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string jcrVenuePartion = 1; */
        if (message.jcrVenuePartion !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.jcrVenuePartion);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originJcrVenuePartion = 3; */
        if (message.originJcrVenuePartion !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originJcrVenuePartion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayJcrVenuePartion
 */
export const UserDocDisplayJcrVenuePartion = new UserDocDisplayJcrVenuePartion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayJcrImpactFactor$Type extends MessageType<UserDocDisplayJcrImpactFactor> {
    constructor() {
        super("doc.UserDocDisplayJcrImpactFactor", [
            { no: 1, name: "impactOfFactor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originImpactOfFactor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayJcrImpactFactor>): UserDocDisplayJcrImpactFactor {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayJcrImpactFactor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayJcrImpactFactor): UserDocDisplayJcrImpactFactor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float impactOfFactor */ 1:
                    message.impactOfFactor = reader.float();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional float originImpactOfFactor */ 3:
                    message.originImpactOfFactor = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayJcrImpactFactor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float impactOfFactor = 1; */
        if (message.impactOfFactor !== undefined)
            writer.tag(1, WireType.Bit32).float(message.impactOfFactor);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional float originImpactOfFactor = 3; */
        if (message.originImpactOfFactor !== undefined)
            writer.tag(3, WireType.Bit32).float(message.originImpactOfFactor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayJcrImpactFactor
 */
export const UserDocDisplayJcrImpactFactor = new UserDocDisplayJcrImpactFactor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocSearchResult$Type extends MessageType<DocSearchResult> {
    constructor() {
        super("doc.DocSearchResult", [
            { no: 1, name: "hitDocName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hitNote", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hitRemark", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "hitPublishDate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hitAuthor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "hitVenue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "hitJcrVenuePartion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DocSearchResult>): DocSearchResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DocSearchResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DocSearchResult): DocSearchResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string hitDocName */ 1:
                    message.hitDocName = reader.string();
                    break;
                case /* optional string hitNote */ 2:
                    message.hitNote = reader.string();
                    break;
                case /* optional string hitRemark */ 3:
                    message.hitRemark = reader.string();
                    break;
                case /* optional string hitPublishDate */ 4:
                    message.hitPublishDate = reader.string();
                    break;
                case /* optional string hitAuthor */ 5:
                    message.hitAuthor = reader.string();
                    break;
                case /* optional string hitVenue */ 6:
                    message.hitVenue = reader.string();
                    break;
                case /* optional string hitJcrVenuePartion */ 7:
                    message.hitJcrVenuePartion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DocSearchResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string hitDocName = 1; */
        if (message.hitDocName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.hitDocName);
        /* optional string hitNote = 2; */
        if (message.hitNote !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.hitNote);
        /* optional string hitRemark = 3; */
        if (message.hitRemark !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.hitRemark);
        /* optional string hitPublishDate = 4; */
        if (message.hitPublishDate !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.hitPublishDate);
        /* optional string hitAuthor = 5; */
        if (message.hitAuthor !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.hitAuthor);
        /* optional string hitVenue = 6; */
        if (message.hitVenue !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.hitVenue);
        /* optional string hitJcrVenuePartion = 7; */
        if (message.hitJcrVenuePartion !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.hitJcrVenuePartion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DocSearchResult
 */
export const DocSearchResult = new DocSearchResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocClassifyInfo$Type extends MessageType<UserDocClassifyInfo> {
    constructor() {
        super("doc.UserDocClassifyInfo", [
            { no: 1, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocClassifyInfo>): UserDocClassifyInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classifyId = "";
        message.classifyName = "";
        if (value !== undefined)
            reflectionMergePartial<UserDocClassifyInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocClassifyInfo): UserDocClassifyInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string classifyId */ 1:
                    message.classifyId = reader.string();
                    break;
                case /* string classifyName */ 2:
                    message.classifyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocClassifyInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string classifyId = 1; */
        if (message.classifyId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.classifyId);
        /* string classifyName = 2; */
        if (message.classifyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classifyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocClassifyInfo
 */
export const UserDocClassifyInfo = new UserDocClassifyInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayVolume$Type extends MessageType<UserDocDisplayVolume> {
    constructor() {
        super("doc.UserDocDisplayVolume", [
            { no: 1, name: "volume", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originVolume", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayVolume>): UserDocDisplayVolume {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayVolume): UserDocDisplayVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string volume */ 1:
                    message.volume = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originVolume */ 3:
                    message.originVolume = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string volume = 1; */
        if (message.volume !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.volume);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originVolume = 3; */
        if (message.originVolume !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originVolume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayVolume
 */
export const UserDocDisplayVolume = new UserDocDisplayVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayIssue$Type extends MessageType<UserDocDisplayIssue> {
    constructor() {
        super("doc.UserDocDisplayIssue", [
            { no: 1, name: "issue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originIssue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayIssue>): UserDocDisplayIssue {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayIssue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayIssue): UserDocDisplayIssue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string issue */ 1:
                    message.issue = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originIssue */ 3:
                    message.originIssue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayIssue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string issue = 1; */
        if (message.issue !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.issue);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originIssue = 3; */
        if (message.originIssue !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originIssue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayIssue
 */
export const UserDocDisplayIssue = new UserDocDisplayIssue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayPartition$Type extends MessageType<UserDocDisplayPartition> {
    constructor() {
        super("doc.UserDocDisplayPartition", [
            { no: 1, name: "partition", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originPartition", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayPartition>): UserDocDisplayPartition {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayPartition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayPartition): UserDocDisplayPartition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string partition */ 1:
                    message.partition = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originPartition */ 3:
                    message.originPartition = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayPartition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string partition = 1; */
        if (message.partition !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.partition);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originPartition = 3; */
        if (message.originPartition !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originPartition);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayPartition
 */
export const UserDocDisplayPartition = new UserDocDisplayPartition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayDoi$Type extends MessageType<UserDocDisplayDoi> {
    constructor() {
        super("doc.UserDocDisplayDoi", [
            { no: 1, name: "doi", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originDoi", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayDoi>): UserDocDisplayDoi {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayDoi>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayDoi): UserDocDisplayDoi {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string doi */ 1:
                    message.doi = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originDoi */ 3:
                    message.originDoi = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayDoi, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string doi = 1; */
        if (message.doi !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.doi);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originDoi = 3; */
        if (message.originDoi !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originDoi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayDoi
 */
export const UserDocDisplayDoi = new UserDocDisplayDoi$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayUrl$Type extends MessageType<UserDocDisplayUrl> {
    constructor() {
        super("doc.UserDocDisplayUrl", [
            { no: 1, name: "url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originUrl", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayUrl>): UserDocDisplayUrl {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayUrl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayUrl): UserDocDisplayUrl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string url */ 1:
                    message.url = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originUrl */ 3:
                    message.originUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayUrl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string url = 1; */
        if (message.url !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originUrl = 3; */
        if (message.originUrl !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayUrl
 */
export const UserDocDisplayUrl = new UserDocDisplayUrl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayLanguage$Type extends MessageType<UserDocDisplayLanguage> {
    constructor() {
        super("doc.UserDocDisplayLanguage", [
            { no: 1, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originLanguage", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayLanguage>): UserDocDisplayLanguage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayLanguage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayLanguage): UserDocDisplayLanguage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string language */ 1:
                    message.language = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originLanguage */ 3:
                    message.originLanguage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayLanguage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string language = 1; */
        if (message.language !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originLanguage = 3; */
        if (message.originLanguage !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originLanguage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayLanguage
 */
export const UserDocDisplayLanguage = new UserDocDisplayLanguage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayEventInfo$Type extends MessageType<UserDocDisplayEventInfo> {
    constructor() {
        super("doc.UserDocDisplayEventInfo", [
            { no: 1, name: "eventInfo", kind: "message", T: () => EventInfo },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originEventInfo", kind: "message", T: () => EventInfo }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayEventInfo>): UserDocDisplayEventInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayEventInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayEventInfo): UserDocDisplayEventInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional doc.EventInfo eventInfo */ 1:
                    message.eventInfo = EventInfo.internalBinaryRead(reader, reader.uint32(), options, message.eventInfo);
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional doc.EventInfo originEventInfo */ 3:
                    message.originEventInfo = EventInfo.internalBinaryRead(reader, reader.uint32(), options, message.originEventInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayEventInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional doc.EventInfo eventInfo = 1; */
        if (message.eventInfo)
            EventInfo.internalBinaryWrite(message.eventInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional doc.EventInfo originEventInfo = 3; */
        if (message.originEventInfo)
            EventInfo.internalBinaryWrite(message.originEventInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayEventInfo
 */
export const UserDocDisplayEventInfo = new UserDocDisplayEventInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventInfo$Type extends MessageType<EventInfo> {
    constructor() {
        super("doc.EventInfo", [
            { no: 1, name: "eventTitle", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "eventPlace", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "eventDate", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventInfo>): EventInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventDate = [];
        if (value !== undefined)
            reflectionMergePartial<EventInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventInfo): EventInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string eventTitle */ 1:
                    message.eventTitle = reader.string();
                    break;
                case /* optional string eventPlace */ 2:
                    message.eventPlace = reader.string();
                    break;
                case /* repeated string eventDate */ 3:
                    message.eventDate.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string eventTitle = 1; */
        if (message.eventTitle !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.eventTitle);
        /* optional string eventPlace = 2; */
        if (message.eventPlace !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.eventPlace);
        /* repeated string eventDate = 3; */
        for (let i = 0; i < message.eventDate.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.eventDate[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.EventInfo
 */
export const EventInfo = new EventInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayPage$Type extends MessageType<UserDocDisplayPage> {
    constructor() {
        super("doc.UserDocDisplayPage", [
            { no: 1, name: "page", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originPage", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayPage>): UserDocDisplayPage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayPage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayPage): UserDocDisplayPage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string page */ 1:
                    message.page = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originPage */ 3:
                    message.originPage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayPage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string page = 1; */
        if (message.page !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.page);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originPage = 3; */
        if (message.originPage !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originPage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayPage
 */
export const UserDocDisplayPage = new UserDocDisplayPage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayDocType$Type extends MessageType<UserDocDisplayDocType> {
    constructor() {
        super("doc.UserDocDisplayDocType", [
            { no: 1, name: "docType", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originDocType", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayDocType>): UserDocDisplayDocType {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayDocType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayDocType): UserDocDisplayDocType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string docType */ 1:
                    message.docType = reader.string();
                    break;
                case /* optional bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* optional string originDocType */ 3:
                    message.originDocType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayDocType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string docType = 1; */
        if (message.docType !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.docType);
        /* optional bool userEdited = 2; */
        if (message.userEdited !== undefined)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* optional string originDocType = 3; */
        if (message.originDocType !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.originDocType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayDocType
 */
export const UserDocDisplayDocType = new UserDocDisplayDocType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayVenue$Type extends MessageType<UserDocDisplayVenue> {
    constructor() {
        super("doc.UserDocDisplayVenue", [
            { no: 1, name: "venueInfos", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originVenueInfos", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayVenue>): UserDocDisplayVenue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.venueInfos = [];
        message.userEdited = false;
        message.originVenueInfos = [];
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayVenue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayVenue): UserDocDisplayVenue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string venueInfos */ 1:
                    message.venueInfos.push(reader.string());
                    break;
                case /* bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* repeated string originVenueInfos */ 3:
                    message.originVenueInfos.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayVenue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string venueInfos = 1; */
        for (let i = 0; i < message.venueInfos.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.venueInfos[i]);
        /* bool userEdited = 2; */
        if (message.userEdited !== false)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* repeated string originVenueInfos = 3; */
        for (let i = 0; i < message.originVenueInfos.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.originVenueInfos[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayVenue
 */
export const UserDocDisplayVenue = new UserDocDisplayVenue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayAuthor$Type extends MessageType<UserDocDisplayAuthor> {
    constructor() {
        super("doc.UserDocDisplayAuthor", [
            { no: 1, name: "authorInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocAuthorInfo },
            { no: 2, name: "userEdited", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originAuthorInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocAuthorInfo }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayAuthor>): UserDocDisplayAuthor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorInfos = [];
        message.userEdited = false;
        message.originAuthorInfos = [];
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayAuthor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayAuthor): UserDocDisplayAuthor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated doc.UserDocAuthorInfo authorInfos */ 1:
                    message.authorInfos.push(UserDocAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* repeated doc.UserDocAuthorInfo originAuthorInfos */ 3:
                    message.originAuthorInfos.push(UserDocAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayAuthor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated doc.UserDocAuthorInfo authorInfos = 1; */
        for (let i = 0; i < message.authorInfos.length; i++)
            UserDocAuthorInfo.internalBinaryWrite(message.authorInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool userEdited = 2; */
        if (message.userEdited !== false)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* repeated doc.UserDocAuthorInfo originAuthorInfos = 3; */
        for (let i = 0; i < message.originAuthorInfos.length; i++)
            UserDocAuthorInfo.internalBinaryWrite(message.originAuthorInfos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayAuthor
 */
export const UserDocDisplayAuthor = new UserDocDisplayAuthor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocAuthorInfo$Type extends MessageType<UserDocAuthorInfo> {
    constructor() {
        super("doc.UserDocAuthorInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "given", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "family", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "literal", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "isAuthentication", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocAuthorInfo>): UserDocAuthorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.literal = "";
        message.isAuthentication = false;
        if (value !== undefined)
            reflectionMergePartial<UserDocAuthorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocAuthorInfo): UserDocAuthorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string id */ 1:
                    message.id = reader.string();
                    break;
                case /* optional string given */ 2:
                    message.given = reader.string();
                    break;
                case /* optional string family */ 3:
                    message.family = reader.string();
                    break;
                case /* string literal */ 4:
                    message.literal = reader.string();
                    break;
                case /* bool isAuthentication */ 5:
                    message.isAuthentication = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocAuthorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* optional string given = 2; */
        if (message.given !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.given);
        /* optional string family = 3; */
        if (message.family !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.family);
        /* string literal = 4; */
        if (message.literal !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.literal);
        /* bool isAuthentication = 5; */
        if (message.isAuthentication !== false)
            writer.tag(5, WireType.Varint).bool(message.isAuthentication);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocAuthorInfo
 */
export const UserDocAuthorInfo = new UserDocAuthorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocDisplayPublishDate$Type extends MessageType<UserDocDisplayPublishDate> {
    constructor() {
        super("doc.UserDocDisplayPublishDate", [
            { no: 1, name: "publishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userEdited", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originPublishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocDisplayPublishDate>): UserDocDisplayPublishDate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publishDate = "";
        message.userEdited = false;
        message.originPublishDate = "";
        if (value !== undefined)
            reflectionMergePartial<UserDocDisplayPublishDate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocDisplayPublishDate): UserDocDisplayPublishDate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string publishDate */ 1:
                    message.publishDate = reader.string();
                    break;
                case /* bool userEdited */ 2:
                    message.userEdited = reader.bool();
                    break;
                case /* string originPublishDate */ 3:
                    message.originPublishDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocDisplayPublishDate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string publishDate = 1; */
        if (message.publishDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.publishDate);
        /* bool userEdited = 2; */
        if (message.userEdited !== false)
            writer.tag(2, WireType.Varint).bool(message.userEdited);
        /* string originPublishDate = 3; */
        if (message.originPublishDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originPublishDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocDisplayPublishDate
 */
export const UserDocDisplayPublishDate = new UserDocDisplayPublishDate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarkFinishReq$Type extends MessageType<MarkFinishReq> {
    constructor() {
        super("doc.MarkFinishReq", [
            { no: 1, name: "paperId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarkFinishReq>): MarkFinishReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<MarkFinishReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarkFinishReq): MarkFinishReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarkFinishReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string paperId = 1; */
        if (message.paperId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.MarkFinishReq
 */
export const MarkFinishReq = new MarkFinishReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportanceScoreReq$Type extends MessageType<ImportanceScoreReq> {
    constructor() {
        super("doc.ImportanceScoreReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ImportanceScoreReq>): ImportanceScoreReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.score = 0;
        if (value !== undefined)
            reflectionMergePartial<ImportanceScoreReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImportanceScoreReq): ImportanceScoreReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* int32 score */ 4:
                    message.score = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImportanceScoreReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* int32 score = 4; */
        if (message.score !== 0)
            writer.tag(4, WireType.Varint).int32(message.score);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.ImportanceScoreReq
 */
export const ImportanceScoreReq = new ImportanceScoreReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JcrPartionsReq$Type extends MessageType<JcrPartionsReq> {
    constructor() {
        super("doc.JcrPartionsReq", [
            { no: 1, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JcrPartionsReq>): JcrPartionsReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.folderId = "";
        if (value !== undefined)
            reflectionMergePartial<JcrPartionsReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JcrPartionsReq): JcrPartionsReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string folderId */ 1:
                    message.folderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JcrPartionsReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string folderId = 1; */
        if (message.folderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.folderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.JcrPartionsReq
 */
export const JcrPartionsReq = new JcrPartionsReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JcrPartionsResponse$Type extends MessageType<JcrPartionsResponse> {
    constructor() {
        super("doc.JcrPartionsResponse", [
            { no: 1, name: "jcrPartions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JcrPartionsResponse>): JcrPartionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jcrPartions = [];
        if (value !== undefined)
            reflectionMergePartial<JcrPartionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JcrPartionsResponse): JcrPartionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string jcrPartions */ 1:
                    message.jcrPartions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JcrPartionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string jcrPartions = 1; */
        for (let i = 0; i < message.jcrPartions.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.jcrPartions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.JcrPartionsResponse
 */
export const JcrPartionsResponse = new JcrPartionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImpactFactorReq$Type extends MessageType<ImpactFactorReq> {
    constructor() {
        super("doc.ImpactFactorReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "impactOfFactor", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ImpactFactorReq>): ImpactFactorReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        if (value !== undefined)
            reflectionMergePartial<ImpactFactorReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImpactFactorReq): ImpactFactorReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* optional float impactOfFactor */ 2:
                    message.impactOfFactor = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImpactFactorReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* optional float impactOfFactor = 2; */
        if (message.impactOfFactor !== undefined)
            writer.tag(2, WireType.Bit32).float(message.impactOfFactor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.ImpactFactorReq
 */
export const ImpactFactorReq = new ImpactFactorReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImpactFactorResponse$Type extends MessageType<ImpactFactorResponse> {
    constructor() {
        super("doc.ImpactFactorResponse", [
            { no: 1, name: "originalImpactOfFactor", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "rollbackEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "currentImpactOfFactor", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ImpactFactorResponse>): ImpactFactorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.originalImpactOfFactor = 0;
        message.rollbackEnable = false;
        message.currentImpactOfFactor = 0;
        if (value !== undefined)
            reflectionMergePartial<ImpactFactorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImpactFactorResponse): ImpactFactorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float originalImpactOfFactor */ 1:
                    message.originalImpactOfFactor = reader.float();
                    break;
                case /* bool rollbackEnable */ 2:
                    message.rollbackEnable = reader.bool();
                    break;
                case /* float currentImpactOfFactor */ 3:
                    message.currentImpactOfFactor = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImpactFactorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float originalImpactOfFactor = 1; */
        if (message.originalImpactOfFactor !== 0)
            writer.tag(1, WireType.Bit32).float(message.originalImpactOfFactor);
        /* bool rollbackEnable = 2; */
        if (message.rollbackEnable !== false)
            writer.tag(2, WireType.Varint).bool(message.rollbackEnable);
        /* float currentImpactOfFactor = 3; */
        if (message.currentImpactOfFactor !== 0)
            writer.tag(3, WireType.Bit32).float(message.currentImpactOfFactor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.ImpactFactorResponse
 */
export const ImpactFactorResponse = new ImpactFactorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JcrPartionUpdateReq$Type extends MessageType<JcrPartionUpdateReq> {
    constructor() {
        super("doc.JcrPartionUpdateReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "jcrPartion", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JcrPartionUpdateReq>): JcrPartionUpdateReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.jcrPartion = "";
        if (value !== undefined)
            reflectionMergePartial<JcrPartionUpdateReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JcrPartionUpdateReq): JcrPartionUpdateReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string jcrPartion */ 2:
                    message.jcrPartion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JcrPartionUpdateReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string jcrPartion = 2; */
        if (message.jcrPartion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.jcrPartion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.JcrPartionUpdateReq
 */
export const JcrPartionUpdateReq = new JcrPartionUpdateReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JcrPartionUpdateResponse$Type extends MessageType<JcrPartionUpdateResponse> {
    constructor() {
        super("doc.JcrPartionUpdateResponse", [
            { no: 1, name: "originalJcrPartion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rollbackEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "currentJcrPartion", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JcrPartionUpdateResponse>): JcrPartionUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.originalJcrPartion = "";
        message.rollbackEnable = false;
        message.currentJcrPartion = "";
        if (value !== undefined)
            reflectionMergePartial<JcrPartionUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JcrPartionUpdateResponse): JcrPartionUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string originalJcrPartion */ 1:
                    message.originalJcrPartion = reader.string();
                    break;
                case /* bool rollbackEnable */ 2:
                    message.rollbackEnable = reader.bool();
                    break;
                case /* string currentJcrPartion */ 3:
                    message.currentJcrPartion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JcrPartionUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string originalJcrPartion = 1; */
        if (message.originalJcrPartion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.originalJcrPartion);
        /* bool rollbackEnable = 2; */
        if (message.rollbackEnable !== false)
            writer.tag(2, WireType.Varint).bool(message.rollbackEnable);
        /* string currentJcrPartion = 3; */
        if (message.currentJcrPartion !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentJcrPartion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.JcrPartionUpdateResponse
 */
export const JcrPartionUpdateResponse = new JcrPartionUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDocRemarkReq$Type extends MessageType<UpdateDocRemarkReq> {
    constructor() {
        super("doc.UpdateDocRemarkReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateDocRemarkReq>): UpdateDocRemarkReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.remark = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateDocRemarkReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDocRemarkReq): UpdateDocRemarkReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string remark */ 2:
                    message.remark = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateDocRemarkReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string remark = 2; */
        if (message.remark !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remark);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateDocRemarkReq
 */
export const UpdateDocRemarkReq = new UpdateDocRemarkReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateReadStatusRequest$Type extends MessageType<UpdateReadStatusRequest> {
    constructor() {
        super("doc.UpdateReadStatusRequest", [
            { no: 1, name: "paperId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "enum", opt: true, T: () => ["doc.DocReadingStatus", DocReadingStatus] },
            { no: 4, name: "progress", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateReadStatusRequest>): UpdateReadStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateReadStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateReadStatusRequest): UpdateReadStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* optional doc.DocReadingStatus status */ 3:
                    message.status = reader.int32();
                    break;
                case /* optional int32 progress */ 4:
                    message.progress = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateReadStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string paperId = 1; */
        if (message.paperId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* optional doc.DocReadingStatus status = 3; */
        if (message.status !== undefined)
            writer.tag(3, WireType.Varint).int32(message.status);
        /* optional int32 progress = 4; */
        if (message.progress !== undefined)
            writer.tag(4, WireType.Varint).int32(message.progress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateReadStatusRequest
 */
export const UpdateReadStatusRequest = new UpdateReadStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteClassifyReq$Type extends MessageType<DeleteClassifyReq> {
    constructor() {
        super("doc.DeleteClassifyReq", [
            { no: 1, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteClassifyReq>): DeleteClassifyReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classifyId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteClassifyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteClassifyReq): DeleteClassifyReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string classifyId */ 1:
                    message.classifyId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteClassifyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string classifyId = 1; */
        if (message.classifyId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.classifyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DeleteClassifyReq
 */
export const DeleteClassifyReq = new DeleteClassifyReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateClassifyReq$Type extends MessageType<UpdateClassifyReq> {
    constructor() {
        super("doc.UpdateClassifyReq", [
            { no: 1, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateClassifyReq>): UpdateClassifyReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classifyId = "";
        message.classifyName = "";
        message.remark = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateClassifyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateClassifyReq): UpdateClassifyReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string classifyId */ 1:
                    message.classifyId = reader.string();
                    break;
                case /* string classifyName */ 2:
                    message.classifyName = reader.string();
                    break;
                case /* string remark */ 3:
                    message.remark = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateClassifyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string classifyId = 1; */
        if (message.classifyId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.classifyId);
        /* string classifyName = 2; */
        if (message.classifyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classifyName);
        /* string remark = 3; */
        if (message.remark !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.remark);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateClassifyReq
 */
export const UpdateClassifyReq = new UpdateClassifyReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddClassifyReq$Type extends MessageType<AddClassifyReq> {
    constructor() {
        super("doc.AddClassifyReq", [
            { no: 1, name: "classifyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddClassifyReq>): AddClassifyReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classifyName = "";
        message.remark = "";
        if (value !== undefined)
            reflectionMergePartial<AddClassifyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddClassifyReq): AddClassifyReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string classifyName */ 1:
                    message.classifyName = reader.string();
                    break;
                case /* string remark */ 2:
                    message.remark = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddClassifyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string classifyName = 1; */
        if (message.classifyName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.classifyName);
        /* string remark = 2; */
        if (message.remark !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remark);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AddClassifyReq
 */
export const AddClassifyReq = new AddClassifyReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddClassifyResponse$Type extends MessageType<AddClassifyResponse> {
    constructor() {
        super("doc.AddClassifyResponse", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "classifyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddClassifyResponse>): AddClassifyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.classifyId = "";
        message.classifyName = "";
        if (value !== undefined)
            reflectionMergePartial<AddClassifyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddClassifyResponse): AddClassifyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string classifyId */ 2:
                    message.classifyId = reader.string();
                    break;
                case /* string classifyName */ 3:
                    message.classifyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddClassifyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string classifyId = 2; */
        if (message.classifyId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classifyId);
        /* string classifyName = 3; */
        if (message.classifyName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classifyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AddClassifyResponse
 */
export const AddClassifyResponse = new AddClassifyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttachDocToClassifyReq$Type extends MessageType<AttachDocToClassifyReq> {
    constructor() {
        super("doc.AttachDocToClassifyReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "classifyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttachDocToClassifyReq>): AttachDocToClassifyReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.classifyId = "";
        message.classifyName = "";
        if (value !== undefined)
            reflectionMergePartial<AttachDocToClassifyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttachDocToClassifyReq): AttachDocToClassifyReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string classifyId */ 2:
                    message.classifyId = reader.string();
                    break;
                case /* string classifyName */ 3:
                    message.classifyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttachDocToClassifyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string classifyId = 2; */
        if (message.classifyId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classifyId);
        /* string classifyName = 3; */
        if (message.classifyName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classifyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.AttachDocToClassifyReq
 */
export const AttachDocToClassifyReq = new AttachDocToClassifyReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDocClassifyReq$Type extends MessageType<DeleteDocClassifyReq> {
    constructor() {
        super("doc.DeleteDocClassifyReq", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDocClassifyReq>): DeleteDocClassifyReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.classifyId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteDocClassifyReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDocClassifyReq): DeleteDocClassifyReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* string classifyId */ 2:
                    message.classifyId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDocClassifyReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* string classifyId = 2; */
        if (message.classifyId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classifyId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DeleteDocClassifyReq
 */
export const DeleteDocClassifyReq = new DeleteDocClassifyReq$Type();
