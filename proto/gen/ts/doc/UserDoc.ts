// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/doc/UserDoc.proto" (package "doc", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DisplayPublishDate } from "./ClientDoc";
import { DisplayVenue } from "./ClientDoc";
import { UserDocParsedStatusEnum } from "./UserDocParsedStatus";
import { OSSS3Info } from "../oss/OSS";
import { UploadS3Info } from "../oss/OSS";
/**
 * *
 * 	接口描述: 获取minio上传token
 * 	接口url: /userDoc/GetUploadToken
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetUploadTokenReq
 */
export interface GetUploadTokenReq {
    /**
     * @generated from protobuf field: string fileSHA256 = 1
     */
    fileSHA256: string; // 文件fileSHA256值（sha256）
    /**
     * @generated from protobuf field: string fileName = 2
     */
    fileName: string; // 文件名
    /**
     * @generated from protobuf field: string folderId = 3
     */
    folderId: string; // 文件夹ID
    /**
     * @generated from protobuf field: uint64 fileSize = 4
     */
    fileSize: bigint; // 文件大小 单位（字节）
    /**
     * @generated from protobuf field: uint64 filePage = 5
     */
    filePage: bigint; // 文件页数
    /**
     * @generated from protobuf field: string scene = 6
     */
    scene: string; // 场景标识
}
/**
 * @generated from protobuf message doc.GetUploadTokenResp
 */
export interface GetUploadTokenResp {
    /**
     * 是否需要上传
     *
     * @generated from protobuf field: bool needUpload = 1
     */
    needUpload: boolean;
    /**
     * 上传信息
     *
     * @generated from protobuf field: oss.UploadS3Info uploadInfo = 2
     */
    uploadInfo?: UploadS3Info;
    /**
     * oss记录
     *
     * @generated from protobuf field: oss.OSSS3Info ossInfo = 3
     */
    ossInfo?: OSSS3Info;
    /**
     * 是否需要解析
     *
     * @generated from protobuf field: bool needParsed = 4
     */
    needParsed: boolean;
    /**
     * 上传token
     *
     * @generated from protobuf field: string token = 5
     */
    token: string;
}
/**
 * *
 * 	接口描述: 获取用户上传解析pdf状态
 * 	接口url: /userDoc/GetUserDocCreateStatus
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetUserDocCreateStatusRequest
 */
export interface GetUserDocCreateStatusRequest {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * @generated from protobuf message doc.GetUserDocCreateStatusResponse
 */
export interface GetUserDocCreateStatusResponse {
    /**
     * @generated from protobuf field: doc.UserDocParsedStatusEnum status = 1
     */
    status: UserDocParsedStatusEnum;
    /**
     * @generated from protobuf field: string msg = 2
     */
    msg: string;
    /**
     * @generated from protobuf field: string token = 3
     */
    token: string;
    /**
     * @generated from protobuf field: doc.MyCollectedDocInfo docInfo = 4
     */
    docInfo?: MyCollectedDocInfo;
    /**
     * @generated from protobuf field: string pdfId = 5
     */
    pdfId: string;
}
/**
 * @generated from protobuf message doc.MyCollectedDocInfo
 */
export interface MyCollectedDocInfo {
    /**
     * @generated from protobuf field: string ownerNoteId = 11
     */
    ownerNoteId: string;
    /**
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string userId = 10
     */
    userId: string;
    /**
     * @generated from protobuf field: uint32 sort = 3
     */
    sort: number;
    /**
     * @generated from protobuf field: uint32 type = 4
     */
    type: number;
    /**
     * @generated from protobuf field: string remark = 5
     */
    remark: string;
    /**
     * @generated from protobuf field: string docName = 6
     */
    docName: string;
    /**
     * @generated from protobuf field: uint64 lastReadTime = 9
     */
    lastReadTime: bigint;
    /**
     * @generated from protobuf field: repeated doc.UserDocClassifyInformation classifyInfos = 7
     */
    classifyInfos: UserDocClassifyInformation[];
    /**
     * @generated from protobuf field: string id = 8
     */
    id: string;
    /**
     * @generated from protobuf field: bool isLatestRead = 12
     */
    isLatestRead: boolean;
    /**
     * @generated from protobuf field: string paperRepositoryStatus = 13
     */
    paperRepositoryStatus: string;
    /**
     * @generated from protobuf field: repeated string authors = 14
     */
    authors: string[];
    /**
     * @generated from protobuf field: string journal = 15
     */
    journal: string;
    /**
     * @generated from protobuf field: string conference = 16
     */
    conference: string;
    /**
     * @generated from protobuf field: uint64 publishDate = 17
     */
    publishDate: bigint;
}
/**
 * @generated from protobuf message doc.UserDocClassifyInformation
 */
export interface UserDocClassifyInformation {
    /**
     * @generated from protobuf field: string classifyId = 1
     */
    classifyId: string;
    /**
     * @generated from protobuf field: string classifyName = 2
     */
    classifyName: string;
    /**
     * @generated from protobuf field: uint32 docCount = 3
     */
    docCount: number;
    /**
     * @generated from protobuf field: uint32 sort = 5
     */
    sort: number;
    /**
     * @generated from protobuf field: bool isContain = 4
     */
    isContain: boolean;
    /**
     * @generated from protobuf field: string remark = 6
     */
    remark: string;
}
/**
 * *
 * 	接口描述: 查询用户的文献列表 文献列表左侧
 * 	接口url: /userDoc/GetDocIndex
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.GetDocIndexResponse
 */
export interface GetDocIndexResponse {
    /**
     * @generated from protobuf field: uint32 totalDocCount = 1
     */
    totalDocCount: number;
    /**
     * @generated from protobuf field: repeated doc.UserDocFolderInfo folderInfos = 2
     */
    folderInfos: UserDocFolderInfo[];
    /**
     * @generated from protobuf field: repeated doc.SimpleUserDocInfo unclassifiedDocInfos = 3
     */
    unclassifiedDocInfos: SimpleUserDocInfo[];
}
/**
 * @generated from protobuf message doc.UserDocFolderInfo
 */
export interface UserDocFolderInfo {
    /**
     * 文件夹名
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * 文献数
     *
     * @generated from protobuf field: uint32 docCount = 2
     */
    docCount: number;
    /**
     * 父文件夹id
     *
     * @generated from protobuf field: string parentId = 3
     */
    parentId: string;
    /**
     * 文件夹id
     *
     * @generated from protobuf field: string folderId = 4
     */
    folderId: string;
    /**
     * 文件夹层级
     *
     * @generated from protobuf field: uint32 level = 5
     */
    level: number;
    /**
     * 文件夹排序
     *
     * @generated from protobuf field: uint32 sort = 6
     */
    sort: number;
    /**
     * 子文件夹
     *
     * @generated from protobuf field: repeated doc.UserDocFolderInfo childrenFolders = 7
     */
    childrenFolders: UserDocFolderInfo[];
    /**
     * 文献信息
     *
     * @generated from protobuf field: repeated doc.SimpleUserDocInfo docInfos = 8
     */
    docInfos: SimpleUserDocInfo[];
}
/**
 * @generated from protobuf message doc.SimpleUserDocInfo
 */
export interface SimpleUserDocInfo {
    /**
     * 排序
     *
     * @generated from protobuf field: uint32 sort = 1
     */
    sort: number;
    /**
     * 文献名
     *
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
    /**
     * 文献id
     *
     * @generated from protobuf field: string docId = 3
     */
    docId: string;
    /**
     * @generated from protobuf field: string pdfId = 4
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string paperId = 5
     */
    paperId: string;
    /**
     * @generated from protobuf field: string noteId = 6
     */
    noteId: string;
    /**
     * @generated from protobuf field: uint64 modifyDate = 7
     */
    modifyDate: bigint;
}
/**
 * *
 * 	接口描述: 获取用户文献分类列表
 * 	接口url: /userDoc/getUserAllClassifyList
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.getUserAllClassifyListResp
 */
export interface getUserAllClassifyListResp {
    /**
     * @generated from protobuf field: repeated doc.UserDocClassify results = 1
     */
    results: UserDocClassify[];
}
/**
 * @generated from protobuf message doc.UserDocClassify
 */
export interface UserDocClassify {
    /**
     * 文档ID
     *
     * @generated from protobuf field: string doc_id = 1
     */
    doc_id: string;
    /**
     * 分类ID
     *
     * @generated from protobuf field: string classify_id = 2
     */
    classify_id: string;
    /**
     * 分类名称
     *
     * @generated from protobuf field: string classify_name = 3
     */
    classify_name: string;
}
/**
 * *
 * 	接口描述: 获取一个个人文献信息
 * 	接口url: /userDoc/getUserDoc
 * 	接口请求方式: POST
 * 	参数格式:application/json
 * 	响应:doc.DocDetailInfo
 *
 * @generated from protobuf message doc.GetUserDocRequest
 */
export interface GetUserDocRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string noteId = 2
     */
    noteId: string;
}
/**
 * *
 * 	接口描述: 处理秒传文件
 * 	接口url: /userDoc/HandleFileFastUpload
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.HandleFileFastUploadReq
 */
export interface HandleFileFastUploadReq {
    /**
     * 是否需要上传
     *
     * @generated from protobuf field: bool needUpload = 1
     */
    needUpload: boolean;
    /**
     * 上传信息
     *
     * @generated from protobuf field: oss.UploadS3Info uploadInfo = 2
     */
    uploadInfo?: UploadS3Info;
    /**
     * oss记录
     *
     * @generated from protobuf field: oss.OSSS3Info ossInfo = 3
     */
    ossInfo?: OSSS3Info;
}
/**
 * @generated from protobuf message doc.HandleFileFastUploadResp
 */
export interface HandleFileFastUploadResp {
    /**
     * @generated from protobuf field: uint32 status = 1
     */
    status: number;
    /**
     * @generated from protobuf field: string msg = 2
     */
    msg: string;
    /**
     * @generated from protobuf field: string fileSHA256 = 3
     */
    fileSHA256: string;
    /**
     * @generated from protobuf field: doc.MyCollectedDocInfo docInfo = 4
     */
    docInfo?: MyCollectedDocInfo;
    /**
     * @generated from protobuf field: string pdfId = 5
     */
    pdfId: string;
}
/**
 * *
 * 用户手动修改个人文献的收录情况
 * method:PUT
 * url:/userDoc/venue
 *
 * venue传 null 则回滚至官方信息
 *
 * @generated from protobuf message doc.UpdateVenueRequest
 */
export interface UpdateVenueRequest {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: optional string venue = 2
     */
    venue?: string;
}
/**
 * @generated from protobuf message doc.UpdateVenueResponse
 */
export interface UpdateVenueResponse {
    /**
     * @generated from protobuf field: doc.DisplayVenue newVenue = 1
     */
    newVenue?: DisplayVenue;
}
/**
 * *
 * 用户手动修改个人文献的发布时间
 * method:PUT
 * url:/userDoc/publishDate
 *
 * publishDate传 null 则回滚至官方信息
 *
 * @generated from protobuf message doc.UpdatePublishDateRequest
 */
export interface UpdatePublishDateRequest {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: optional string publishDate = 2
     */
    publishDate?: string;
}
/**
 * @generated from protobuf message doc.UpdatePublishDateResponse
 */
export interface UpdatePublishDateResponse {
    /**
     * @generated from protobuf field: doc.DisplayPublishDate newPublishDate = 1
     */
    newPublishDate?: DisplayPublishDate;
}
/**
 * *
 * 用户手动修改个人文献的作者
 * method:PUT
 * url:/userDoc/authors
 *
 * authors 传空列表 null 则回滚至官方信息
 *
 * @generated from protobuf message doc.UpdateAuthorsRequest
 */
export interface UpdateAuthorsRequest {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: repeated doc.BaseAuthorInfo authors = 2
     */
    authors: BaseAuthorInfo[];
}
/**
 * @generated from protobuf message doc.UpdateAuthorsResponse
 */
export interface UpdateAuthorsResponse {
    /**
     * @generated from protobuf field: doc.DisplaySimpleAuthors newAuthor = 1
     */
    newAuthor?: DisplaySimpleAuthors;
}
/**
 * *
 * 获取文献的作者列表
 * method:GET
 * url:/userDoc/authors
 *
 * @generated from protobuf message doc.GetAuthorsRequest
 */
export interface GetAuthorsRequest {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
}
/**
 * @generated from protobuf message doc.GetAuthorsResponse
 */
export interface GetAuthorsResponse {
    /**
     * @generated from protobuf field: doc.DisplaySimpleAuthors displayAuthor = 1
     */
    displayAuthor?: DisplaySimpleAuthors;
}
/**
 * @generated from protobuf message doc.DisplaySimpleAuthors
 */
export interface DisplaySimpleAuthors {
    /**
     * @generated from protobuf field: repeated doc.BaseAuthorInfo authors = 1
     */
    authors: BaseAuthorInfo[];
    /**
     * @generated from protobuf field: bool rollbackEnable = 2
     */
    rollbackEnable: boolean;
    /**
     * @generated from protobuf field: repeated doc.BaseAuthorInfo originAuthors = 3
     */
    originAuthors: BaseAuthorInfo[];
}
/**
 * @generated from protobuf message doc.BaseAuthorInfo
 */
export interface BaseAuthorInfo {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * 是否认证作者
     *
     * @generated from protobuf field: bool isAuthentication = 3
     */
    isAuthentication: boolean;
}
// *
// 获取最近阅读文献
// method:POST
// url:/userDoc/getLatestReadDocList

/**
 * @generated from protobuf message doc.GetLatestReadDocListReq
 */
export interface GetLatestReadDocListReq {
}
/**
 * @generated from protobuf message doc.GetLatestReadDocListResp
 */
export interface GetLatestReadDocListResp {
    /**
     * @generated from protobuf field: repeated doc.LatestReadDocInfo docInfos = 1
     */
    docInfos: LatestReadDocInfo[];
    /**
     * @generated from protobuf field: uint64 currentTime = 2
     */
    currentTime: bigint;
}
/**
 * @generated from protobuf message doc.LatestReadDocInfo
 */
export interface LatestReadDocInfo {
    /**
     * 文献名
     *
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
    /**
     * 文献id
     *
     * @generated from protobuf field: string docId = 3
     */
    docId: string;
    /**
     * @generated from protobuf field: string pdfId = 4
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string paperId = 5
     */
    paperId: string;
    /**
     * @generated from protobuf field: string venue = 6
     */
    venue: string;
    /**
     * @generated from protobuf field: string publishDate = 7
     */
    publishDate: string;
    /**
     * @generated from protobuf field: string remark = 8
     */
    remark: string;
    /**
     * @generated from protobuf field: uint64 lastReadTime = 9
     */
    lastReadTime: bigint;
}
/**
 * @api {post} /api/userDoc/uploadPdfByUrlLink
 * @method post
 * @summary UploadPdfByUrlLink 通过url链接上传pdf
 *
 * @generated from protobuf message doc.UploadPdfByUrlLinkRequest
 */
export interface UploadPdfByUrlLinkRequest {
    /**
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * @generated from protobuf field: string uploadToken = 2
     */
    uploadToken: string;
}
/**
 * @generated from protobuf message doc.UploadPdfByUrlLinkResponse
 */
export interface UploadPdfByUrlLinkResponse {
}
/**
 * *
 * 获取解析的统一token
 * method: POST
 * url: /userDoc/GetParseToken
 *
 * @generated from protobuf message doc.GetParseTokenRequest
 */
export interface GetParseTokenRequest {
}
/**
 * @generated from protobuf message doc.GetParseTokenResponse
 */
export interface GetParseTokenResponse {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * *
 * 	接口描述: 获取用户文献的状态
 * 	接口url: /userDoc/userDocStatusByIds
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message doc.UserDocStatusByIdsRequest
 */
export interface UserDocStatusByIdsRequest {
    /**
     * @generated from protobuf field: repeated string docIds = 1
     */
    docIds: string[];
}
/**
 * @generated from protobuf message doc.UserDocStatusByIdsResponse
 */
export interface UserDocStatusByIdsResponse {
    /**
     * @generated from protobuf field: repeated doc.UserDocStatusByIdsItem items = 1
     */
    items: UserDocStatusByIdsItem[];
}
/**
 * @generated from protobuf message doc.UserDocStatusByIdsItem
 */
export interface UserDocStatusByIdsItem {
    /**
     * @generated from protobuf field: string docId = 1
     */
    docId: string;
    /**
     * @generated from protobuf field: doc.UserDocParsedStatusEnum status = 2
     */
    status: UserDocParsedStatusEnum;
    /**
     * @generated from protobuf field: doc.UserDocParsedStatusEnum embeddingStatus = 3
     */
    embeddingStatus: UserDocParsedStatusEnum;
}
/**
 * 用户文献创建状态
 *
 * @generated from protobuf enum doc.UserDocCreateStatus
 */
export enum UserDocCreateStatus {
    /**
     * @generated from protobuf enum value: UPLOAD = 0;
     */
    UPLOAD = 0,
    /**
     * @generated from protobuf enum value: PARSE = 1;
     */
    PARSE = 1,
    /**
     * @generated from protobuf enum value: MATCH = 2;
     */
    MATCH = 2,
    /**
     * @generated from protobuf enum value: FINISH = 3;
     */
    FINISH = 3,
    /**
     * @generated from protobuf enum value: ERROR = 4;
     */
    ERROR = 4,
    /**
     * @generated from protobuf enum value: CANCEL = 5;
     */
    CANCEL = 5,
    /**
     * @generated from protobuf enum value: CONFLICT = 6;
     */
    CONFLICT = 6,
    /**
     * @generated from protobuf enum value: GROUP_OTHER_VERSION = 7;
     */
    GROUP_OTHER_VERSION = 7,
    /**
     * @generated from protobuf enum value: SELF_OTHER_VERSION = 8;
     */
    SELF_OTHER_VERSION = 8,
    /**
     * @generated from protobuf enum value: DOC_COUNT_OVERFLOW = 9;
     */
    DOC_COUNT_OVERFLOW = 9,
    /**
     * @generated from protobuf enum value: DOC_COUNT_OVERFLOW_FOR_ALL_USER = 10;
     */
    DOC_COUNT_OVERFLOW_FOR_ALL_USER = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class GetUploadTokenReq$Type extends MessageType<GetUploadTokenReq> {
    constructor() {
        super("doc.GetUploadTokenReq", [
            { no: 1, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fileName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "fileSize", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "filePage", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "scene", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUploadTokenReq>): GetUploadTokenReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileSHA256 = "";
        message.fileName = "";
        message.folderId = "";
        message.fileSize = 0n;
        message.filePage = 0n;
        message.scene = "";
        if (value !== undefined)
            reflectionMergePartial<GetUploadTokenReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUploadTokenReq): GetUploadTokenReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fileSHA256 */ 1:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string fileName */ 2:
                    message.fileName = reader.string();
                    break;
                case /* string folderId */ 3:
                    message.folderId = reader.string();
                    break;
                case /* uint64 fileSize */ 4:
                    message.fileSize = reader.uint64().toBigInt();
                    break;
                case /* uint64 filePage */ 5:
                    message.filePage = reader.uint64().toBigInt();
                    break;
                case /* string scene */ 6:
                    message.scene = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUploadTokenReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fileSHA256 = 1; */
        if (message.fileSHA256 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileSHA256);
        /* string fileName = 2; */
        if (message.fileName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fileName);
        /* string folderId = 3; */
        if (message.folderId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.folderId);
        /* uint64 fileSize = 4; */
        if (message.fileSize !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.fileSize);
        /* uint64 filePage = 5; */
        if (message.filePage !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.filePage);
        /* string scene = 6; */
        if (message.scene !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.scene);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetUploadTokenReq
 */
export const GetUploadTokenReq = new GetUploadTokenReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUploadTokenResp$Type extends MessageType<GetUploadTokenResp> {
    constructor() {
        super("doc.GetUploadTokenResp", [
            { no: 1, name: "needUpload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "uploadInfo", kind: "message", T: () => UploadS3Info },
            { no: 3, name: "ossInfo", kind: "message", T: () => OSSS3Info },
            { no: 4, name: "needParsed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUploadTokenResp>): GetUploadTokenResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needUpload = false;
        message.needParsed = false;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetUploadTokenResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUploadTokenResp): GetUploadTokenResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool needUpload */ 1:
                    message.needUpload = reader.bool();
                    break;
                case /* oss.UploadS3Info uploadInfo */ 2:
                    message.uploadInfo = UploadS3Info.internalBinaryRead(reader, reader.uint32(), options, message.uploadInfo);
                    break;
                case /* oss.OSSS3Info ossInfo */ 3:
                    message.ossInfo = OSSS3Info.internalBinaryRead(reader, reader.uint32(), options, message.ossInfo);
                    break;
                case /* bool needParsed */ 4:
                    message.needParsed = reader.bool();
                    break;
                case /* string token */ 5:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUploadTokenResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool needUpload = 1; */
        if (message.needUpload !== false)
            writer.tag(1, WireType.Varint).bool(message.needUpload);
        /* oss.UploadS3Info uploadInfo = 2; */
        if (message.uploadInfo)
            UploadS3Info.internalBinaryWrite(message.uploadInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* oss.OSSS3Info ossInfo = 3; */
        if (message.ossInfo)
            OSSS3Info.internalBinaryWrite(message.ossInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool needParsed = 4; */
        if (message.needParsed !== false)
            writer.tag(4, WireType.Varint).bool(message.needParsed);
        /* string token = 5; */
        if (message.token !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetUploadTokenResp
 */
export const GetUploadTokenResp = new GetUploadTokenResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserDocCreateStatusRequest$Type extends MessageType<GetUserDocCreateStatusRequest> {
    constructor() {
        super("doc.GetUserDocCreateStatusRequest", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserDocCreateStatusRequest>): GetUserDocCreateStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserDocCreateStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserDocCreateStatusRequest): GetUserDocCreateStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserDocCreateStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetUserDocCreateStatusRequest
 */
export const GetUserDocCreateStatusRequest = new GetUserDocCreateStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserDocCreateStatusResponse$Type extends MessageType<GetUserDocCreateStatusResponse> {
    constructor() {
        super("doc.GetUserDocCreateStatusResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["doc.UserDocParsedStatusEnum", UserDocParsedStatusEnum] },
            { no: 2, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "docInfo", kind: "message", T: () => MyCollectedDocInfo },
            { no: 5, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserDocCreateStatusResponse>): GetUserDocCreateStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.msg = "";
        message.token = "";
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserDocCreateStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserDocCreateStatusResponse): GetUserDocCreateStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* doc.UserDocParsedStatusEnum status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string msg */ 2:
                    message.msg = reader.string();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                case /* doc.MyCollectedDocInfo docInfo */ 4:
                    message.docInfo = MyCollectedDocInfo.internalBinaryRead(reader, reader.uint32(), options, message.docInfo);
                    break;
                case /* string pdfId */ 5:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserDocCreateStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* doc.UserDocParsedStatusEnum status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string msg = 2; */
        if (message.msg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.msg);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        /* doc.MyCollectedDocInfo docInfo = 4; */
        if (message.docInfo)
            MyCollectedDocInfo.internalBinaryWrite(message.docInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string pdfId = 5; */
        if (message.pdfId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetUserDocCreateStatusResponse
 */
export const GetUserDocCreateStatusResponse = new GetUserDocCreateStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyCollectedDocInfo$Type extends MessageType<MyCollectedDocInfo> {
    constructor() {
        super("doc.MyCollectedDocInfo", [
            { no: 11, name: "ownerNoteId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "lastReadTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "classifyInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocClassifyInformation },
            { no: 8, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "isLatestRead", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "paperRepositoryStatus", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "authors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "journal", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "conference", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "publishDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MyCollectedDocInfo>): MyCollectedDocInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ownerNoteId = "";
        message.paperId = "";
        message.pdfId = "";
        message.userId = "";
        message.sort = 0;
        message.type = 0;
        message.remark = "";
        message.docName = "";
        message.lastReadTime = 0n;
        message.classifyInfos = [];
        message.id = "";
        message.isLatestRead = false;
        message.paperRepositoryStatus = "";
        message.authors = [];
        message.journal = "";
        message.conference = "";
        message.publishDate = 0n;
        if (value !== undefined)
            reflectionMergePartial<MyCollectedDocInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyCollectedDocInfo): MyCollectedDocInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ownerNoteId */ 11:
                    message.ownerNoteId = reader.string();
                    break;
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* string userId */ 10:
                    message.userId = reader.string();
                    break;
                case /* uint32 sort */ 3:
                    message.sort = reader.uint32();
                    break;
                case /* uint32 type */ 4:
                    message.type = reader.uint32();
                    break;
                case /* string remark */ 5:
                    message.remark = reader.string();
                    break;
                case /* string docName */ 6:
                    message.docName = reader.string();
                    break;
                case /* uint64 lastReadTime */ 9:
                    message.lastReadTime = reader.uint64().toBigInt();
                    break;
                case /* repeated doc.UserDocClassifyInformation classifyInfos */ 7:
                    message.classifyInfos.push(UserDocClassifyInformation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string id */ 8:
                    message.id = reader.string();
                    break;
                case /* bool isLatestRead */ 12:
                    message.isLatestRead = reader.bool();
                    break;
                case /* string paperRepositoryStatus */ 13:
                    message.paperRepositoryStatus = reader.string();
                    break;
                case /* repeated string authors */ 14:
                    message.authors.push(reader.string());
                    break;
                case /* string journal */ 15:
                    message.journal = reader.string();
                    break;
                case /* string conference */ 16:
                    message.conference = reader.string();
                    break;
                case /* uint64 publishDate */ 17:
                    message.publishDate = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyCollectedDocInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* uint32 sort = 3; */
        if (message.sort !== 0)
            writer.tag(3, WireType.Varint).uint32(message.sort);
        /* uint32 type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).uint32(message.type);
        /* string remark = 5; */
        if (message.remark !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.remark);
        /* string docName = 6; */
        if (message.docName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.docName);
        /* repeated doc.UserDocClassifyInformation classifyInfos = 7; */
        for (let i = 0; i < message.classifyInfos.length; i++)
            UserDocClassifyInformation.internalBinaryWrite(message.classifyInfos[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string id = 8; */
        if (message.id !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.id);
        /* uint64 lastReadTime = 9; */
        if (message.lastReadTime !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.lastReadTime);
        /* string userId = 10; */
        if (message.userId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.userId);
        /* string ownerNoteId = 11; */
        if (message.ownerNoteId !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.ownerNoteId);
        /* bool isLatestRead = 12; */
        if (message.isLatestRead !== false)
            writer.tag(12, WireType.Varint).bool(message.isLatestRead);
        /* string paperRepositoryStatus = 13; */
        if (message.paperRepositoryStatus !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.paperRepositoryStatus);
        /* repeated string authors = 14; */
        for (let i = 0; i < message.authors.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.authors[i]);
        /* string journal = 15; */
        if (message.journal !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.journal);
        /* string conference = 16; */
        if (message.conference !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.conference);
        /* uint64 publishDate = 17; */
        if (message.publishDate !== 0n)
            writer.tag(17, WireType.Varint).uint64(message.publishDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.MyCollectedDocInfo
 */
export const MyCollectedDocInfo = new MyCollectedDocInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocClassifyInformation$Type extends MessageType<UserDocClassifyInformation> {
    constructor() {
        super("doc.UserDocClassifyInformation", [
            { no: 1, name: "classifyId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "docCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "isContain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocClassifyInformation>): UserDocClassifyInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.classifyId = "";
        message.classifyName = "";
        message.docCount = 0;
        message.sort = 0;
        message.isContain = false;
        message.remark = "";
        if (value !== undefined)
            reflectionMergePartial<UserDocClassifyInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocClassifyInformation): UserDocClassifyInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string classifyId */ 1:
                    message.classifyId = reader.string();
                    break;
                case /* string classifyName */ 2:
                    message.classifyName = reader.string();
                    break;
                case /* uint32 docCount */ 3:
                    message.docCount = reader.uint32();
                    break;
                case /* uint32 sort */ 5:
                    message.sort = reader.uint32();
                    break;
                case /* bool isContain */ 4:
                    message.isContain = reader.bool();
                    break;
                case /* string remark */ 6:
                    message.remark = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocClassifyInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string classifyId = 1; */
        if (message.classifyId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.classifyId);
        /* string classifyName = 2; */
        if (message.classifyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classifyName);
        /* uint32 docCount = 3; */
        if (message.docCount !== 0)
            writer.tag(3, WireType.Varint).uint32(message.docCount);
        /* bool isContain = 4; */
        if (message.isContain !== false)
            writer.tag(4, WireType.Varint).bool(message.isContain);
        /* uint32 sort = 5; */
        if (message.sort !== 0)
            writer.tag(5, WireType.Varint).uint32(message.sort);
        /* string remark = 6; */
        if (message.remark !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.remark);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocClassifyInformation
 */
export const UserDocClassifyInformation = new UserDocClassifyInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDocIndexResponse$Type extends MessageType<GetDocIndexResponse> {
    constructor() {
        super("doc.GetDocIndexResponse", [
            { no: 1, name: "totalDocCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "folderInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocFolderInfo },
            { no: 3, name: "unclassifiedDocInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SimpleUserDocInfo }
        ]);
    }
    create(value?: PartialMessage<GetDocIndexResponse>): GetDocIndexResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalDocCount = 0;
        message.folderInfos = [];
        message.unclassifiedDocInfos = [];
        if (value !== undefined)
            reflectionMergePartial<GetDocIndexResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDocIndexResponse): GetDocIndexResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 totalDocCount */ 1:
                    message.totalDocCount = reader.uint32();
                    break;
                case /* repeated doc.UserDocFolderInfo folderInfos */ 2:
                    message.folderInfos.push(UserDocFolderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated doc.SimpleUserDocInfo unclassifiedDocInfos */ 3:
                    message.unclassifiedDocInfos.push(SimpleUserDocInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDocIndexResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 totalDocCount = 1; */
        if (message.totalDocCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.totalDocCount);
        /* repeated doc.UserDocFolderInfo folderInfos = 2; */
        for (let i = 0; i < message.folderInfos.length; i++)
            UserDocFolderInfo.internalBinaryWrite(message.folderInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated doc.SimpleUserDocInfo unclassifiedDocInfos = 3; */
        for (let i = 0; i < message.unclassifiedDocInfos.length; i++)
            SimpleUserDocInfo.internalBinaryWrite(message.unclassifiedDocInfos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetDocIndexResponse
 */
export const GetDocIndexResponse = new GetDocIndexResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocFolderInfo$Type extends MessageType<UserDocFolderInfo> {
    constructor() {
        super("doc.UserDocFolderInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "docCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "parentId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "folderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "childrenFolders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocFolderInfo },
            { no: 8, name: "docInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SimpleUserDocInfo }
        ]);
    }
    create(value?: PartialMessage<UserDocFolderInfo>): UserDocFolderInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.docCount = 0;
        message.parentId = "";
        message.folderId = "";
        message.level = 0;
        message.sort = 0;
        message.childrenFolders = [];
        message.docInfos = [];
        if (value !== undefined)
            reflectionMergePartial<UserDocFolderInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocFolderInfo): UserDocFolderInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 docCount */ 2:
                    message.docCount = reader.uint32();
                    break;
                case /* string parentId */ 3:
                    message.parentId = reader.string();
                    break;
                case /* string folderId */ 4:
                    message.folderId = reader.string();
                    break;
                case /* uint32 level */ 5:
                    message.level = reader.uint32();
                    break;
                case /* uint32 sort */ 6:
                    message.sort = reader.uint32();
                    break;
                case /* repeated doc.UserDocFolderInfo childrenFolders */ 7:
                    message.childrenFolders.push(UserDocFolderInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated doc.SimpleUserDocInfo docInfos */ 8:
                    message.docInfos.push(SimpleUserDocInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocFolderInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 docCount = 2; */
        if (message.docCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.docCount);
        /* string parentId = 3; */
        if (message.parentId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.parentId);
        /* string folderId = 4; */
        if (message.folderId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.folderId);
        /* uint32 level = 5; */
        if (message.level !== 0)
            writer.tag(5, WireType.Varint).uint32(message.level);
        /* uint32 sort = 6; */
        if (message.sort !== 0)
            writer.tag(6, WireType.Varint).uint32(message.sort);
        /* repeated doc.UserDocFolderInfo childrenFolders = 7; */
        for (let i = 0; i < message.childrenFolders.length; i++)
            UserDocFolderInfo.internalBinaryWrite(message.childrenFolders[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated doc.SimpleUserDocInfo docInfos = 8; */
        for (let i = 0; i < message.docInfos.length; i++)
            SimpleUserDocInfo.internalBinaryWrite(message.docInfos[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocFolderInfo
 */
export const UserDocFolderInfo = new UserDocFolderInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleUserDocInfo$Type extends MessageType<SimpleUserDocInfo> {
    constructor() {
        super("doc.SimpleUserDocInfo", [
            { no: 1, name: "sort", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "modifyDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleUserDocInfo>): SimpleUserDocInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sort = 0;
        message.docName = "";
        message.docId = "";
        message.pdfId = "";
        message.paperId = "";
        message.noteId = "";
        message.modifyDate = 0n;
        if (value !== undefined)
            reflectionMergePartial<SimpleUserDocInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleUserDocInfo): SimpleUserDocInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 sort */ 1:
                    message.sort = reader.uint32();
                    break;
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                case /* string docId */ 3:
                    message.docId = reader.string();
                    break;
                case /* string pdfId */ 4:
                    message.pdfId = reader.string();
                    break;
                case /* string paperId */ 5:
                    message.paperId = reader.string();
                    break;
                case /* string noteId */ 6:
                    message.noteId = reader.string();
                    break;
                case /* uint64 modifyDate */ 7:
                    message.modifyDate = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleUserDocInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 sort = 1; */
        if (message.sort !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sort);
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        /* string docId = 3; */
        if (message.docId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.docId);
        /* string pdfId = 4; */
        if (message.pdfId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pdfId);
        /* string paperId = 5; */
        if (message.paperId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paperId);
        /* string noteId = 6; */
        if (message.noteId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.noteId);
        /* uint64 modifyDate = 7; */
        if (message.modifyDate !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.modifyDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.SimpleUserDocInfo
 */
export const SimpleUserDocInfo = new SimpleUserDocInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class getUserAllClassifyListResp$Type extends MessageType<getUserAllClassifyListResp> {
    constructor() {
        super("doc.getUserAllClassifyListResp", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocClassify }
        ]);
    }
    create(value?: PartialMessage<getUserAllClassifyListResp>): getUserAllClassifyListResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<getUserAllClassifyListResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: getUserAllClassifyListResp): getUserAllClassifyListResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated doc.UserDocClassify results */ 1:
                    message.results.push(UserDocClassify.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: getUserAllClassifyListResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated doc.UserDocClassify results = 1; */
        for (let i = 0; i < message.results.length; i++)
            UserDocClassify.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.getUserAllClassifyListResp
 */
export const getUserAllClassifyListResp = new getUserAllClassifyListResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocClassify$Type extends MessageType<UserDocClassify> {
    constructor() {
        super("doc.UserDocClassify", [
            { no: 1, name: "doc_id", kind: "scalar", localName: "doc_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classify_id", kind: "scalar", localName: "classify_id", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "classify_name", kind: "scalar", localName: "classify_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocClassify>): UserDocClassify {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.doc_id = "";
        message.classify_id = "";
        message.classify_name = "";
        if (value !== undefined)
            reflectionMergePartial<UserDocClassify>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocClassify): UserDocClassify {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string doc_id */ 1:
                    message.doc_id = reader.string();
                    break;
                case /* string classify_id */ 2:
                    message.classify_id = reader.string();
                    break;
                case /* string classify_name */ 3:
                    message.classify_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocClassify, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string doc_id = 1; */
        if (message.doc_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.doc_id);
        /* string classify_id = 2; */
        if (message.classify_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classify_id);
        /* string classify_name = 3; */
        if (message.classify_name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classify_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocClassify
 */
export const UserDocClassify = new UserDocClassify$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserDocRequest$Type extends MessageType<GetUserDocRequest> {
    constructor() {
        super("doc.GetUserDocRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserDocRequest>): GetUserDocRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.noteId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserDocRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserDocRequest): GetUserDocRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string noteId */ 2:
                    message.noteId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserDocRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string noteId = 2; */
        if (message.noteId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.noteId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetUserDocRequest
 */
export const GetUserDocRequest = new GetUserDocRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HandleFileFastUploadReq$Type extends MessageType<HandleFileFastUploadReq> {
    constructor() {
        super("doc.HandleFileFastUploadReq", [
            { no: 1, name: "needUpload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "uploadInfo", kind: "message", T: () => UploadS3Info },
            { no: 3, name: "ossInfo", kind: "message", T: () => OSSS3Info }
        ]);
    }
    create(value?: PartialMessage<HandleFileFastUploadReq>): HandleFileFastUploadReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needUpload = false;
        if (value !== undefined)
            reflectionMergePartial<HandleFileFastUploadReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandleFileFastUploadReq): HandleFileFastUploadReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool needUpload */ 1:
                    message.needUpload = reader.bool();
                    break;
                case /* oss.UploadS3Info uploadInfo */ 2:
                    message.uploadInfo = UploadS3Info.internalBinaryRead(reader, reader.uint32(), options, message.uploadInfo);
                    break;
                case /* oss.OSSS3Info ossInfo */ 3:
                    message.ossInfo = OSSS3Info.internalBinaryRead(reader, reader.uint32(), options, message.ossInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandleFileFastUploadReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool needUpload = 1; */
        if (message.needUpload !== false)
            writer.tag(1, WireType.Varint).bool(message.needUpload);
        /* oss.UploadS3Info uploadInfo = 2; */
        if (message.uploadInfo)
            UploadS3Info.internalBinaryWrite(message.uploadInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* oss.OSSS3Info ossInfo = 3; */
        if (message.ossInfo)
            OSSS3Info.internalBinaryWrite(message.ossInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.HandleFileFastUploadReq
 */
export const HandleFileFastUploadReq = new HandleFileFastUploadReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HandleFileFastUploadResp$Type extends MessageType<HandleFileFastUploadResp> {
    constructor() {
        super("doc.HandleFileFastUploadResp", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "docInfo", kind: "message", T: () => MyCollectedDocInfo },
            { no: 5, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HandleFileFastUploadResp>): HandleFileFastUploadResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.msg = "";
        message.fileSHA256 = "";
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<HandleFileFastUploadResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandleFileFastUploadResp): HandleFileFastUploadResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* string msg */ 2:
                    message.msg = reader.string();
                    break;
                case /* string fileSHA256 */ 3:
                    message.fileSHA256 = reader.string();
                    break;
                case /* doc.MyCollectedDocInfo docInfo */ 4:
                    message.docInfo = MyCollectedDocInfo.internalBinaryRead(reader, reader.uint32(), options, message.docInfo);
                    break;
                case /* string pdfId */ 5:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandleFileFastUploadResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* string msg = 2; */
        if (message.msg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.msg);
        /* string fileSHA256 = 3; */
        if (message.fileSHA256 !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileSHA256);
        /* doc.MyCollectedDocInfo docInfo = 4; */
        if (message.docInfo)
            MyCollectedDocInfo.internalBinaryWrite(message.docInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string pdfId = 5; */
        if (message.pdfId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.HandleFileFastUploadResp
 */
export const HandleFileFastUploadResp = new HandleFileFastUploadResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateVenueRequest$Type extends MessageType<UpdateVenueRequest> {
    constructor() {
        super("doc.UpdateVenueRequest", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "venue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateVenueRequest>): UpdateVenueRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateVenueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateVenueRequest): UpdateVenueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* optional string venue */ 2:
                    message.venue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateVenueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* optional string venue = 2; */
        if (message.venue !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.venue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateVenueRequest
 */
export const UpdateVenueRequest = new UpdateVenueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateVenueResponse$Type extends MessageType<UpdateVenueResponse> {
    constructor() {
        super("doc.UpdateVenueResponse", [
            { no: 1, name: "newVenue", kind: "message", T: () => DisplayVenue }
        ]);
    }
    create(value?: PartialMessage<UpdateVenueResponse>): UpdateVenueResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateVenueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateVenueResponse): UpdateVenueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* doc.DisplayVenue newVenue */ 1:
                    message.newVenue = DisplayVenue.internalBinaryRead(reader, reader.uint32(), options, message.newVenue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateVenueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* doc.DisplayVenue newVenue = 1; */
        if (message.newVenue)
            DisplayVenue.internalBinaryWrite(message.newVenue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateVenueResponse
 */
export const UpdateVenueResponse = new UpdateVenueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePublishDateRequest$Type extends MessageType<UpdatePublishDateRequest> {
    constructor() {
        super("doc.UpdatePublishDateRequest", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "publishDate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePublishDateRequest>): UpdatePublishDateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        if (value !== undefined)
            reflectionMergePartial<UpdatePublishDateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePublishDateRequest): UpdatePublishDateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* optional string publishDate */ 2:
                    message.publishDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePublishDateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* optional string publishDate = 2; */
        if (message.publishDate !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.publishDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdatePublishDateRequest
 */
export const UpdatePublishDateRequest = new UpdatePublishDateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePublishDateResponse$Type extends MessageType<UpdatePublishDateResponse> {
    constructor() {
        super("doc.UpdatePublishDateResponse", [
            { no: 1, name: "newPublishDate", kind: "message", T: () => DisplayPublishDate }
        ]);
    }
    create(value?: PartialMessage<UpdatePublishDateResponse>): UpdatePublishDateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdatePublishDateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePublishDateResponse): UpdatePublishDateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* doc.DisplayPublishDate newPublishDate */ 1:
                    message.newPublishDate = DisplayPublishDate.internalBinaryRead(reader, reader.uint32(), options, message.newPublishDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePublishDateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* doc.DisplayPublishDate newPublishDate = 1; */
        if (message.newPublishDate)
            DisplayPublishDate.internalBinaryWrite(message.newPublishDate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdatePublishDateResponse
 */
export const UpdatePublishDateResponse = new UpdatePublishDateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAuthorsRequest$Type extends MessageType<UpdateAuthorsRequest> {
    constructor() {
        super("doc.UpdateAuthorsRequest", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BaseAuthorInfo }
        ]);
    }
    create(value?: PartialMessage<UpdateAuthorsRequest>): UpdateAuthorsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.authors = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateAuthorsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAuthorsRequest): UpdateAuthorsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* repeated doc.BaseAuthorInfo authors */ 2:
                    message.authors.push(BaseAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAuthorsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* repeated doc.BaseAuthorInfo authors = 2; */
        for (let i = 0; i < message.authors.length; i++)
            BaseAuthorInfo.internalBinaryWrite(message.authors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateAuthorsRequest
 */
export const UpdateAuthorsRequest = new UpdateAuthorsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAuthorsResponse$Type extends MessageType<UpdateAuthorsResponse> {
    constructor() {
        super("doc.UpdateAuthorsResponse", [
            { no: 1, name: "newAuthor", kind: "message", T: () => DisplaySimpleAuthors }
        ]);
    }
    create(value?: PartialMessage<UpdateAuthorsResponse>): UpdateAuthorsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateAuthorsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAuthorsResponse): UpdateAuthorsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* doc.DisplaySimpleAuthors newAuthor */ 1:
                    message.newAuthor = DisplaySimpleAuthors.internalBinaryRead(reader, reader.uint32(), options, message.newAuthor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAuthorsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* doc.DisplaySimpleAuthors newAuthor = 1; */
        if (message.newAuthor)
            DisplaySimpleAuthors.internalBinaryWrite(message.newAuthor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UpdateAuthorsResponse
 */
export const UpdateAuthorsResponse = new UpdateAuthorsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthorsRequest$Type extends MessageType<GetAuthorsRequest> {
    constructor() {
        super("doc.GetAuthorsRequest", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAuthorsRequest>): GetAuthorsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        if (value !== undefined)
            reflectionMergePartial<GetAuthorsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthorsRequest): GetAuthorsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthorsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetAuthorsRequest
 */
export const GetAuthorsRequest = new GetAuthorsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthorsResponse$Type extends MessageType<GetAuthorsResponse> {
    constructor() {
        super("doc.GetAuthorsResponse", [
            { no: 1, name: "displayAuthor", kind: "message", T: () => DisplaySimpleAuthors }
        ]);
    }
    create(value?: PartialMessage<GetAuthorsResponse>): GetAuthorsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAuthorsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthorsResponse): GetAuthorsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* doc.DisplaySimpleAuthors displayAuthor */ 1:
                    message.displayAuthor = DisplaySimpleAuthors.internalBinaryRead(reader, reader.uint32(), options, message.displayAuthor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthorsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* doc.DisplaySimpleAuthors displayAuthor = 1; */
        if (message.displayAuthor)
            DisplaySimpleAuthors.internalBinaryWrite(message.displayAuthor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetAuthorsResponse
 */
export const GetAuthorsResponse = new GetAuthorsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplaySimpleAuthors$Type extends MessageType<DisplaySimpleAuthors> {
    constructor() {
        super("doc.DisplaySimpleAuthors", [
            { no: 1, name: "authors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BaseAuthorInfo },
            { no: 2, name: "rollbackEnable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "originAuthors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BaseAuthorInfo }
        ]);
    }
    create(value?: PartialMessage<DisplaySimpleAuthors>): DisplaySimpleAuthors {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authors = [];
        message.rollbackEnable = false;
        message.originAuthors = [];
        if (value !== undefined)
            reflectionMergePartial<DisplaySimpleAuthors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplaySimpleAuthors): DisplaySimpleAuthors {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated doc.BaseAuthorInfo authors */ 1:
                    message.authors.push(BaseAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool rollbackEnable */ 2:
                    message.rollbackEnable = reader.bool();
                    break;
                case /* repeated doc.BaseAuthorInfo originAuthors */ 3:
                    message.originAuthors.push(BaseAuthorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplaySimpleAuthors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated doc.BaseAuthorInfo authors = 1; */
        for (let i = 0; i < message.authors.length; i++)
            BaseAuthorInfo.internalBinaryWrite(message.authors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool rollbackEnable = 2; */
        if (message.rollbackEnable !== false)
            writer.tag(2, WireType.Varint).bool(message.rollbackEnable);
        /* repeated doc.BaseAuthorInfo originAuthors = 3; */
        for (let i = 0; i < message.originAuthors.length; i++)
            BaseAuthorInfo.internalBinaryWrite(message.originAuthors[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.DisplaySimpleAuthors
 */
export const DisplaySimpleAuthors = new DisplaySimpleAuthors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseAuthorInfo$Type extends MessageType<BaseAuthorInfo> {
    constructor() {
        super("doc.BaseAuthorInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "isAuthentication", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BaseAuthorInfo>): BaseAuthorInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.isAuthentication = false;
        if (value !== undefined)
            reflectionMergePartial<BaseAuthorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BaseAuthorInfo): BaseAuthorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool isAuthentication */ 3:
                    message.isAuthentication = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BaseAuthorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool isAuthentication = 3; */
        if (message.isAuthentication !== false)
            writer.tag(3, WireType.Varint).bool(message.isAuthentication);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.BaseAuthorInfo
 */
export const BaseAuthorInfo = new BaseAuthorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLatestReadDocListReq$Type extends MessageType<GetLatestReadDocListReq> {
    constructor() {
        super("doc.GetLatestReadDocListReq", []);
    }
    create(value?: PartialMessage<GetLatestReadDocListReq>): GetLatestReadDocListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetLatestReadDocListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLatestReadDocListReq): GetLatestReadDocListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLatestReadDocListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetLatestReadDocListReq
 */
export const GetLatestReadDocListReq = new GetLatestReadDocListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLatestReadDocListResp$Type extends MessageType<GetLatestReadDocListResp> {
    constructor() {
        super("doc.GetLatestReadDocListResp", [
            { no: 1, name: "docInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LatestReadDocInfo },
            { no: 2, name: "currentTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetLatestReadDocListResp>): GetLatestReadDocListResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docInfos = [];
        message.currentTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetLatestReadDocListResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLatestReadDocListResp): GetLatestReadDocListResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated doc.LatestReadDocInfo docInfos */ 1:
                    message.docInfos.push(LatestReadDocInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 currentTime */ 2:
                    message.currentTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLatestReadDocListResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated doc.LatestReadDocInfo docInfos = 1; */
        for (let i = 0; i < message.docInfos.length; i++)
            LatestReadDocInfo.internalBinaryWrite(message.docInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 currentTime = 2; */
        if (message.currentTime !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.currentTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetLatestReadDocListResp
 */
export const GetLatestReadDocListResp = new GetLatestReadDocListResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LatestReadDocInfo$Type extends MessageType<LatestReadDocInfo> {
    constructor() {
        super("doc.LatestReadDocInfo", [
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "venue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "publishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "remark", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "lastReadTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LatestReadDocInfo>): LatestReadDocInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docName = "";
        message.docId = "";
        message.pdfId = "";
        message.paperId = "";
        message.venue = "";
        message.publishDate = "";
        message.remark = "";
        message.lastReadTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<LatestReadDocInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LatestReadDocInfo): LatestReadDocInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                case /* string docId */ 3:
                    message.docId = reader.string();
                    break;
                case /* string pdfId */ 4:
                    message.pdfId = reader.string();
                    break;
                case /* string paperId */ 5:
                    message.paperId = reader.string();
                    break;
                case /* string venue */ 6:
                    message.venue = reader.string();
                    break;
                case /* string publishDate */ 7:
                    message.publishDate = reader.string();
                    break;
                case /* string remark */ 8:
                    message.remark = reader.string();
                    break;
                case /* uint64 lastReadTime */ 9:
                    message.lastReadTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LatestReadDocInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        /* string docId = 3; */
        if (message.docId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.docId);
        /* string pdfId = 4; */
        if (message.pdfId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pdfId);
        /* string paperId = 5; */
        if (message.paperId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paperId);
        /* string venue = 6; */
        if (message.venue !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.venue);
        /* string publishDate = 7; */
        if (message.publishDate !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.publishDate);
        /* string remark = 8; */
        if (message.remark !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.remark);
        /* uint64 lastReadTime = 9; */
        if (message.lastReadTime !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.lastReadTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.LatestReadDocInfo
 */
export const LatestReadDocInfo = new LatestReadDocInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadPdfByUrlLinkRequest$Type extends MessageType<UploadPdfByUrlLinkRequest> {
    constructor() {
        super("doc.UploadPdfByUrlLinkRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uploadToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UploadPdfByUrlLinkRequest>): UploadPdfByUrlLinkRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.uploadToken = "";
        if (value !== undefined)
            reflectionMergePartial<UploadPdfByUrlLinkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadPdfByUrlLinkRequest): UploadPdfByUrlLinkRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string uploadToken */ 2:
                    message.uploadToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadPdfByUrlLinkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string uploadToken = 2; */
        if (message.uploadToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uploadToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UploadPdfByUrlLinkRequest
 */
export const UploadPdfByUrlLinkRequest = new UploadPdfByUrlLinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadPdfByUrlLinkResponse$Type extends MessageType<UploadPdfByUrlLinkResponse> {
    constructor() {
        super("doc.UploadPdfByUrlLinkResponse", []);
    }
    create(value?: PartialMessage<UploadPdfByUrlLinkResponse>): UploadPdfByUrlLinkResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadPdfByUrlLinkResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadPdfByUrlLinkResponse): UploadPdfByUrlLinkResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadPdfByUrlLinkResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UploadPdfByUrlLinkResponse
 */
export const UploadPdfByUrlLinkResponse = new UploadPdfByUrlLinkResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetParseTokenRequest$Type extends MessageType<GetParseTokenRequest> {
    constructor() {
        super("doc.GetParseTokenRequest", []);
    }
    create(value?: PartialMessage<GetParseTokenRequest>): GetParseTokenRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetParseTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetParseTokenRequest): GetParseTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetParseTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetParseTokenRequest
 */
export const GetParseTokenRequest = new GetParseTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetParseTokenResponse$Type extends MessageType<GetParseTokenResponse> {
    constructor() {
        super("doc.GetParseTokenResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetParseTokenResponse>): GetParseTokenResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<GetParseTokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetParseTokenResponse): GetParseTokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetParseTokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.GetParseTokenResponse
 */
export const GetParseTokenResponse = new GetParseTokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocStatusByIdsRequest$Type extends MessageType<UserDocStatusByIdsRequest> {
    constructor() {
        super("doc.UserDocStatusByIdsRequest", [
            { no: 1, name: "docIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserDocStatusByIdsRequest>): UserDocStatusByIdsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docIds = [];
        if (value !== undefined)
            reflectionMergePartial<UserDocStatusByIdsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocStatusByIdsRequest): UserDocStatusByIdsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string docIds */ 1:
                    message.docIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocStatusByIdsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string docIds = 1; */
        for (let i = 0; i < message.docIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.docIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocStatusByIdsRequest
 */
export const UserDocStatusByIdsRequest = new UserDocStatusByIdsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocStatusByIdsResponse$Type extends MessageType<UserDocStatusByIdsResponse> {
    constructor() {
        super("doc.UserDocStatusByIdsResponse", [
            { no: 1, name: "items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDocStatusByIdsItem }
        ]);
    }
    create(value?: PartialMessage<UserDocStatusByIdsResponse>): UserDocStatusByIdsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<UserDocStatusByIdsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocStatusByIdsResponse): UserDocStatusByIdsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated doc.UserDocStatusByIdsItem items */ 1:
                    message.items.push(UserDocStatusByIdsItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocStatusByIdsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated doc.UserDocStatusByIdsItem items = 1; */
        for (let i = 0; i < message.items.length; i++)
            UserDocStatusByIdsItem.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocStatusByIdsResponse
 */
export const UserDocStatusByIdsResponse = new UserDocStatusByIdsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDocStatusByIdsItem$Type extends MessageType<UserDocStatusByIdsItem> {
    constructor() {
        super("doc.UserDocStatusByIdsItem", [
            { no: 1, name: "docId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "enum", T: () => ["doc.UserDocParsedStatusEnum", UserDocParsedStatusEnum] },
            { no: 3, name: "embeddingStatus", kind: "enum", T: () => ["doc.UserDocParsedStatusEnum", UserDocParsedStatusEnum] }
        ]);
    }
    create(value?: PartialMessage<UserDocStatusByIdsItem>): UserDocStatusByIdsItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.docId = "";
        message.status = 0;
        message.embeddingStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<UserDocStatusByIdsItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserDocStatusByIdsItem): UserDocStatusByIdsItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string docId */ 1:
                    message.docId = reader.string();
                    break;
                case /* doc.UserDocParsedStatusEnum status */ 2:
                    message.status = reader.int32();
                    break;
                case /* doc.UserDocParsedStatusEnum embeddingStatus */ 3:
                    message.embeddingStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserDocStatusByIdsItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string docId = 1; */
        if (message.docId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.docId);
        /* doc.UserDocParsedStatusEnum status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* doc.UserDocParsedStatusEnum embeddingStatus = 3; */
        if (message.embeddingStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.embeddingStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message doc.UserDocStatusByIdsItem
 */
export const UserDocStatusByIdsItem = new UserDocStatusByIdsItem$Type();
