// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/validate/Validate.proto" (package "validate", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * FieldRules encapsulates the rules for each type of field.
 *
 * @generated from protobuf message validate.FieldRules
 */
export interface FieldRules {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "float";
        /**
         * Scalar Field Types
         *
         * @generated from protobuf field: validate.FloatRules float = 1
         */
        float: FloatRules;
    } | {
        oneofKind: "double";
        /**
         * @generated from protobuf field: validate.DoubleRules double = 2
         */
        double: DoubleRules;
    } | {
        oneofKind: "int32";
        /**
         * @generated from protobuf field: validate.Int32Rules int32 = 3
         */
        int32: Int32Rules;
    } | {
        oneofKind: "int64";
        /**
         * @generated from protobuf field: validate.Int64Rules int64 = 4
         */
        int64: Int64Rules;
    } | {
        oneofKind: "uint32";
        /**
         * @generated from protobuf field: validate.UInt32Rules uint32 = 5
         */
        uint32: UInt32Rules;
    } | {
        oneofKind: "uint64";
        /**
         * @generated from protobuf field: validate.UInt64Rules uint64 = 6
         */
        uint64: UInt64Rules;
    } | {
        oneofKind: "sint32";
        /**
         * @generated from protobuf field: validate.SInt32Rules sint32 = 7
         */
        sint32: SInt32Rules;
    } | {
        oneofKind: "sint64";
        /**
         * @generated from protobuf field: validate.SInt64Rules sint64 = 8
         */
        sint64: SInt64Rules;
    } | {
        oneofKind: "fixed32";
        /**
         * @generated from protobuf field: validate.Fixed32Rules fixed32 = 9
         */
        fixed32: Fixed32Rules;
    } | {
        oneofKind: "fixed64";
        /**
         * @generated from protobuf field: validate.Fixed64Rules fixed64 = 10
         */
        fixed64: Fixed64Rules;
    } | {
        oneofKind: "sfixed32";
        /**
         * @generated from protobuf field: validate.SFixed32Rules sfixed32 = 11
         */
        sfixed32: SFixed32Rules;
    } | {
        oneofKind: "sfixed64";
        /**
         * @generated from protobuf field: validate.SFixed64Rules sfixed64 = 12
         */
        sfixed64: SFixed64Rules;
    } | {
        oneofKind: "bool";
        /**
         * @generated from protobuf field: validate.BoolRules bool = 13
         */
        bool: BoolRules;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: validate.StringRules string = 14
         */
        string: StringRules;
    } | {
        oneofKind: "bytes";
        /**
         * @generated from protobuf field: validate.BytesRules bytes = 15
         */
        bytes: BytesRules;
    } | {
        oneofKind: "enum";
        /**
         * Complex Field Types
         *
         * @generated from protobuf field: validate.EnumRules enum = 16
         */
        enum: EnumRules;
    } | {
        oneofKind: "message";
        /**
         * @generated from protobuf field: validate.MessageRules message = 17
         */
        message: MessageRules;
    } | {
        oneofKind: "repeated";
        /**
         * @generated from protobuf field: validate.RepeatedRules repeated = 18
         */
        repeated: RepeatedRules;
    } | {
        oneofKind: "map";
        /**
         * @generated from protobuf field: validate.MapRules map = 19
         */
        map: MapRules;
    } | {
        oneofKind: undefined;
    };
}
/**
 * FloatRules describes the constraints applied to `float` values
 *
 * @generated from protobuf message validate.FloatRules
 */
export interface FloatRules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional float const = 1
     */
    const?: number;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional float lt = 2
     */
    lt?: number;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional float lte = 3
     */
    lte?: number;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional float gt = 4
     */
    gt?: number;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional float gte = 5
     */
    gte?: number;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated float in = 6
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated float not_in = 7
     */
    not_in: number[];
}
/**
 * DoubleRules describes the constraints applied to `double` values
 *
 * @generated from protobuf message validate.DoubleRules
 */
export interface DoubleRules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional double const = 1
     */
    const?: number;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional double lt = 2
     */
    lt?: number;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional double lte = 3
     */
    lte?: number;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional double gt = 4
     */
    gt?: number;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional double gte = 5
     */
    gte?: number;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated double in = 6
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated double not_in = 7
     */
    not_in: number[];
}
/**
 * Int32Rules describes the constraints applied to `int32` values
 *
 * @generated from protobuf message validate.Int32Rules
 */
export interface Int32Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional int32 const = 1
     */
    const?: number;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional int32 lt = 2
     */
    lt?: number;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional int32 lte = 3
     */
    lte?: number;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional int32 gt = 4
     */
    gt?: number;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional int32 gte = 5
     */
    gte?: number;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 in = 6
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 not_in = 7
     */
    not_in: number[];
}
/**
 * Int64Rules describes the constraints applied to `int64` values
 *
 * @generated from protobuf message validate.Int64Rules
 */
export interface Int64Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional int64 const = 1
     */
    const?: bigint;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional int64 lt = 2
     */
    lt?: bigint;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional int64 lte = 3
     */
    lte?: bigint;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional int64 gt = 4
     */
    gt?: bigint;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional int64 gte = 5
     */
    gte?: bigint;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int64 in = 6
     */
    in: bigint[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int64 not_in = 7
     */
    not_in: bigint[];
}
/**
 * UInt32Rules describes the constraints applied to `uint32` values
 *
 * @generated from protobuf message validate.UInt32Rules
 */
export interface UInt32Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional uint32 const = 1
     */
    const?: number;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional uint32 lt = 2
     */
    lt?: number;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional uint32 lte = 3
     */
    lte?: number;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional uint32 gt = 4
     */
    gt?: number;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional uint32 gte = 5
     */
    gte?: number;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint32 in = 6
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint32 not_in = 7
     */
    not_in: number[];
}
/**
 * UInt64Rules describes the constraints applied to `uint64` values
 *
 * @generated from protobuf message validate.UInt64Rules
 */
export interface UInt64Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional uint64 const = 1
     */
    const?: bigint;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional uint64 lt = 2
     */
    lt?: bigint;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional uint64 lte = 3
     */
    lte?: bigint;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional uint64 gt = 4
     */
    gt?: bigint;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional uint64 gte = 5
     */
    gte?: bigint;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint64 in = 6
     */
    in: bigint[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint64 not_in = 7
     */
    not_in: bigint[];
}
/**
 * SInt32Rules describes the constraints applied to `sint32` values
 *
 * @generated from protobuf message validate.SInt32Rules
 */
export interface SInt32Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional int32 const = 1
     */
    const?: number;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional int32 lt = 2
     */
    lt?: number;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional int32 lte = 3
     */
    lte?: number;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional int32 gt = 4
     */
    gt?: number;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional int32 gte = 5
     */
    gte?: number;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 in = 6
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 not_in = 7
     */
    not_in: number[];
}
/**
 * SInt64Rules describes the constraints applied to `sint64` values
 *
 * @generated from protobuf message validate.SInt64Rules
 */
export interface SInt64Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional int64 const = 1
     */
    const?: bigint;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional int64 lt = 2
     */
    lt?: bigint;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional int64 lte = 3
     */
    lte?: bigint;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional int64 gt = 4
     */
    gt?: bigint;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional int64 gte = 5
     */
    gte?: bigint;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int64 in = 6
     */
    in: bigint[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int64 not_in = 7
     */
    not_in: bigint[];
}
/**
 * Fixed32Rules describes the constraints applied to `fixed32` values
 *
 * @generated from protobuf message validate.Fixed32Rules
 */
export interface Fixed32Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional uint32 const = 1
     */
    const?: number;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional uint32 lt = 2
     */
    lt?: number;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional uint32 lte = 3
     */
    lte?: number;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional uint32 gt = 4
     */
    gt?: number;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional uint32 gte = 5
     */
    gte?: number;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint32 in = 6
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint32 not_in = 7
     */
    not_in: number[];
}
/**
 * Fixed64Rules describes the constraints applied to `fixed64` values
 *
 * @generated from protobuf message validate.Fixed64Rules
 */
export interface Fixed64Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional uint64 const = 1
     */
    const?: bigint;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional uint64 lt = 2
     */
    lt?: bigint;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional uint64 lte = 3
     */
    lte?: bigint;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional uint64 gt = 4
     */
    gt?: bigint;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional uint64 gte = 5
     */
    gte?: bigint;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint64 in = 6
     */
    in: bigint[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated uint64 not_in = 7
     */
    not_in: bigint[];
}
/**
 * SFixed32Rules describes the constraints applied to `sfixed32` values
 *
 * @generated from protobuf message validate.SFixed32Rules
 */
export interface SFixed32Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional int32 const = 1
     */
    const?: number;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional int32 lt = 2
     */
    lt?: number;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional int32 lte = 3
     */
    lte?: number;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional int32 gt = 4
     */
    gt?: number;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional int32 gte = 5
     */
    gte?: number;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 in = 6
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 not_in = 7
     */
    not_in: number[];
}
/**
 * SFixed64Rules describes the constraints applied to `sfixed64` values
 *
 * @generated from protobuf message validate.SFixed64Rules
 */
export interface SFixed64Rules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional int64 const = 1
     */
    const?: bigint;
    /**
     * Lt specifies that this field must be less than the specified value
     *
     * @generated from protobuf field: optional int64 lt = 2
     */
    lt?: bigint;
    /**
     * Lte specifies that this field must be less than or equal to the specified value
     *
     * @generated from protobuf field: optional int64 lte = 3
     */
    lte?: bigint;
    /**
     * Gt specifies that this field must be greater than the specified value
     *
     * @generated from protobuf field: optional int64 gt = 4
     */
    gt?: bigint;
    /**
     * Gte specifies that this field must be greater than or equal to the specified value
     *
     * @generated from protobuf field: optional int64 gte = 5
     */
    gte?: bigint;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int64 in = 6
     */
    in: bigint[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int64 not_in = 7
     */
    not_in: bigint[];
}
/**
 * BoolRules describes the constraints applied to `bool` values
 *
 * @generated from protobuf message validate.BoolRules
 */
export interface BoolRules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional bool const = 1
     */
    const?: boolean;
}
/**
 * StringRules describes the constraints applied to `string` values
 *
 * @generated from protobuf message validate.StringRules
 */
export interface StringRules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional string const = 1
     */
    const?: string;
    /**
     * Len specifies that this field must be the specified number of characters
     *
     * @generated from protobuf field: optional uint64 len = 19
     */
    len?: bigint;
    /**
     * MinLen specifies that this field must be at least the specified number of characters
     *
     * @generated from protobuf field: optional uint64 min_len = 2
     */
    min_len?: bigint;
    /**
     * MaxLen specifies that this field must be at most the specified number of characters
     *
     * @generated from protobuf field: optional uint64 max_len = 3
     */
    max_len?: bigint;
    /**
     * LenBytes specifies that this field must be the specified number of bytes
     *
     * @generated from protobuf field: optional uint64 len_bytes = 20
     */
    len_bytes?: bigint;
    /**
     * MinBytes specifies that this field must be at least the specified number of bytes
     *
     * @generated from protobuf field: optional uint64 min_bytes = 4
     */
    min_bytes?: bigint;
    /**
     * MaxBytes specifies that this field must be at most the specified number of bytes
     *
     * @generated from protobuf field: optional uint64 max_bytes = 5
     */
    max_bytes?: bigint;
    /**
     * Pattern specifies that this field must match the specified regular expression (RE2 syntax)
     *
     * @generated from protobuf field: optional string pattern = 6
     */
    pattern?: string;
    /**
     * Prefix specifies that this field must have the specified substring at the beginning of the string
     *
     * @generated from protobuf field: optional string prefix = 7
     */
    prefix?: string;
    /**
     * Suffix specifies that this field must have the specified substring at the end of the string
     *
     * @generated from protobuf field: optional string suffix = 8
     */
    suffix?: string;
    /**
     * Contains specifies that this field must have the specified substring anywhere in the string
     *
     * @generated from protobuf field: optional string contains = 9
     */
    contains?: string;
    /**
     * NotContains specifies that this field cannot have the specified substring anywhere in the string
     *
     * @generated from protobuf field: optional string not_contains = 23
     */
    not_contains?: string;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated string in = 10
     */
    in: string[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated string not_in = 11
     */
    not_in: string[];
    /**
     * WellKnown rules provide advanced constraints against common string patterns
     *
     * @generated from protobuf oneof: well_known
     */
    well_known: {
        oneofKind: "email";
        /**
         * Email specifies that the field must be a valid email address
         *
         * @generated from protobuf field: bool email = 12
         */
        email: boolean;
    } | {
        oneofKind: "hostname";
        /**
         * Hostname specifies that the field must be a valid hostname
         *
         * @generated from protobuf field: bool hostname = 13
         */
        hostname: boolean;
    } | {
        oneofKind: "ip";
        /**
         * Ip specifies that the field must be a valid IP (v4 or v6) address
         *
         * @generated from protobuf field: bool ip = 14
         */
        ip: boolean;
    } | {
        oneofKind: "ipv4";
        /**
         * Ipv4 specifies that the field must be a valid IPv4 address
         *
         * @generated from protobuf field: bool ipv4 = 15
         */
        ipv4: boolean;
    } | {
        oneofKind: "ipv6";
        /**
         * Ipv6 specifies that the field must be a valid IPv6 address
         *
         * @generated from protobuf field: bool ipv6 = 16
         */
        ipv6: boolean;
    } | {
        oneofKind: "uri";
        /**
         * Uri specifies that the field must be a valid URI
         *
         * @generated from protobuf field: bool uri = 17
         */
        uri: boolean;
    } | {
        oneofKind: "uri_ref";
        /**
         * UriRef specifies that the field must be a valid URI reference
         *
         * @generated from protobuf field: bool uri_ref = 18
         */
        uri_ref: boolean;
    } | {
        oneofKind: "address";
        /**
         * Address specifies that the field must be either a valid hostname or IP address
         *
         * @generated from protobuf field: bool address = 21
         */
        address: boolean;
    } | {
        oneofKind: "uuid";
        /**
         * Uuid specifies that the field must be a valid UUID
         *
         * @generated from protobuf field: bool uuid = 22
         */
        uuid: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * BytesRules describes the constraints applied to `bytes` values
 *
 * @generated from protobuf message validate.BytesRules
 */
export interface BytesRules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional bytes const = 1
     */
    const?: Uint8Array;
    /**
     * Len specifies that this field must be the specified number of bytes
     *
     * @generated from protobuf field: optional uint64 len = 13
     */
    len?: bigint;
    /**
     * MinLen specifies that this field must be at least the specified number of bytes
     *
     * @generated from protobuf field: optional uint64 min_len = 2
     */
    min_len?: bigint;
    /**
     * MaxLen specifies that this field must be at most the specified number of bytes
     *
     * @generated from protobuf field: optional uint64 max_len = 3
     */
    max_len?: bigint;
    /**
     * Pattern specifies that this field must match the specified regular expression (RE2 syntax)
     *
     * @generated from protobuf field: optional string pattern = 4
     */
    pattern?: string;
    /**
     * Prefix specifies that this field must have the specified bytes at the beginning
     *
     * @generated from protobuf field: optional bytes prefix = 5
     */
    prefix?: Uint8Array;
    /**
     * Suffix specifies that this field must have the specified bytes at the end
     *
     * @generated from protobuf field: optional bytes suffix = 6
     */
    suffix?: Uint8Array;
    /**
     * Contains specifies that this field must have the specified bytes anywhere
     *
     * @generated from protobuf field: optional bytes contains = 7
     */
    contains?: Uint8Array;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated bytes in = 8
     */
    in: Uint8Array[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated bytes not_in = 9
     */
    not_in: Uint8Array[];
    /**
     * WellKnown rules provide advanced constraints against common byte patterns
     *
     * @generated from protobuf oneof: well_known
     */
    well_known: {
        oneofKind: "ip";
        /**
         * Ip specifies that the field must be a valid IP (v4 or v6) address in byte format
         *
         * @generated from protobuf field: bool ip = 10
         */
        ip: boolean;
    } | {
        oneofKind: "ipv4";
        /**
         * Ipv4 specifies that the field must be a valid IPv4 address in byte format
         *
         * @generated from protobuf field: bool ipv4 = 11
         */
        ipv4: boolean;
    } | {
        oneofKind: "ipv6";
        /**
         * Ipv6 specifies that the field must be a valid IPv6 address in byte format
         *
         * @generated from protobuf field: bool ipv6 = 12
         */
        ipv6: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * EnumRules describes the constraints applied to enum values
 *
 * @generated from protobuf message validate.EnumRules
 */
export interface EnumRules {
    /**
     * Const specifies that this field must be exactly the specified value
     *
     * @generated from protobuf field: optional int32 const = 1
     */
    const?: number;
    /**
     * DefinedOnly specifies that this field must be only one of the defined values for this enum
     *
     * @generated from protobuf field: optional bool defined_only = 2
     */
    defined_only?: boolean;
    /**
     * In specifies that this field must be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 in = 3
     */
    in: number[];
    /**
     * NotIn specifies that this field cannot be equal to one of the specified values
     *
     * @generated from protobuf field: repeated int32 not_in = 4
     */
    not_in: number[];
}
/**
 * MessageRules describe the constraints applied to embedded message values
 *
 * @generated from protobuf message validate.MessageRules
 */
export interface MessageRules {
    /**
     * Skip specifies that the validation rules of this field should not be evaluated
     *
     * @generated from protobuf field: optional bool skip = 1
     */
    skip?: boolean;
    /**
     * Required specifies that this field must be set
     *
     * @generated from protobuf field: optional bool required = 2
     */
    required?: boolean;
}
/**
 * RepeatedRules describe the constraints applied to `repeated` values
 *
 * @generated from protobuf message validate.RepeatedRules
 */
export interface RepeatedRules {
    /**
     * MinItems specifies that this field must have the specified number of items at minimum
     *
     * @generated from protobuf field: optional uint64 min_items = 1
     */
    min_items?: bigint;
    /**
     * MaxItems specifies that this field must have the specified number of items at maximum
     *
     * @generated from protobuf field: optional uint64 max_items = 2
     */
    max_items?: bigint;
    /**
     * Unique specifies that all elements in this field must be unique
     *
     * @generated from protobuf field: optional bool unique = 3
     */
    unique?: boolean;
    /**
     * Items specifies the constraints to be applied to each item in the field
     *
     * @generated from protobuf field: optional validate.FieldRules items = 4
     */
    items?: FieldRules;
}
/**
 * MapRules describe the constraints applied to `map` values
 *
 * @generated from protobuf message validate.MapRules
 */
export interface MapRules {
    /**
     * MinPairs specifies that this field must have the specified number of KVs at minimum
     *
     * @generated from protobuf field: optional uint64 min_pairs = 1
     */
    min_pairs?: bigint;
    /**
     * MaxPairs specifies that this field must have the specified number of KVs at maximum
     *
     * @generated from protobuf field: optional uint64 max_pairs = 2
     */
    max_pairs?: bigint;
    /**
     * Keys specifies the constraints to be applied to each key in the field
     *
     * @generated from protobuf field: optional validate.FieldRules keys = 3
     */
    keys?: FieldRules;
    /**
     * Values specifies the constraints to be applied to each value in the field
     *
     * @generated from protobuf field: optional validate.FieldRules values = 4
     */
    values?: FieldRules;
}
// @generated message type with reflection information, may provide speed optimized methods
class FieldRules$Type extends MessageType<FieldRules> {
    constructor() {
        super("validate.FieldRules", [
            { no: 1, name: "float", kind: "message", oneof: "type", T: () => FloatRules },
            { no: 2, name: "double", kind: "message", oneof: "type", T: () => DoubleRules },
            { no: 3, name: "int32", kind: "message", oneof: "type", T: () => Int32Rules },
            { no: 4, name: "int64", kind: "message", oneof: "type", T: () => Int64Rules },
            { no: 5, name: "uint32", kind: "message", oneof: "type", T: () => UInt32Rules },
            { no: 6, name: "uint64", kind: "message", oneof: "type", T: () => UInt64Rules },
            { no: 7, name: "sint32", kind: "message", oneof: "type", T: () => SInt32Rules },
            { no: 8, name: "sint64", kind: "message", oneof: "type", T: () => SInt64Rules },
            { no: 9, name: "fixed32", kind: "message", oneof: "type", T: () => Fixed32Rules },
            { no: 10, name: "fixed64", kind: "message", oneof: "type", T: () => Fixed64Rules },
            { no: 11, name: "sfixed32", kind: "message", oneof: "type", T: () => SFixed32Rules },
            { no: 12, name: "sfixed64", kind: "message", oneof: "type", T: () => SFixed64Rules },
            { no: 13, name: "bool", kind: "message", oneof: "type", T: () => BoolRules },
            { no: 14, name: "string", kind: "message", oneof: "type", T: () => StringRules },
            { no: 15, name: "bytes", kind: "message", oneof: "type", T: () => BytesRules },
            { no: 16, name: "enum", kind: "message", oneof: "type", T: () => EnumRules },
            { no: 17, name: "message", kind: "message", oneof: "type", T: () => MessageRules },
            { no: 18, name: "repeated", kind: "message", oneof: "type", T: () => RepeatedRules },
            { no: 19, name: "map", kind: "message", oneof: "type", T: () => MapRules }
        ]);
    }
    create(value?: PartialMessage<FieldRules>): FieldRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<FieldRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldRules): FieldRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* validate.FloatRules float */ 1:
                    message.type = {
                        oneofKind: "float",
                        float: FloatRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).float)
                    };
                    break;
                case /* validate.DoubleRules double */ 2:
                    message.type = {
                        oneofKind: "double",
                        double: DoubleRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).double)
                    };
                    break;
                case /* validate.Int32Rules int32 */ 3:
                    message.type = {
                        oneofKind: "int32",
                        int32: Int32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).int32)
                    };
                    break;
                case /* validate.Int64Rules int64 */ 4:
                    message.type = {
                        oneofKind: "int64",
                        int64: Int64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).int64)
                    };
                    break;
                case /* validate.UInt32Rules uint32 */ 5:
                    message.type = {
                        oneofKind: "uint32",
                        uint32: UInt32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).uint32)
                    };
                    break;
                case /* validate.UInt64Rules uint64 */ 6:
                    message.type = {
                        oneofKind: "uint64",
                        uint64: UInt64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).uint64)
                    };
                    break;
                case /* validate.SInt32Rules sint32 */ 7:
                    message.type = {
                        oneofKind: "sint32",
                        sint32: SInt32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sint32)
                    };
                    break;
                case /* validate.SInt64Rules sint64 */ 8:
                    message.type = {
                        oneofKind: "sint64",
                        sint64: SInt64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sint64)
                    };
                    break;
                case /* validate.Fixed32Rules fixed32 */ 9:
                    message.type = {
                        oneofKind: "fixed32",
                        fixed32: Fixed32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).fixed32)
                    };
                    break;
                case /* validate.Fixed64Rules fixed64 */ 10:
                    message.type = {
                        oneofKind: "fixed64",
                        fixed64: Fixed64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).fixed64)
                    };
                    break;
                case /* validate.SFixed32Rules sfixed32 */ 11:
                    message.type = {
                        oneofKind: "sfixed32",
                        sfixed32: SFixed32Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sfixed32)
                    };
                    break;
                case /* validate.SFixed64Rules sfixed64 */ 12:
                    message.type = {
                        oneofKind: "sfixed64",
                        sfixed64: SFixed64Rules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).sfixed64)
                    };
                    break;
                case /* validate.BoolRules bool */ 13:
                    message.type = {
                        oneofKind: "bool",
                        bool: BoolRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).bool)
                    };
                    break;
                case /* validate.StringRules string */ 14:
                    message.type = {
                        oneofKind: "string",
                        string: StringRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).string)
                    };
                    break;
                case /* validate.BytesRules bytes */ 15:
                    message.type = {
                        oneofKind: "bytes",
                        bytes: BytesRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).bytes)
                    };
                    break;
                case /* validate.EnumRules enum */ 16:
                    message.type = {
                        oneofKind: "enum",
                        enum: EnumRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).enum)
                    };
                    break;
                case /* validate.MessageRules message */ 17:
                    message.type = {
                        oneofKind: "message",
                        message: MessageRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).message)
                    };
                    break;
                case /* validate.RepeatedRules repeated */ 18:
                    message.type = {
                        oneofKind: "repeated",
                        repeated: RepeatedRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).repeated)
                    };
                    break;
                case /* validate.MapRules map */ 19:
                    message.type = {
                        oneofKind: "map",
                        map: MapRules.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).map)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FieldRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* validate.FloatRules float = 1; */
        if (message.type.oneofKind === "float")
            FloatRules.internalBinaryWrite(message.type.float, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* validate.DoubleRules double = 2; */
        if (message.type.oneofKind === "double")
            DoubleRules.internalBinaryWrite(message.type.double, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* validate.Int32Rules int32 = 3; */
        if (message.type.oneofKind === "int32")
            Int32Rules.internalBinaryWrite(message.type.int32, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* validate.Int64Rules int64 = 4; */
        if (message.type.oneofKind === "int64")
            Int64Rules.internalBinaryWrite(message.type.int64, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* validate.UInt32Rules uint32 = 5; */
        if (message.type.oneofKind === "uint32")
            UInt32Rules.internalBinaryWrite(message.type.uint32, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* validate.UInt64Rules uint64 = 6; */
        if (message.type.oneofKind === "uint64")
            UInt64Rules.internalBinaryWrite(message.type.uint64, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* validate.SInt32Rules sint32 = 7; */
        if (message.type.oneofKind === "sint32")
            SInt32Rules.internalBinaryWrite(message.type.sint32, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* validate.SInt64Rules sint64 = 8; */
        if (message.type.oneofKind === "sint64")
            SInt64Rules.internalBinaryWrite(message.type.sint64, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* validate.Fixed32Rules fixed32 = 9; */
        if (message.type.oneofKind === "fixed32")
            Fixed32Rules.internalBinaryWrite(message.type.fixed32, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* validate.Fixed64Rules fixed64 = 10; */
        if (message.type.oneofKind === "fixed64")
            Fixed64Rules.internalBinaryWrite(message.type.fixed64, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* validate.SFixed32Rules sfixed32 = 11; */
        if (message.type.oneofKind === "sfixed32")
            SFixed32Rules.internalBinaryWrite(message.type.sfixed32, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* validate.SFixed64Rules sfixed64 = 12; */
        if (message.type.oneofKind === "sfixed64")
            SFixed64Rules.internalBinaryWrite(message.type.sfixed64, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* validate.BoolRules bool = 13; */
        if (message.type.oneofKind === "bool")
            BoolRules.internalBinaryWrite(message.type.bool, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* validate.StringRules string = 14; */
        if (message.type.oneofKind === "string")
            StringRules.internalBinaryWrite(message.type.string, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* validate.BytesRules bytes = 15; */
        if (message.type.oneofKind === "bytes")
            BytesRules.internalBinaryWrite(message.type.bytes, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* validate.EnumRules enum = 16; */
        if (message.type.oneofKind === "enum")
            EnumRules.internalBinaryWrite(message.type.enum, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* validate.MessageRules message = 17; */
        if (message.type.oneofKind === "message")
            MessageRules.internalBinaryWrite(message.type.message, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* validate.RepeatedRules repeated = 18; */
        if (message.type.oneofKind === "repeated")
            RepeatedRules.internalBinaryWrite(message.type.repeated, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* validate.MapRules map = 19; */
        if (message.type.oneofKind === "map")
            MapRules.internalBinaryWrite(message.type.map, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.FieldRules
 */
export const FieldRules = new FieldRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FloatRules$Type extends MessageType<FloatRules> {
    constructor() {
        super("validate.FloatRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<FloatRules>): FloatRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<FloatRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FloatRules): FloatRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float const */ 1:
                    message.const = reader.float();
                    break;
                case /* optional float lt */ 2:
                    message.lt = reader.float();
                    break;
                case /* optional float lte */ 3:
                    message.lte = reader.float();
                    break;
                case /* optional float gt */ 4:
                    message.gt = reader.float();
                    break;
                case /* optional float gte */ 5:
                    message.gte = reader.float();
                    break;
                case /* repeated float in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.float());
                    else
                        message.in.push(reader.float());
                    break;
                case /* repeated float not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.float());
                    else
                        message.not_in.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FloatRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit32).float(message.const);
        /* optional float lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Bit32).float(message.lt);
        /* optional float lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Bit32).float(message.lte);
        /* optional float gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Bit32).float(message.gt);
        /* optional float gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Bit32).float(message.gte);
        /* repeated float in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.float(message.in[i]);
            writer.join();
        }
        /* repeated float not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.float(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.FloatRules
 */
export const FloatRules = new FloatRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleRules$Type extends MessageType<DoubleRules> {
    constructor() {
        super("validate.DoubleRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<DoubleRules>): DoubleRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<DoubleRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoubleRules): DoubleRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double const */ 1:
                    message.const = reader.double();
                    break;
                case /* optional double lt */ 2:
                    message.lt = reader.double();
                    break;
                case /* optional double lte */ 3:
                    message.lte = reader.double();
                    break;
                case /* optional double gt */ 4:
                    message.gt = reader.double();
                    break;
                case /* optional double gte */ 5:
                    message.gte = reader.double();
                    break;
                case /* repeated double in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.double());
                    else
                        message.in.push(reader.double());
                    break;
                case /* repeated double not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.double());
                    else
                        message.not_in.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoubleRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Bit64).double(message.const);
        /* optional double lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Bit64).double(message.lt);
        /* optional double lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Bit64).double(message.lte);
        /* optional double gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Bit64).double(message.gt);
        /* optional double gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Bit64).double(message.gte);
        /* repeated double in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.double(message.in[i]);
            writer.join();
        }
        /* repeated double not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.double(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.DoubleRules
 */
export const DoubleRules = new DoubleRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int32Rules$Type extends MessageType<Int32Rules> {
    constructor() {
        super("validate.Int32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Int32Rules>): Int32Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<Int32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Int32Rules): Int32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* optional int32 lt */ 2:
                    message.lt = reader.int32();
                    break;
                case /* optional int32 lte */ 3:
                    message.lte = reader.int32();
                    break;
                case /* optional int32 gt */ 4:
                    message.gt = reader.int32();
                    break;
                case /* optional int32 gte */ 5:
                    message.gte = reader.int32();
                    break;
                case /* repeated int32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int32());
                    else
                        message.not_in.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Int32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int32(message.const);
        /* optional int32 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).int32(message.lt);
        /* optional int32 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).int32(message.lte);
        /* optional int32 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).int32(message.gt);
        /* optional int32 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).int32(message.gte);
        /* repeated int32 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int32(message.in[i]);
            writer.join();
        }
        /* repeated int32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.Int32Rules
 */
export const Int32Rules = new Int32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Int64Rules$Type extends MessageType<Int64Rules> {
    constructor() {
        super("validate.Int64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Int64Rules>): Int64Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<Int64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Int64Rules): Int64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 const */ 1:
                    message.const = reader.int64().toBigInt();
                    break;
                case /* optional int64 lt */ 2:
                    message.lt = reader.int64().toBigInt();
                    break;
                case /* optional int64 lte */ 3:
                    message.lte = reader.int64().toBigInt();
                    break;
                case /* optional int64 gt */ 4:
                    message.gt = reader.int64().toBigInt();
                    break;
                case /* optional int64 gte */ 5:
                    message.gte = reader.int64().toBigInt();
                    break;
                case /* repeated int64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int64().toBigInt());
                    else
                        message.in.push(reader.int64().toBigInt());
                    break;
                case /* repeated int64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int64().toBigInt());
                    else
                        message.not_in.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Int64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int64(message.const);
        /* optional int64 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).int64(message.lt);
        /* optional int64 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).int64(message.lte);
        /* optional int64 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).int64(message.gt);
        /* optional int64 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).int64(message.gte);
        /* repeated int64 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int64(message.in[i]);
            writer.join();
        }
        /* repeated int64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.Int64Rules
 */
export const Int64Rules = new Int64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UInt32Rules$Type extends MessageType<UInt32Rules> {
    constructor() {
        super("validate.UInt32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UInt32Rules>): UInt32Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<UInt32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UInt32Rules): UInt32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 const */ 1:
                    message.const = reader.uint32();
                    break;
                case /* optional uint32 lt */ 2:
                    message.lt = reader.uint32();
                    break;
                case /* optional uint32 lte */ 3:
                    message.lte = reader.uint32();
                    break;
                case /* optional uint32 gt */ 4:
                    message.gt = reader.uint32();
                    break;
                case /* optional uint32 gte */ 5:
                    message.gte = reader.uint32();
                    break;
                case /* repeated uint32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint32());
                    else
                        message.in.push(reader.uint32());
                    break;
                case /* repeated uint32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.uint32());
                    else
                        message.not_in.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UInt32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.const);
        /* optional uint32 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.lt);
        /* optional uint32 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.lte);
        /* optional uint32 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gt);
        /* optional uint32 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.gte);
        /* repeated uint32 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.uint32(message.in[i]);
            writer.join();
        }
        /* repeated uint32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.uint32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.UInt32Rules
 */
export const UInt32Rules = new UInt32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UInt64Rules$Type extends MessageType<UInt64Rules> {
    constructor() {
        super("validate.UInt64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UInt64Rules>): UInt64Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<UInt64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UInt64Rules): UInt64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 const */ 1:
                    message.const = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 lt */ 2:
                    message.lt = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 lte */ 3:
                    message.lte = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 gt */ 4:
                    message.gt = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 gte */ 5:
                    message.gte = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint64().toBigInt());
                    else
                        message.in.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.uint64().toBigInt());
                    else
                        message.not_in.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UInt64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.const);
        /* optional uint64 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.lt);
        /* optional uint64 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.lte);
        /* optional uint64 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.gt);
        /* optional uint64 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.gte);
        /* repeated uint64 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.uint64(message.in[i]);
            writer.join();
        }
        /* repeated uint64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.uint64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.UInt64Rules
 */
export const UInt64Rules = new UInt64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt32Rules$Type extends MessageType<SInt32Rules> {
    constructor() {
        super("validate.SInt32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SInt32Rules>): SInt32Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<SInt32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SInt32Rules): SInt32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* optional int32 lt */ 2:
                    message.lt = reader.int32();
                    break;
                case /* optional int32 lte */ 3:
                    message.lte = reader.int32();
                    break;
                case /* optional int32 gt */ 4:
                    message.gt = reader.int32();
                    break;
                case /* optional int32 gte */ 5:
                    message.gte = reader.int32();
                    break;
                case /* repeated int32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int32());
                    else
                        message.not_in.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SInt32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int32(message.const);
        /* optional int32 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).int32(message.lt);
        /* optional int32 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).int32(message.lte);
        /* optional int32 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).int32(message.gt);
        /* optional int32 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).int32(message.gte);
        /* repeated int32 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int32(message.in[i]);
            writer.join();
        }
        /* repeated int32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.SInt32Rules
 */
export const SInt32Rules = new SInt32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SInt64Rules$Type extends MessageType<SInt64Rules> {
    constructor() {
        super("validate.SInt64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SInt64Rules>): SInt64Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<SInt64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SInt64Rules): SInt64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 const */ 1:
                    message.const = reader.int64().toBigInt();
                    break;
                case /* optional int64 lt */ 2:
                    message.lt = reader.int64().toBigInt();
                    break;
                case /* optional int64 lte */ 3:
                    message.lte = reader.int64().toBigInt();
                    break;
                case /* optional int64 gt */ 4:
                    message.gt = reader.int64().toBigInt();
                    break;
                case /* optional int64 gte */ 5:
                    message.gte = reader.int64().toBigInt();
                    break;
                case /* repeated int64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int64().toBigInt());
                    else
                        message.in.push(reader.int64().toBigInt());
                    break;
                case /* repeated int64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int64().toBigInt());
                    else
                        message.not_in.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SInt64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int64(message.const);
        /* optional int64 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).int64(message.lt);
        /* optional int64 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).int64(message.lte);
        /* optional int64 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).int64(message.gt);
        /* optional int64 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).int64(message.gte);
        /* repeated int64 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int64(message.in[i]);
            writer.join();
        }
        /* repeated int64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.SInt64Rules
 */
export const SInt64Rules = new SInt64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fixed32Rules$Type extends MessageType<Fixed32Rules> {
    constructor() {
        super("validate.Fixed32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Fixed32Rules>): Fixed32Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<Fixed32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Fixed32Rules): Fixed32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 const */ 1:
                    message.const = reader.uint32();
                    break;
                case /* optional uint32 lt */ 2:
                    message.lt = reader.uint32();
                    break;
                case /* optional uint32 lte */ 3:
                    message.lte = reader.uint32();
                    break;
                case /* optional uint32 gt */ 4:
                    message.gt = reader.uint32();
                    break;
                case /* optional uint32 gte */ 5:
                    message.gte = reader.uint32();
                    break;
                case /* repeated uint32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint32());
                    else
                        message.in.push(reader.uint32());
                    break;
                case /* repeated uint32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.uint32());
                    else
                        message.not_in.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Fixed32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.const);
        /* optional uint32 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.lt);
        /* optional uint32 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.lte);
        /* optional uint32 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.gt);
        /* optional uint32 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.gte);
        /* repeated uint32 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.uint32(message.in[i]);
            writer.join();
        }
        /* repeated uint32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.uint32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.Fixed32Rules
 */
export const Fixed32Rules = new Fixed32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fixed64Rules$Type extends MessageType<Fixed64Rules> {
    constructor() {
        super("validate.Fixed64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Fixed64Rules>): Fixed64Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<Fixed64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Fixed64Rules): Fixed64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 const */ 1:
                    message.const = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 lt */ 2:
                    message.lt = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 lte */ 3:
                    message.lte = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 gt */ 4:
                    message.gt = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 gte */ 5:
                    message.gte = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.uint64().toBigInt());
                    else
                        message.in.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.uint64().toBigInt());
                    else
                        message.not_in.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Fixed64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.const);
        /* optional uint64 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.lt);
        /* optional uint64 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.lte);
        /* optional uint64 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.gt);
        /* optional uint64 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.gte);
        /* repeated uint64 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.uint64(message.in[i]);
            writer.join();
        }
        /* repeated uint64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.uint64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.Fixed64Rules
 */
export const Fixed64Rules = new Fixed64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFixed32Rules$Type extends MessageType<SFixed32Rules> {
    constructor() {
        super("validate.SFixed32Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SFixed32Rules>): SFixed32Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<SFixed32Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SFixed32Rules): SFixed32Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* optional int32 lt */ 2:
                    message.lt = reader.int32();
                    break;
                case /* optional int32 lte */ 3:
                    message.lte = reader.int32();
                    break;
                case /* optional int32 gt */ 4:
                    message.gt = reader.int32();
                    break;
                case /* optional int32 gte */ 5:
                    message.gte = reader.int32();
                    break;
                case /* repeated int32 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int32());
                    else
                        message.not_in.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SFixed32Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int32(message.const);
        /* optional int32 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).int32(message.lt);
        /* optional int32 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).int32(message.lte);
        /* optional int32 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).int32(message.gt);
        /* optional int32 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).int32(message.gte);
        /* repeated int32 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int32(message.in[i]);
            writer.join();
        }
        /* repeated int32 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.SFixed32Rules
 */
export const SFixed32Rules = new SFixed32Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SFixed64Rules$Type extends MessageType<SFixed64Rules> {
    constructor() {
        super("validate.SFixed64Rules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lt", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "lte", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "gt", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "gte", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SFixed64Rules>): SFixed64Rules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<SFixed64Rules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SFixed64Rules): SFixed64Rules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 const */ 1:
                    message.const = reader.int64().toBigInt();
                    break;
                case /* optional int64 lt */ 2:
                    message.lt = reader.int64().toBigInt();
                    break;
                case /* optional int64 lte */ 3:
                    message.lte = reader.int64().toBigInt();
                    break;
                case /* optional int64 gt */ 4:
                    message.gt = reader.int64().toBigInt();
                    break;
                case /* optional int64 gte */ 5:
                    message.gte = reader.int64().toBigInt();
                    break;
                case /* repeated int64 in */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int64().toBigInt());
                    else
                        message.in.push(reader.int64().toBigInt());
                    break;
                case /* repeated int64 not_in */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int64().toBigInt());
                    else
                        message.not_in.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SFixed64Rules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int64(message.const);
        /* optional int64 lt = 2; */
        if (message.lt !== undefined)
            writer.tag(2, WireType.Varint).int64(message.lt);
        /* optional int64 lte = 3; */
        if (message.lte !== undefined)
            writer.tag(3, WireType.Varint).int64(message.lte);
        /* optional int64 gt = 4; */
        if (message.gt !== undefined)
            writer.tag(4, WireType.Varint).int64(message.gt);
        /* optional int64 gte = 5; */
        if (message.gte !== undefined)
            writer.tag(5, WireType.Varint).int64(message.gte);
        /* repeated int64 in = 6; */
        if (message.in.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int64(message.in[i]);
            writer.join();
        }
        /* repeated int64 not_in = 7; */
        if (message.not_in.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int64(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.SFixed64Rules
 */
export const SFixed64Rules = new SFixed64Rules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolRules$Type extends MessageType<BoolRules> {
    constructor() {
        super("validate.BoolRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BoolRules>): BoolRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BoolRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoolRules): BoolRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool const */ 1:
                    message.const = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoolRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).bool(message.const);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.BoolRules
 */
export const BoolRules = new BoolRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringRules$Type extends MessageType<StringRules> {
    constructor() {
        super("validate.StringRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "min_len", kind: "scalar", localName: "min_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_len", kind: "scalar", localName: "max_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "len_bytes", kind: "scalar", localName: "len_bytes", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "min_bytes", kind: "scalar", localName: "min_bytes", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "max_bytes", kind: "scalar", localName: "max_bytes", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "prefix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "suffix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "contains", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "not_contains", kind: "scalar", localName: "not_contains", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "not_in", kind: "scalar", localName: "not_in", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "email", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "hostname", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "ip", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "ipv4", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "ipv6", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "uri", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "uri_ref", kind: "scalar", localName: "uri_ref", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "address", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "uuid", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StringRules>): StringRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        message.well_known = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StringRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringRules): StringRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string const */ 1:
                    message.const = reader.string();
                    break;
                case /* optional uint64 len */ 19:
                    message.len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_len */ 2:
                    message.min_len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_len */ 3:
                    message.max_len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 len_bytes */ 20:
                    message.len_bytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_bytes */ 4:
                    message.min_bytes = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_bytes */ 5:
                    message.max_bytes = reader.uint64().toBigInt();
                    break;
                case /* optional string pattern */ 6:
                    message.pattern = reader.string();
                    break;
                case /* optional string prefix */ 7:
                    message.prefix = reader.string();
                    break;
                case /* optional string suffix */ 8:
                    message.suffix = reader.string();
                    break;
                case /* optional string contains */ 9:
                    message.contains = reader.string();
                    break;
                case /* optional string not_contains */ 23:
                    message.not_contains = reader.string();
                    break;
                case /* repeated string in */ 10:
                    message.in.push(reader.string());
                    break;
                case /* repeated string not_in */ 11:
                    message.not_in.push(reader.string());
                    break;
                case /* bool email */ 12:
                    message.well_known = {
                        oneofKind: "email",
                        email: reader.bool()
                    };
                    break;
                case /* bool hostname */ 13:
                    message.well_known = {
                        oneofKind: "hostname",
                        hostname: reader.bool()
                    };
                    break;
                case /* bool ip */ 14:
                    message.well_known = {
                        oneofKind: "ip",
                        ip: reader.bool()
                    };
                    break;
                case /* bool ipv4 */ 15:
                    message.well_known = {
                        oneofKind: "ipv4",
                        ipv4: reader.bool()
                    };
                    break;
                case /* bool ipv6 */ 16:
                    message.well_known = {
                        oneofKind: "ipv6",
                        ipv6: reader.bool()
                    };
                    break;
                case /* bool uri */ 17:
                    message.well_known = {
                        oneofKind: "uri",
                        uri: reader.bool()
                    };
                    break;
                case /* bool uri_ref */ 18:
                    message.well_known = {
                        oneofKind: "uri_ref",
                        uri_ref: reader.bool()
                    };
                    break;
                case /* bool address */ 21:
                    message.well_known = {
                        oneofKind: "address",
                        address: reader.bool()
                    };
                    break;
                case /* bool uuid */ 22:
                    message.well_known = {
                        oneofKind: "uuid",
                        uuid: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.const);
        /* optional uint64 min_len = 2; */
        if (message.min_len !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.min_len);
        /* optional uint64 max_len = 3; */
        if (message.max_len !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.max_len);
        /* optional uint64 min_bytes = 4; */
        if (message.min_bytes !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.min_bytes);
        /* optional uint64 max_bytes = 5; */
        if (message.max_bytes !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.max_bytes);
        /* optional string pattern = 6; */
        if (message.pattern !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.pattern);
        /* optional string prefix = 7; */
        if (message.prefix !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.prefix);
        /* optional string suffix = 8; */
        if (message.suffix !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.suffix);
        /* optional string contains = 9; */
        if (message.contains !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.contains);
        /* repeated string in = 10; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.in[i]);
        /* repeated string not_in = 11; */
        for (let i = 0; i < message.not_in.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.not_in[i]);
        /* bool email = 12; */
        if (message.well_known.oneofKind === "email")
            writer.tag(12, WireType.Varint).bool(message.well_known.email);
        /* bool hostname = 13; */
        if (message.well_known.oneofKind === "hostname")
            writer.tag(13, WireType.Varint).bool(message.well_known.hostname);
        /* bool ip = 14; */
        if (message.well_known.oneofKind === "ip")
            writer.tag(14, WireType.Varint).bool(message.well_known.ip);
        /* bool ipv4 = 15; */
        if (message.well_known.oneofKind === "ipv4")
            writer.tag(15, WireType.Varint).bool(message.well_known.ipv4);
        /* bool ipv6 = 16; */
        if (message.well_known.oneofKind === "ipv6")
            writer.tag(16, WireType.Varint).bool(message.well_known.ipv6);
        /* bool uri = 17; */
        if (message.well_known.oneofKind === "uri")
            writer.tag(17, WireType.Varint).bool(message.well_known.uri);
        /* bool uri_ref = 18; */
        if (message.well_known.oneofKind === "uri_ref")
            writer.tag(18, WireType.Varint).bool(message.well_known.uri_ref);
        /* optional uint64 len = 19; */
        if (message.len !== undefined)
            writer.tag(19, WireType.Varint).uint64(message.len);
        /* optional uint64 len_bytes = 20; */
        if (message.len_bytes !== undefined)
            writer.tag(20, WireType.Varint).uint64(message.len_bytes);
        /* bool address = 21; */
        if (message.well_known.oneofKind === "address")
            writer.tag(21, WireType.Varint).bool(message.well_known.address);
        /* bool uuid = 22; */
        if (message.well_known.oneofKind === "uuid")
            writer.tag(22, WireType.Varint).bool(message.well_known.uuid);
        /* optional string not_contains = 23; */
        if (message.not_contains !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.not_contains);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.StringRules
 */
export const StringRules = new StringRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BytesRules$Type extends MessageType<BytesRules> {
    constructor() {
        super("validate.BytesRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 13, name: "len", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "min_len", kind: "scalar", localName: "min_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_len", kind: "scalar", localName: "max_len", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "prefix", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "suffix", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "contains", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "in", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "not_in", kind: "scalar", localName: "not_in", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "ip", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "ipv4", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "ipv6", kind: "scalar", oneof: "well_known", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BytesRules>): BytesRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        message.well_known = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<BytesRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BytesRules): BytesRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes const */ 1:
                    message.const = reader.bytes();
                    break;
                case /* optional uint64 len */ 13:
                    message.len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 min_len */ 2:
                    message.min_len = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_len */ 3:
                    message.max_len = reader.uint64().toBigInt();
                    break;
                case /* optional string pattern */ 4:
                    message.pattern = reader.string();
                    break;
                case /* optional bytes prefix */ 5:
                    message.prefix = reader.bytes();
                    break;
                case /* optional bytes suffix */ 6:
                    message.suffix = reader.bytes();
                    break;
                case /* optional bytes contains */ 7:
                    message.contains = reader.bytes();
                    break;
                case /* repeated bytes in */ 8:
                    message.in.push(reader.bytes());
                    break;
                case /* repeated bytes not_in */ 9:
                    message.not_in.push(reader.bytes());
                    break;
                case /* bool ip */ 10:
                    message.well_known = {
                        oneofKind: "ip",
                        ip: reader.bool()
                    };
                    break;
                case /* bool ipv4 */ 11:
                    message.well_known = {
                        oneofKind: "ipv4",
                        ipv4: reader.bool()
                    };
                    break;
                case /* bool ipv6 */ 12:
                    message.well_known = {
                        oneofKind: "ipv6",
                        ipv6: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BytesRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.const);
        /* optional uint64 min_len = 2; */
        if (message.min_len !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.min_len);
        /* optional uint64 max_len = 3; */
        if (message.max_len !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.max_len);
        /* optional string pattern = 4; */
        if (message.pattern !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.pattern);
        /* optional bytes prefix = 5; */
        if (message.prefix !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.prefix);
        /* optional bytes suffix = 6; */
        if (message.suffix !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.suffix);
        /* optional bytes contains = 7; */
        if (message.contains !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.contains);
        /* repeated bytes in = 8; */
        for (let i = 0; i < message.in.length; i++)
            writer.tag(8, WireType.LengthDelimited).bytes(message.in[i]);
        /* repeated bytes not_in = 9; */
        for (let i = 0; i < message.not_in.length; i++)
            writer.tag(9, WireType.LengthDelimited).bytes(message.not_in[i]);
        /* bool ip = 10; */
        if (message.well_known.oneofKind === "ip")
            writer.tag(10, WireType.Varint).bool(message.well_known.ip);
        /* bool ipv4 = 11; */
        if (message.well_known.oneofKind === "ipv4")
            writer.tag(11, WireType.Varint).bool(message.well_known.ipv4);
        /* bool ipv6 = 12; */
        if (message.well_known.oneofKind === "ipv6")
            writer.tag(12, WireType.Varint).bool(message.well_known.ipv6);
        /* optional uint64 len = 13; */
        if (message.len !== undefined)
            writer.tag(13, WireType.Varint).uint64(message.len);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.BytesRules
 */
export const BytesRules = new BytesRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnumRules$Type extends MessageType<EnumRules> {
    constructor() {
        super("validate.EnumRules", [
            { no: 1, name: "const", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "defined_only", kind: "scalar", localName: "defined_only", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "in", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "not_in", kind: "scalar", localName: "not_in", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnumRules>): EnumRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.in = [];
        message.not_in = [];
        if (value !== undefined)
            reflectionMergePartial<EnumRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumRules): EnumRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 const */ 1:
                    message.const = reader.int32();
                    break;
                case /* optional bool defined_only */ 2:
                    message.defined_only = reader.bool();
                    break;
                case /* repeated int32 in */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.in.push(reader.int32());
                    else
                        message.in.push(reader.int32());
                    break;
                case /* repeated int32 not_in */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.not_in.push(reader.int32());
                    else
                        message.not_in.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnumRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 const = 1; */
        if (message.const !== undefined)
            writer.tag(1, WireType.Varint).int32(message.const);
        /* optional bool defined_only = 2; */
        if (message.defined_only !== undefined)
            writer.tag(2, WireType.Varint).bool(message.defined_only);
        /* repeated int32 in = 3; */
        if (message.in.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.in.length; i++)
                writer.int32(message.in[i]);
            writer.join();
        }
        /* repeated int32 not_in = 4; */
        if (message.not_in.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.not_in.length; i++)
                writer.int32(message.not_in[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.EnumRules
 */
export const EnumRules = new EnumRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageRules$Type extends MessageType<MessageRules> {
    constructor() {
        super("validate.MessageRules", [
            { no: 1, name: "skip", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "required", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MessageRules>): MessageRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MessageRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageRules): MessageRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool skip */ 1:
                    message.skip = reader.bool();
                    break;
                case /* optional bool required */ 2:
                    message.required = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool skip = 1; */
        if (message.skip !== undefined)
            writer.tag(1, WireType.Varint).bool(message.skip);
        /* optional bool required = 2; */
        if (message.required !== undefined)
            writer.tag(2, WireType.Varint).bool(message.required);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.MessageRules
 */
export const MessageRules = new MessageRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RepeatedRules$Type extends MessageType<RepeatedRules> {
    constructor() {
        super("validate.RepeatedRules", [
            { no: 1, name: "min_items", kind: "scalar", localName: "min_items", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_items", kind: "scalar", localName: "max_items", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "unique", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "items", kind: "message", T: () => FieldRules }
        ]);
    }
    create(value?: PartialMessage<RepeatedRules>): RepeatedRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RepeatedRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RepeatedRules): RepeatedRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 min_items */ 1:
                    message.min_items = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_items */ 2:
                    message.max_items = reader.uint64().toBigInt();
                    break;
                case /* optional bool unique */ 3:
                    message.unique = reader.bool();
                    break;
                case /* optional validate.FieldRules items */ 4:
                    message.items = FieldRules.internalBinaryRead(reader, reader.uint32(), options, message.items);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RepeatedRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 min_items = 1; */
        if (message.min_items !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.min_items);
        /* optional uint64 max_items = 2; */
        if (message.max_items !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.max_items);
        /* optional bool unique = 3; */
        if (message.unique !== undefined)
            writer.tag(3, WireType.Varint).bool(message.unique);
        /* optional validate.FieldRules items = 4; */
        if (message.items)
            FieldRules.internalBinaryWrite(message.items, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.RepeatedRules
 */
export const RepeatedRules = new RepeatedRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapRules$Type extends MessageType<MapRules> {
    constructor() {
        super("validate.MapRules", [
            { no: 1, name: "min_pairs", kind: "scalar", localName: "min_pairs", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_pairs", kind: "scalar", localName: "max_pairs", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "keys", kind: "message", T: () => FieldRules },
            { no: 4, name: "values", kind: "message", T: () => FieldRules }
        ]);
    }
    create(value?: PartialMessage<MapRules>): MapRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MapRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapRules): MapRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 min_pairs */ 1:
                    message.min_pairs = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_pairs */ 2:
                    message.max_pairs = reader.uint64().toBigInt();
                    break;
                case /* optional validate.FieldRules keys */ 3:
                    message.keys = FieldRules.internalBinaryRead(reader, reader.uint32(), options, message.keys);
                    break;
                case /* optional validate.FieldRules values */ 4:
                    message.values = FieldRules.internalBinaryRead(reader, reader.uint32(), options, message.values);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 min_pairs = 1; */
        if (message.min_pairs !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.min_pairs);
        /* optional uint64 max_pairs = 2; */
        if (message.max_pairs !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.max_pairs);
        /* optional validate.FieldRules keys = 3; */
        if (message.keys)
            FieldRules.internalBinaryWrite(message.keys, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional validate.FieldRules values = 4; */
        if (message.values)
            FieldRules.internalBinaryWrite(message.values, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message validate.MapRules
 */
export const MapRules = new MapRules$Type();
