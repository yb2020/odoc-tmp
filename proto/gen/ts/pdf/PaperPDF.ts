// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/pdf/PaperPDF.proto" (package "pdf", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AuthorBean } from "../user/AuthorBean";
/**
 * 论文PDF模型
 *
 * @generated from protobuf message pdf.PaperPDF
 */
export interface PaperPDF {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string app_id = 2
     */
    app_id: string;
    /**
     * @generated from protobuf field: string paper_id = 3
     */
    paper_id: string;
    /**
     * @generated from protobuf field: string source_url = 4
     */
    source_url: string;
    /**
     * @generated from protobuf field: string store_static_domain = 5
     */
    store_static_domain: string;
    /**
     * @generated from protobuf field: string store_file_full_name = 6
     */
    store_file_full_name: string;
    /**
     * @generated from protobuf field: string creator = 7
     */
    creator: string;
    /**
     * @generated from protobuf field: string creator_id = 8
     */
    creator_id: string;
    /**
     * @generated from protobuf field: string modifier = 9
     */
    modifier: string;
    /**
     * @generated from protobuf field: string modifier_id = 10
     */
    modifier_id: string;
    /**
     * @generated from protobuf field: string fileSHA256 = 11
     */
    fileSHA256: string;
    /**
     * @generated from protobuf field: string download_url = 12
     */
    download_url: string;
    /**
     * @generated from protobuf field: string record_id = 13
     */
    record_id: string;
    /**
     * @generated from protobuf field: string private_status = 14
     */
    private_status: string;
    /**
     * @generated from protobuf field: string online_status = 15
     */
    online_status: string;
    /**
     * @generated from protobuf field: string auth_status = 16
     */
    auth_status: string;
    /**
     * @generated from protobuf field: string catalogue = 17
     */
    catalogue: string;
    /**
     * @generated from protobuf field: uint32 parse_count = 18
     */
    parse_count: number;
    /**
     * @generated from protobuf field: string licence_type = 19
     */
    licence_type: string;
    /**
     * @generated from protobuf field: float size = 20
     */
    size: number;
    /**
     * @generated from protobuf field: uint32 page_count = 21
     */
    page_count: number;
    /**
     * @generated from protobuf field: uint64 created_at = 22
     */
    created_at: bigint;
    /**
     * @generated from protobuf field: uint64 updated_at = 23
     */
    updated_at: bigint;
}
/**
 * @api_path: /api/pdf/paper
 * @method: POST
 * @content-type: application/json
 * @summary: 创建论文PDF
 *
 * @generated from protobuf message pdf.CreatePaperPDFRequest
 */
export interface CreatePaperPDFRequest {
    /**
     * @generated from protobuf field: string app_id = 1
     */
    app_id: string;
    /**
     * @generated from protobuf field: string paper_id = 2
     */
    paper_id: string;
    /**
     * @generated from protobuf field: string source_url = 3
     */
    source_url: string;
    /**
     * @generated from protobuf field: string store_static_domain = 4
     */
    store_static_domain: string;
    /**
     * @generated from protobuf field: string store_file_full_name = 5
     */
    store_file_full_name: string;
    /**
     * @generated from protobuf field: string creator = 6
     */
    creator: string;
    /**
     * @generated from protobuf field: string creator_id = 7
     */
    creator_id: string;
    /**
     * @generated from protobuf field: string fileSHA256 = 8
     */
    fileSHA256: string;
    /**
     * @generated from protobuf field: string download_url = 9
     */
    download_url: string;
    /**
     * @generated from protobuf field: string record_id = 10
     */
    record_id: string;
    /**
     * @generated from protobuf field: string private_status = 11
     */
    private_status: string;
    /**
     * @generated from protobuf field: string online_status = 12
     */
    online_status: string;
    /**
     * @generated from protobuf field: string auth_status = 13
     */
    auth_status: string;
    /**
     * @generated from protobuf field: string catalogue = 14
     */
    catalogue: string;
    /**
     * @generated from protobuf field: uint32 parse_count = 15
     */
    parse_count: number;
    /**
     * @generated from protobuf field: string licence_type = 16
     */
    licence_type: string;
    /**
     * @generated from protobuf field: float size = 17
     */
    size: number;
    /**
     * @generated from protobuf field: uint32 page_count = 18
     */
    page_count: number;
}
/**
 * @generated from protobuf message pdf.CreatePaperPDFResponse
 */
export interface CreatePaperPDFResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/pdf/paper
 * @method: GET
 * @content-type: application/json
 * @summary: 获取论文PDF
 *
 * @generated from protobuf message pdf.GetPaperPDFRequest
 */
export interface GetPaperPDFRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message pdf.GetPaperPDFResponse
 */
export interface GetPaperPDFResponse {
    /**
     * @generated from protobuf field: pdf.PaperPDF pdf = 1
     */
    pdf?: PaperPDF;
}
/**
 * @api_path: /api/pdf/paper
 * @method: PUT
 * @content-type: application/json
 * @summary: 更新论文PDF
 *
 * @generated from protobuf message pdf.UpdatePaperPDFRequest
 */
export interface UpdatePaperPDFRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string source_url = 2
     */
    source_url: string;
    /**
     * @generated from protobuf field: string download_url = 3
     */
    download_url: string;
    /**
     * @generated from protobuf field: string private_status = 4
     */
    private_status: string;
    /**
     * @generated from protobuf field: string online_status = 5
     */
    online_status: string;
    /**
     * @generated from protobuf field: string auth_status = 6
     */
    auth_status: string;
    /**
     * @generated from protobuf field: string catalogue = 7
     */
    catalogue: string;
    /**
     * @generated from protobuf field: uint32 parse_count = 8
     */
    parse_count: number;
    /**
     * @generated from protobuf field: uint32 page_count = 9
     */
    page_count: number;
}
/**
 * @generated from protobuf message pdf.UpdatePaperPDFResponse
 */
export interface UpdatePaperPDFResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/pdf/paper
 * @method: DELETE
 * @content-type: application/json
 * @summary: 删除论文PDF
 *
 * @generated from protobuf message pdf.DeletePaperPDFRequest
 */
export interface DeletePaperPDFRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message pdf.DeletePaperPDFResponse
 */
export interface DeletePaperPDFResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @api_path: /api/pdf/papers
 * @method: GET
 * @content-type: application/json
 * @summary: 列出论文PDF
 *
 * @generated from protobuf message pdf.ListPaperPDFsRequest
 */
export interface ListPaperPDFsRequest {
    /**
     * @generated from protobuf field: uint32 limit = 1
     */
    limit: number;
    /**
     * @generated from protobuf field: uint32 offset = 2
     */
    offset: number;
}
/**
 * @generated from protobuf message pdf.ListPaperPDFsResponse
 */
export interface ListPaperPDFsResponse {
    /**
     * @generated from protobuf field: repeated pdf.PaperPDF pdfs = 1
     */
    pdfs: PaperPDF[];
}
/**
 * @api_path: /api/pdf/papers/count
 * @method: GET
 * @content-type: application/json
 * @summary: 获取论文PDF总数
 *
 * @generated from protobuf message pdf.CountPaperPDFsRequest
 */
export interface CountPaperPDFsRequest {
}
/**
 * @generated from protobuf message pdf.CountPaperPDFsResponse
 */
export interface CountPaperPDFsResponse {
    /**
     * @generated from protobuf field: uint64 count = 1
     */
    count: bigint;
}
/**
 * @api_path: /api/pdf/paper/byPaperId
 * @method: GET
 * @content-type: application/json
 * @summary: 根据论文ID获取PDF
 *
 * @generated from protobuf message pdf.GetPaperPDFByPaperIdRequest
 */
export interface GetPaperPDFByPaperIdRequest {
    /**
     * @generated from protobuf field: string paper_id = 1
     */
    paper_id: string;
}
/**
 * @generated from protobuf message pdf.GetPaperPDFByPaperIdResponse
 */
export interface GetPaperPDFByPaperIdResponse {
    /**
     * @generated from protobuf field: pdf.PaperPDF pdf = 1
     */
    pdf?: PaperPDF;
}
/**
 * @api_path: /api/pdf/paper/byMD5
 * @method: GET
 * @content-type: application/json
 * @summary: 根据文件hash获取PDF
 *
 * @generated from protobuf message pdf.GetPaperPDFByFileSHA256Request
 */
export interface GetPaperPDFByFileSHA256Request {
    /**
     * @generated from protobuf field: string fileSHA256 = 1
     */
    fileSHA256: string;
}
/**
 * @generated from protobuf message pdf.GetPaperPDFByFileSHA256Response
 */
export interface GetPaperPDFByFileSHA256Response {
    /**
     * @generated from protobuf field: pdf.PaperPDF pdf = 1
     */
    pdf?: PaperPDF;
}
/**
 * @old_api_path: /aiKnowledge/pdf/getPdfStatusInfo/v2
 * @api_path: /api/pdf/getPdfStatusInfo/v2
 * @method: GET
 * @content-type: application/json
 * @summary: 获取pdf相关状态信息
 *
 * @generated from protobuf message pdf.GetPdfStatusInfoRequest
 */
export interface GetPdfStatusInfoRequest {
    /**
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string noteId = 2
     */
    noteId: string;
}
/**
 * @generated from protobuf message pdf.GetPdfStatusInfoResponse
 */
export interface GetPdfStatusInfoResponse {
    /**
     * @generated from protobuf field: bool noteOpenAccessFlag = 1
     */
    noteOpenAccessFlag: boolean; // 笔记是否公开,true=公开,false=非公开
    /**
     * @generated from protobuf field: bool hasPdfAccessFlag = 2
     */
    hasPdfAccessFlag: boolean; // 当前用户是否有pdf权限,true=有权限,false=无权限
    /**
     * @generated from protobuf field: string docName = 3
     */
    docName: string; // 文献名称
    /**
     * @generated from protobuf field: pdf.UserStatusEnum pdfUserStatus = 4
     */
    pdfUserStatus: UserStatusEnum; // pdf用户状态
    /**
     * @generated from protobuf field: pdf.UserStatusEnum noteUserStatus = 5
     */
    noteUserStatus: UserStatusEnum; // 笔记用户状态
    /**
     * @generated from protobuf field: string pdfUrl = 6
     */
    pdfUrl: string; // pdfUrl
    /**
     * @generated from protobuf field: string paperTitle = 7
     */
    paperTitle: string; // 论文标题
    /**
     * @generated from protobuf field: string paperId = 8
     */
    paperId: string; // 论文ID
    /**
     * @generated from protobuf field: string authPdfId = 9
     */
    authPdfId: string; // 认证公开的pdfId
    /**
     * @generated from protobuf field: user.AuthorBean pdfOwnerInfo = 10
     */
    pdfOwnerInfo?: AuthorBean; // 该pdf上传者信息
}
/**
 * @api_path: /api/pdf/pdfReader/getSetting
 * @method: POST
 * @content-type: application/json
 * @summary: 获取pdf阅读设置
 *
 * @generated from protobuf message pdf.GetPdfReaderSettingRequest
 */
export interface GetPdfReaderSettingRequest {
    /**
     * @generated from protobuf field: int32 clientType = 1
     */
    clientType: number;
}
/**
 * @generated from protobuf message pdf.GetPdfReaderSettingResponse
 */
export interface GetPdfReaderSettingResponse {
    /**
     * @generated from protobuf field: string setting = 1
     */
    setting: string;
}
/**
 * @api_path: /api/pdf/pdfReader/recordSetting
 * @method: POST
 * @content-type: application/json
 * @summary: 记录pdf阅读设置
 *
 * @generated from protobuf message pdf.RecordPdfReaderSettingRequest
 */
export interface RecordPdfReaderSettingRequest {
    /**
     * @generated from protobuf field: int32 clientType = 1
     */
    clientType: number;
    /**
     * @generated from protobuf field: string setting = 2
     */
    setting: string;
}
/**
 * 用户状态枚举
 *
 * @generated from protobuf enum pdf.UserStatusEnum
 */
export enum UserStatusEnum {
    /**
     * 游客
     *
     * @generated from protobuf enum value: TOURIST = 0;
     */
    TOURIST = 0,
    /**
     * 访客
     *
     * @generated from protobuf enum value: GUEST = 1;
     */
    GUEST = 1,
    /**
     * 所有者
     *
     * @generated from protobuf enum value: OWNER = 2;
     */
    OWNER = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class PaperPDF$Type extends MessageType<PaperPDF> {
    constructor() {
        super("pdf.PaperPDF", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "app_id", kind: "scalar", localName: "app_id", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "paper_id", kind: "scalar", localName: "paper_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "source_url", kind: "scalar", localName: "source_url", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "store_static_domain", kind: "scalar", localName: "store_static_domain", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 6, name: "store_file_full_name", kind: "scalar", localName: "store_file_full_name", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 7, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "creator_id", kind: "scalar", localName: "creator_id", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "modifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "modifier_id", kind: "scalar", localName: "modifier_id", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "download_url", kind: "scalar", localName: "download_url", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "record_id", kind: "scalar", localName: "record_id", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "private_status", kind: "scalar", localName: "private_status", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "online_status", kind: "scalar", localName: "online_status", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "auth_status", kind: "scalar", localName: "auth_status", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "catalogue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "parse_count", kind: "scalar", localName: "parse_count", T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "licence_type", kind: "scalar", localName: "licence_type", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "size", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "page_count", kind: "scalar", localName: "page_count", T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 23, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PaperPDF>): PaperPDF {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.app_id = "";
        message.paper_id = "";
        message.source_url = "";
        message.store_static_domain = "";
        message.store_file_full_name = "";
        message.creator = "";
        message.creator_id = "";
        message.modifier = "";
        message.modifier_id = "";
        message.fileSHA256 = "";
        message.download_url = "";
        message.record_id = "";
        message.private_status = "";
        message.online_status = "";
        message.auth_status = "";
        message.catalogue = "";
        message.parse_count = 0;
        message.licence_type = "";
        message.size = 0;
        message.page_count = 0;
        message.created_at = 0n;
        message.updated_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<PaperPDF>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperPDF): PaperPDF {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string app_id */ 2:
                    message.app_id = reader.string();
                    break;
                case /* string paper_id */ 3:
                    message.paper_id = reader.string();
                    break;
                case /* string source_url */ 4:
                    message.source_url = reader.string();
                    break;
                case /* string store_static_domain */ 5:
                    message.store_static_domain = reader.string();
                    break;
                case /* string store_file_full_name */ 6:
                    message.store_file_full_name = reader.string();
                    break;
                case /* string creator */ 7:
                    message.creator = reader.string();
                    break;
                case /* string creator_id */ 8:
                    message.creator_id = reader.string();
                    break;
                case /* string modifier */ 9:
                    message.modifier = reader.string();
                    break;
                case /* string modifier_id */ 10:
                    message.modifier_id = reader.string();
                    break;
                case /* string fileSHA256 */ 11:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string download_url */ 12:
                    message.download_url = reader.string();
                    break;
                case /* string record_id */ 13:
                    message.record_id = reader.string();
                    break;
                case /* string private_status */ 14:
                    message.private_status = reader.string();
                    break;
                case /* string online_status */ 15:
                    message.online_status = reader.string();
                    break;
                case /* string auth_status */ 16:
                    message.auth_status = reader.string();
                    break;
                case /* string catalogue */ 17:
                    message.catalogue = reader.string();
                    break;
                case /* uint32 parse_count */ 18:
                    message.parse_count = reader.uint32();
                    break;
                case /* string licence_type */ 19:
                    message.licence_type = reader.string();
                    break;
                case /* float size */ 20:
                    message.size = reader.float();
                    break;
                case /* uint32 page_count */ 21:
                    message.page_count = reader.uint32();
                    break;
                case /* uint64 created_at */ 22:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 23:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperPDF, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string app_id = 2; */
        if (message.app_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.app_id);
        /* string paper_id = 3; */
        if (message.paper_id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.paper_id);
        /* string source_url = 4; */
        if (message.source_url !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.source_url);
        /* string store_static_domain = 5; */
        if (message.store_static_domain !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.store_static_domain);
        /* string store_file_full_name = 6; */
        if (message.store_file_full_name !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.store_file_full_name);
        /* string creator = 7; */
        if (message.creator !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.creator);
        /* string creator_id = 8; */
        if (message.creator_id !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.creator_id);
        /* string modifier = 9; */
        if (message.modifier !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.modifier);
        /* string modifier_id = 10; */
        if (message.modifier_id !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.modifier_id);
        /* string fileSHA256 = 11; */
        if (message.fileSHA256 !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.fileSHA256);
        /* string download_url = 12; */
        if (message.download_url !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.download_url);
        /* string record_id = 13; */
        if (message.record_id !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.record_id);
        /* string private_status = 14; */
        if (message.private_status !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.private_status);
        /* string online_status = 15; */
        if (message.online_status !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.online_status);
        /* string auth_status = 16; */
        if (message.auth_status !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.auth_status);
        /* string catalogue = 17; */
        if (message.catalogue !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.catalogue);
        /* uint32 parse_count = 18; */
        if (message.parse_count !== 0)
            writer.tag(18, WireType.Varint).uint32(message.parse_count);
        /* string licence_type = 19; */
        if (message.licence_type !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.licence_type);
        /* float size = 20; */
        if (message.size !== 0)
            writer.tag(20, WireType.Bit32).float(message.size);
        /* uint32 page_count = 21; */
        if (message.page_count !== 0)
            writer.tag(21, WireType.Varint).uint32(message.page_count);
        /* uint64 created_at = 22; */
        if (message.created_at !== 0n)
            writer.tag(22, WireType.Varint).uint64(message.created_at);
        /* uint64 updated_at = 23; */
        if (message.updated_at !== 0n)
            writer.tag(23, WireType.Varint).uint64(message.updated_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.PaperPDF
 */
export const PaperPDF = new PaperPDF$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePaperPDFRequest$Type extends MessageType<CreatePaperPDFRequest> {
    constructor() {
        super("pdf.CreatePaperPDFRequest", [
            { no: 1, name: "app_id", kind: "scalar", localName: "app_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "paper_id", kind: "scalar", localName: "paper_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "source_url", kind: "scalar", localName: "source_url", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "store_static_domain", kind: "scalar", localName: "store_static_domain", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 5, name: "store_file_full_name", kind: "scalar", localName: "store_file_full_name", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 6, name: "creator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "creator_id", kind: "scalar", localName: "creator_id", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "download_url", kind: "scalar", localName: "download_url", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "record_id", kind: "scalar", localName: "record_id", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "private_status", kind: "scalar", localName: "private_status", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "online_status", kind: "scalar", localName: "online_status", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "auth_status", kind: "scalar", localName: "auth_status", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "catalogue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "parse_count", kind: "scalar", localName: "parse_count", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "licence_type", kind: "scalar", localName: "licence_type", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "size", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 18, name: "page_count", kind: "scalar", localName: "page_count", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePaperPDFRequest>): CreatePaperPDFRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.app_id = "";
        message.paper_id = "";
        message.source_url = "";
        message.store_static_domain = "";
        message.store_file_full_name = "";
        message.creator = "";
        message.creator_id = "";
        message.fileSHA256 = "";
        message.download_url = "";
        message.record_id = "";
        message.private_status = "";
        message.online_status = "";
        message.auth_status = "";
        message.catalogue = "";
        message.parse_count = 0;
        message.licence_type = "";
        message.size = 0;
        message.page_count = 0;
        if (value !== undefined)
            reflectionMergePartial<CreatePaperPDFRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePaperPDFRequest): CreatePaperPDFRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string app_id */ 1:
                    message.app_id = reader.string();
                    break;
                case /* string paper_id */ 2:
                    message.paper_id = reader.string();
                    break;
                case /* string source_url */ 3:
                    message.source_url = reader.string();
                    break;
                case /* string store_static_domain */ 4:
                    message.store_static_domain = reader.string();
                    break;
                case /* string store_file_full_name */ 5:
                    message.store_file_full_name = reader.string();
                    break;
                case /* string creator */ 6:
                    message.creator = reader.string();
                    break;
                case /* string creator_id */ 7:
                    message.creator_id = reader.string();
                    break;
                case /* string fileSHA256 */ 8:
                    message.fileSHA256 = reader.string();
                    break;
                case /* string download_url */ 9:
                    message.download_url = reader.string();
                    break;
                case /* string record_id */ 10:
                    message.record_id = reader.string();
                    break;
                case /* string private_status */ 11:
                    message.private_status = reader.string();
                    break;
                case /* string online_status */ 12:
                    message.online_status = reader.string();
                    break;
                case /* string auth_status */ 13:
                    message.auth_status = reader.string();
                    break;
                case /* string catalogue */ 14:
                    message.catalogue = reader.string();
                    break;
                case /* uint32 parse_count */ 15:
                    message.parse_count = reader.uint32();
                    break;
                case /* string licence_type */ 16:
                    message.licence_type = reader.string();
                    break;
                case /* float size */ 17:
                    message.size = reader.float();
                    break;
                case /* uint32 page_count */ 18:
                    message.page_count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePaperPDFRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string app_id = 1; */
        if (message.app_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.app_id);
        /* string paper_id = 2; */
        if (message.paper_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paper_id);
        /* string source_url = 3; */
        if (message.source_url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.source_url);
        /* string store_static_domain = 4; */
        if (message.store_static_domain !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.store_static_domain);
        /* string store_file_full_name = 5; */
        if (message.store_file_full_name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.store_file_full_name);
        /* string creator = 6; */
        if (message.creator !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.creator);
        /* string creator_id = 7; */
        if (message.creator_id !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.creator_id);
        /* string fileSHA256 = 8; */
        if (message.fileSHA256 !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.fileSHA256);
        /* string download_url = 9; */
        if (message.download_url !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.download_url);
        /* string record_id = 10; */
        if (message.record_id !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.record_id);
        /* string private_status = 11; */
        if (message.private_status !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.private_status);
        /* string online_status = 12; */
        if (message.online_status !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.online_status);
        /* string auth_status = 13; */
        if (message.auth_status !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.auth_status);
        /* string catalogue = 14; */
        if (message.catalogue !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.catalogue);
        /* uint32 parse_count = 15; */
        if (message.parse_count !== 0)
            writer.tag(15, WireType.Varint).uint32(message.parse_count);
        /* string licence_type = 16; */
        if (message.licence_type !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.licence_type);
        /* float size = 17; */
        if (message.size !== 0)
            writer.tag(17, WireType.Bit32).float(message.size);
        /* uint32 page_count = 18; */
        if (message.page_count !== 0)
            writer.tag(18, WireType.Varint).uint32(message.page_count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.CreatePaperPDFRequest
 */
export const CreatePaperPDFRequest = new CreatePaperPDFRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePaperPDFResponse$Type extends MessageType<CreatePaperPDFResponse> {
    constructor() {
        super("pdf.CreatePaperPDFResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreatePaperPDFResponse>): CreatePaperPDFResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<CreatePaperPDFResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePaperPDFResponse): CreatePaperPDFResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePaperPDFResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.CreatePaperPDFResponse
 */
export const CreatePaperPDFResponse = new CreatePaperPDFResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperPDFRequest$Type extends MessageType<GetPaperPDFRequest> {
    constructor() {
        super("pdf.GetPaperPDFRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperPDFRequest>): GetPaperPDFRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperPDFRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperPDFRequest): GetPaperPDFRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperPDFRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPaperPDFRequest
 */
export const GetPaperPDFRequest = new GetPaperPDFRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperPDFResponse$Type extends MessageType<GetPaperPDFResponse> {
    constructor() {
        super("pdf.GetPaperPDFResponse", [
            { no: 1, name: "pdf", kind: "message", T: () => PaperPDF }
        ]);
    }
    create(value?: PartialMessage<GetPaperPDFResponse>): GetPaperPDFResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaperPDFResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperPDFResponse): GetPaperPDFResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pdf.PaperPDF pdf */ 1:
                    message.pdf = PaperPDF.internalBinaryRead(reader, reader.uint32(), options, message.pdf);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperPDFResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pdf.PaperPDF pdf = 1; */
        if (message.pdf)
            PaperPDF.internalBinaryWrite(message.pdf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPaperPDFResponse
 */
export const GetPaperPDFResponse = new GetPaperPDFResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaperPDFRequest$Type extends MessageType<UpdatePaperPDFRequest> {
    constructor() {
        super("pdf.UpdatePaperPDFRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "source_url", kind: "scalar", localName: "source_url", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "download_url", kind: "scalar", localName: "download_url", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "private_status", kind: "scalar", localName: "private_status", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "online_status", kind: "scalar", localName: "online_status", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "auth_status", kind: "scalar", localName: "auth_status", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "catalogue", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "parse_count", kind: "scalar", localName: "parse_count", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "page_count", kind: "scalar", localName: "page_count", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePaperPDFRequest>): UpdatePaperPDFRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.source_url = "";
        message.download_url = "";
        message.private_status = "";
        message.online_status = "";
        message.auth_status = "";
        message.catalogue = "";
        message.parse_count = 0;
        message.page_count = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdatePaperPDFRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaperPDFRequest): UpdatePaperPDFRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string source_url */ 2:
                    message.source_url = reader.string();
                    break;
                case /* string download_url */ 3:
                    message.download_url = reader.string();
                    break;
                case /* string private_status */ 4:
                    message.private_status = reader.string();
                    break;
                case /* string online_status */ 5:
                    message.online_status = reader.string();
                    break;
                case /* string auth_status */ 6:
                    message.auth_status = reader.string();
                    break;
                case /* string catalogue */ 7:
                    message.catalogue = reader.string();
                    break;
                case /* uint32 parse_count */ 8:
                    message.parse_count = reader.uint32();
                    break;
                case /* uint32 page_count */ 9:
                    message.page_count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaperPDFRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string source_url = 2; */
        if (message.source_url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.source_url);
        /* string download_url = 3; */
        if (message.download_url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.download_url);
        /* string private_status = 4; */
        if (message.private_status !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.private_status);
        /* string online_status = 5; */
        if (message.online_status !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.online_status);
        /* string auth_status = 6; */
        if (message.auth_status !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.auth_status);
        /* string catalogue = 7; */
        if (message.catalogue !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.catalogue);
        /* uint32 parse_count = 8; */
        if (message.parse_count !== 0)
            writer.tag(8, WireType.Varint).uint32(message.parse_count);
        /* uint32 page_count = 9; */
        if (message.page_count !== 0)
            writer.tag(9, WireType.Varint).uint32(message.page_count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.UpdatePaperPDFRequest
 */
export const UpdatePaperPDFRequest = new UpdatePaperPDFRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePaperPDFResponse$Type extends MessageType<UpdatePaperPDFResponse> {
    constructor() {
        super("pdf.UpdatePaperPDFResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePaperPDFResponse>): UpdatePaperPDFResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<UpdatePaperPDFResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePaperPDFResponse): UpdatePaperPDFResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePaperPDFResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.UpdatePaperPDFResponse
 */
export const UpdatePaperPDFResponse = new UpdatePaperPDFResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaperPDFRequest$Type extends MessageType<DeletePaperPDFRequest> {
    constructor() {
        super("pdf.DeletePaperPDFRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<DeletePaperPDFRequest>): DeletePaperPDFRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeletePaperPDFRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaperPDFRequest): DeletePaperPDFRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePaperPDFRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.DeletePaperPDFRequest
 */
export const DeletePaperPDFRequest = new DeletePaperPDFRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePaperPDFResponse$Type extends MessageType<DeletePaperPDFResponse> {
    constructor() {
        super("pdf.DeletePaperPDFResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePaperPDFResponse>): DeletePaperPDFResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeletePaperPDFResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePaperPDFResponse): DeletePaperPDFResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePaperPDFResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.DeletePaperPDFResponse
 */
export const DeletePaperPDFResponse = new DeletePaperPDFResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPaperPDFsRequest$Type extends MessageType<ListPaperPDFsRequest> {
    constructor() {
        super("pdf.ListPaperPDFsRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gt: 0 } } } },
            { no: 2, name: "offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<ListPaperPDFsRequest>): ListPaperPDFsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.offset = 0;
        if (value !== undefined)
            reflectionMergePartial<ListPaperPDFsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaperPDFsRequest): ListPaperPDFsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* uint32 offset */ 2:
                    message.offset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPaperPDFsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* uint32 offset = 2; */
        if (message.offset !== 0)
            writer.tag(2, WireType.Varint).uint32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.ListPaperPDFsRequest
 */
export const ListPaperPDFsRequest = new ListPaperPDFsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPaperPDFsResponse$Type extends MessageType<ListPaperPDFsResponse> {
    constructor() {
        super("pdf.ListPaperPDFsResponse", [
            { no: 1, name: "pdfs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PaperPDF }
        ]);
    }
    create(value?: PartialMessage<ListPaperPDFsResponse>): ListPaperPDFsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfs = [];
        if (value !== undefined)
            reflectionMergePartial<ListPaperPDFsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPaperPDFsResponse): ListPaperPDFsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pdf.PaperPDF pdfs */ 1:
                    message.pdfs.push(PaperPDF.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPaperPDFsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pdf.PaperPDF pdfs = 1; */
        for (let i = 0; i < message.pdfs.length; i++)
            PaperPDF.internalBinaryWrite(message.pdfs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.ListPaperPDFsResponse
 */
export const ListPaperPDFsResponse = new ListPaperPDFsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountPaperPDFsRequest$Type extends MessageType<CountPaperPDFsRequest> {
    constructor() {
        super("pdf.CountPaperPDFsRequest", []);
    }
    create(value?: PartialMessage<CountPaperPDFsRequest>): CountPaperPDFsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CountPaperPDFsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountPaperPDFsRequest): CountPaperPDFsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountPaperPDFsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.CountPaperPDFsRequest
 */
export const CountPaperPDFsRequest = new CountPaperPDFsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountPaperPDFsResponse$Type extends MessageType<CountPaperPDFsResponse> {
    constructor() {
        super("pdf.CountPaperPDFsResponse", [
            { no: 1, name: "count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CountPaperPDFsResponse>): CountPaperPDFsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<CountPaperPDFsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountPaperPDFsResponse): CountPaperPDFsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 count */ 1:
                    message.count = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountPaperPDFsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 count = 1; */
        if (message.count !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.CountPaperPDFsResponse
 */
export const CountPaperPDFsResponse = new CountPaperPDFsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperPDFByPaperIdRequest$Type extends MessageType<GetPaperPDFByPaperIdRequest> {
    constructor() {
        super("pdf.GetPaperPDFByPaperIdRequest", [
            { no: 1, name: "paper_id", kind: "scalar", localName: "paper_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperPDFByPaperIdRequest>): GetPaperPDFByPaperIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paper_id = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperPDFByPaperIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperPDFByPaperIdRequest): GetPaperPDFByPaperIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paper_id */ 1:
                    message.paper_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperPDFByPaperIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paper_id = 1; */
        if (message.paper_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paper_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPaperPDFByPaperIdRequest
 */
export const GetPaperPDFByPaperIdRequest = new GetPaperPDFByPaperIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperPDFByPaperIdResponse$Type extends MessageType<GetPaperPDFByPaperIdResponse> {
    constructor() {
        super("pdf.GetPaperPDFByPaperIdResponse", [
            { no: 1, name: "pdf", kind: "message", T: () => PaperPDF }
        ]);
    }
    create(value?: PartialMessage<GetPaperPDFByPaperIdResponse>): GetPaperPDFByPaperIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaperPDFByPaperIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperPDFByPaperIdResponse): GetPaperPDFByPaperIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pdf.PaperPDF pdf */ 1:
                    message.pdf = PaperPDF.internalBinaryRead(reader, reader.uint32(), options, message.pdf);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperPDFByPaperIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pdf.PaperPDF pdf = 1; */
        if (message.pdf)
            PaperPDF.internalBinaryWrite(message.pdf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPaperPDFByPaperIdResponse
 */
export const GetPaperPDFByPaperIdResponse = new GetPaperPDFByPaperIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperPDFByFileSHA256Request$Type extends MessageType<GetPaperPDFByFileSHA256Request> {
    constructor() {
        super("pdf.GetPaperPDFByFileSHA256Request", [
            { no: 1, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "32", maxLen: "32" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPaperPDFByFileSHA256Request>): GetPaperPDFByFileSHA256Request {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileSHA256 = "";
        if (value !== undefined)
            reflectionMergePartial<GetPaperPDFByFileSHA256Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperPDFByFileSHA256Request): GetPaperPDFByFileSHA256Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fileSHA256 */ 1:
                    message.fileSHA256 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperPDFByFileSHA256Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fileSHA256 = 1; */
        if (message.fileSHA256 !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fileSHA256);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPaperPDFByFileSHA256Request
 */
export const GetPaperPDFByFileSHA256Request = new GetPaperPDFByFileSHA256Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPaperPDFByFileSHA256Response$Type extends MessageType<GetPaperPDFByFileSHA256Response> {
    constructor() {
        super("pdf.GetPaperPDFByFileSHA256Response", [
            { no: 1, name: "pdf", kind: "message", T: () => PaperPDF }
        ]);
    }
    create(value?: PartialMessage<GetPaperPDFByFileSHA256Response>): GetPaperPDFByFileSHA256Response {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPaperPDFByFileSHA256Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPaperPDFByFileSHA256Response): GetPaperPDFByFileSHA256Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pdf.PaperPDF pdf */ 1:
                    message.pdf = PaperPDF.internalBinaryRead(reader, reader.uint32(), options, message.pdf);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPaperPDFByFileSHA256Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pdf.PaperPDF pdf = 1; */
        if (message.pdf)
            PaperPDF.internalBinaryWrite(message.pdf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPaperPDFByFileSHA256Response
 */
export const GetPaperPDFByFileSHA256Response = new GetPaperPDFByFileSHA256Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPdfStatusInfoRequest$Type extends MessageType<GetPdfStatusInfoRequest> {
    constructor() {
        super("pdf.GetPdfStatusInfoRequest", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "noteId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetPdfStatusInfoRequest>): GetPdfStatusInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        message.noteId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPdfStatusInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPdfStatusInfoRequest): GetPdfStatusInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                case /* string noteId */ 2:
                    message.noteId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPdfStatusInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        /* string noteId = 2; */
        if (message.noteId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.noteId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPdfStatusInfoRequest
 */
export const GetPdfStatusInfoRequest = new GetPdfStatusInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPdfStatusInfoResponse$Type extends MessageType<GetPdfStatusInfoResponse> {
    constructor() {
        super("pdf.GetPdfStatusInfoResponse", [
            { no: 1, name: "noteOpenAccessFlag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "hasPdfAccessFlag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pdfUserStatus", kind: "enum", T: () => ["pdf.UserStatusEnum", UserStatusEnum] },
            { no: 5, name: "noteUserStatus", kind: "enum", T: () => ["pdf.UserStatusEnum", UserStatusEnum] },
            { no: 6, name: "pdfUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "paperTitle", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "authPdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "pdfOwnerInfo", kind: "message", T: () => AuthorBean }
        ]);
    }
    create(value?: PartialMessage<GetPdfStatusInfoResponse>): GetPdfStatusInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noteOpenAccessFlag = false;
        message.hasPdfAccessFlag = false;
        message.docName = "";
        message.pdfUserStatus = 0;
        message.noteUserStatus = 0;
        message.pdfUrl = "";
        message.paperTitle = "";
        message.paperId = "";
        message.authPdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPdfStatusInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPdfStatusInfoResponse): GetPdfStatusInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool noteOpenAccessFlag */ 1:
                    message.noteOpenAccessFlag = reader.bool();
                    break;
                case /* bool hasPdfAccessFlag */ 2:
                    message.hasPdfAccessFlag = reader.bool();
                    break;
                case /* string docName */ 3:
                    message.docName = reader.string();
                    break;
                case /* pdf.UserStatusEnum pdfUserStatus */ 4:
                    message.pdfUserStatus = reader.int32();
                    break;
                case /* pdf.UserStatusEnum noteUserStatus */ 5:
                    message.noteUserStatus = reader.int32();
                    break;
                case /* string pdfUrl */ 6:
                    message.pdfUrl = reader.string();
                    break;
                case /* string paperTitle */ 7:
                    message.paperTitle = reader.string();
                    break;
                case /* string paperId */ 8:
                    message.paperId = reader.string();
                    break;
                case /* string authPdfId */ 9:
                    message.authPdfId = reader.string();
                    break;
                case /* user.AuthorBean pdfOwnerInfo */ 10:
                    message.pdfOwnerInfo = AuthorBean.internalBinaryRead(reader, reader.uint32(), options, message.pdfOwnerInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPdfStatusInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool noteOpenAccessFlag = 1; */
        if (message.noteOpenAccessFlag !== false)
            writer.tag(1, WireType.Varint).bool(message.noteOpenAccessFlag);
        /* bool hasPdfAccessFlag = 2; */
        if (message.hasPdfAccessFlag !== false)
            writer.tag(2, WireType.Varint).bool(message.hasPdfAccessFlag);
        /* string docName = 3; */
        if (message.docName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.docName);
        /* pdf.UserStatusEnum pdfUserStatus = 4; */
        if (message.pdfUserStatus !== 0)
            writer.tag(4, WireType.Varint).int32(message.pdfUserStatus);
        /* pdf.UserStatusEnum noteUserStatus = 5; */
        if (message.noteUserStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.noteUserStatus);
        /* string pdfUrl = 6; */
        if (message.pdfUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.pdfUrl);
        /* string paperTitle = 7; */
        if (message.paperTitle !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.paperTitle);
        /* string paperId = 8; */
        if (message.paperId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.paperId);
        /* string authPdfId = 9; */
        if (message.authPdfId !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.authPdfId);
        /* user.AuthorBean pdfOwnerInfo = 10; */
        if (message.pdfOwnerInfo)
            AuthorBean.internalBinaryWrite(message.pdfOwnerInfo, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPdfStatusInfoResponse
 */
export const GetPdfStatusInfoResponse = new GetPdfStatusInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPdfReaderSettingRequest$Type extends MessageType<GetPdfReaderSettingRequest> {
    constructor() {
        super("pdf.GetPdfReaderSettingRequest", [
            { no: 1, name: "clientType", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPdfReaderSettingRequest>): GetPdfReaderSettingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientType = 0;
        if (value !== undefined)
            reflectionMergePartial<GetPdfReaderSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPdfReaderSettingRequest): GetPdfReaderSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 clientType */ 1:
                    message.clientType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPdfReaderSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 clientType = 1; */
        if (message.clientType !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPdfReaderSettingRequest
 */
export const GetPdfReaderSettingRequest = new GetPdfReaderSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPdfReaderSettingResponse$Type extends MessageType<GetPdfReaderSettingResponse> {
    constructor() {
        super("pdf.GetPdfReaderSettingResponse", [
            { no: 1, name: "setting", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPdfReaderSettingResponse>): GetPdfReaderSettingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setting = "";
        if (value !== undefined)
            reflectionMergePartial<GetPdfReaderSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPdfReaderSettingResponse): GetPdfReaderSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string setting */ 1:
                    message.setting = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPdfReaderSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string setting = 1; */
        if (message.setting !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.setting);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetPdfReaderSettingResponse
 */
export const GetPdfReaderSettingResponse = new GetPdfReaderSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordPdfReaderSettingRequest$Type extends MessageType<RecordPdfReaderSettingRequest> {
    constructor() {
        super("pdf.RecordPdfReaderSettingRequest", [
            { no: 1, name: "clientType", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "setting", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RecordPdfReaderSettingRequest>): RecordPdfReaderSettingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientType = 0;
        message.setting = "";
        if (value !== undefined)
            reflectionMergePartial<RecordPdfReaderSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordPdfReaderSettingRequest): RecordPdfReaderSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 clientType */ 1:
                    message.clientType = reader.int32();
                    break;
                case /* string setting */ 2:
                    message.setting = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordPdfReaderSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 clientType = 1; */
        if (message.clientType !== 0)
            writer.tag(1, WireType.Varint).int32(message.clientType);
        /* string setting = 2; */
        if (message.setting !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.setting);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.RecordPdfReaderSettingRequest
 */
export const RecordPdfReaderSettingRequest = new RecordPdfReaderSettingRequest$Type();
