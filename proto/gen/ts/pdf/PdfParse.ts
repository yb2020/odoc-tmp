// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/pdf/PdfParse.proto" (package "pdf", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PageResponse } from "../common/Base";
import { PageRequest } from "../common/Base";
/**
 * 用来描述PDF元素的位置
 *
 * @generated from protobuf message pdf.PdfBBox
 */
export interface PdfBBox {
    /**
     * @generated from protobuf field: float x0 = 1
     */
    x0: number;
    /**
     * @generated from protobuf field: float y0 = 2
     */
    y0: number;
    /**
     * @generated from protobuf field: float x1 = 3
     */
    x1: number;
    /**
     * @generated from protobuf field: float y1 = 4
     */
    y1: number;
    /**
     * @generated from protobuf field: float originHeight = 5
     */
    originHeight: number;
    /**
     * @generated from protobuf field: float originWidth = 6
     */
    originWidth: number;
}
/**
 * *
 * 【PDF解析】提取取图表信息
 * url: /pdfApi/parser/getFiguresAndTables
 * method: POST
 *
 * 请求
 *
 * @generated from protobuf message pdf.GetFiguresAndTablesListRequest
 */
export interface GetFiguresAndTablesListRequest {
    /**
     * @generated from protobuf field: common.PageRequest pageReq = 1
     */
    pageReq?: PageRequest;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
}
/**
 * 请求
 *
 * @generated from protobuf message pdf.GetFiguresAndTablesRequest
 */
export interface GetFiguresAndTablesRequest {
    /**
     * @generated from protobuf field: common.PageRequest pageReq = 1
     */
    pageReq?: PageRequest;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * @generated from protobuf field: string paperId = 3
     */
    paperId: string;
}
/**
 * message GetFiguresAndTablesListRequest { // 请求
 *    common.PageRequest pageReq = 1;
 *    uint64 pdfId = 2[(common.notNull) = false];
 *    uint64 paperId = 3[(common.notNull) = false];
 * }
 *
 * @generated from protobuf message pdf.PdfFigureAndTableInfo
 */
export interface PdfFigureAndTableInfo {
    /**
     * @generated from protobuf field: int32 pageNum = 1
     */
    pageNum: number;
    /**
     * @generated from protobuf field: string desc = 2
     */
    desc: string;
    /**
     * @generated from protobuf field: string url = 3
     */
    url: string;
    /**
     * @generated from protobuf field: pdf.PdfBBox bbox = 4
     */
    bbox?: PdfBBox;
    /**
     * @generated from protobuf field: string refIdx = 5
     */
    refIdx: string;
}
/**
 * 响应
 *
 * @generated from protobuf message pdf.GetFiguresAndTablesListResponse
 */
export interface GetFiguresAndTablesListResponse {
    /**
     * @generated from protobuf field: common.PageResponse pageResp = 1
     */
    pageResp?: PageResponse;
    /**
     * @generated from protobuf field: repeated pdf.PdfFigureAndTableInfo figureAndTableList = 2
     */
    figureAndTableList: PdfFigureAndTableInfo[];
    /**
     * @generated from protobuf field: bool needFetch = 3
     */
    needFetch: boolean; // 提示重试
}
/**
 * 请求
 *
 * @generated from protobuf message pdf.GetReferenceRequest
 */
export interface GetReferenceRequest {
    /**
     * @generated from protobuf field: common.PageRequest pageReq = 1
     */
    pageReq?: PageRequest;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * @generated from protobuf field: pdf.ReferenceSortType sortType = 3
     */
    sortType: ReferenceSortType;
    /**
     * @generated from protobuf field: string paperId = 4
     */
    paperId: string;
    /**
     * @generated from protobuf field: optional bool filterNoTitle = 5
     */
    filterNoTitle?: boolean;
}
/**
 * @generated from protobuf message pdf.ReferenceInfo
 */
export interface ReferenceInfo {
    /**
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string;
    /**
     * @generated from protobuf field: string title = 2
     */
    title: string;
    /**
     * @generated from protobuf field: int32 pageNum = 3
     */
    pageNum: number;
    /**
     * @generated from protobuf field: pdf.PdfBBox bbox = 4
     */
    bbox?: PdfBBox;
    /**
     * @generated from protobuf field: string refIdx = 5
     */
    refIdx: string;
    /**
     * @generated from protobuf field: int32 citationCount = 6
     */
    citationCount: number;
    /**
     * @generated from protobuf field: uint64 publishDate = 7
     */
    publishDate: bigint;
    /**
     * @generated from protobuf field: string searchKey = 8
     */
    searchKey: string;
    /**
     * @generated from protobuf field: pdf.PaperMetaExtend paperMetaExtend = 9
     */
    paperMetaExtend?: PaperMetaExtend;
}
/**
 * 响应
 *
 * @generated from protobuf message pdf.GetReferenceResponse
 */
export interface GetReferenceResponse {
    /**
     * @generated from protobuf field: common.PageResponse pageResp = 1
     */
    pageResp?: PageResponse;
    /**
     * @generated from protobuf field: repeated pdf.ReferenceInfo referenceInfoList = 2
     */
    referenceInfoList: ReferenceInfo[];
    /**
     * @generated from protobuf field: int32 referenceCount = 3
     */
    referenceCount: number;
    /**
     * @generated from protobuf field: int32 citationCount = 4
     */
    citationCount: number;
    /**
     * @generated from protobuf field: bool needFetch = 5
     */
    needFetch: boolean; // 提示重试
}
/**
 * @generated from protobuf message pdf.PaperMetaExtend
 */
export interface PaperMetaExtend {
    /**
     * 没有就是0
     *
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
    /**
     * @generated from protobuf field: repeated pdf.Author authorList = 2
     */
    authorList: Author[];
    /**
     * @generated from protobuf field: repeated string venueTags = 3
     */
    venueTags: string[];
    /**
     * @generated from protobuf field: string publishDate = 4
     */
    publishDate: string;
    /**
     * @generated from protobuf field: repeated string venues = 5
     */
    venues: string[];
    /**
     * @generated from protobuf field: uint32 noteCount = 6
     */
    noteCount: number;
    /**
     * @generated from protobuf field: uint32 citationCount = 7
     */
    citationCount: number;
    /**
     * @generated from protobuf field: string summary = 8
     */
    summary: string;
    /**
     * @generated from protobuf field: string title = 9
     */
    title: string;
    /**
     * @generated from protobuf field: string paperId = 10
     */
    paperId: string;
}
/**
 * @generated from protobuf message pdf.Author
 */
export interface Author {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * *
 * 【PDF解析】提取被引用信息
 * url: /pdfApi/parser/getCitation
 * method: POST
 *
 * 请求
 *
 * @generated from protobuf message pdf.GetCitationRequest
 */
export interface GetCitationRequest {
    /**
     * @generated from protobuf field: common.PageRequest pageReq = 1
     */
    pageReq?: PageRequest;
    /**
     * @generated from protobuf field: string paperId = 2
     */
    paperId: string;
    /**
     * @generated from protobuf field: pdf.ReferenceSortType sortType = 3
     */
    sortType: ReferenceSortType;
}
/**
 * @generated from protobuf message pdf.CitationInfo
 */
export interface CitationInfo {
    /**
     * @generated from protobuf field: string paperId = 1
     */
    paperId: string;
    /**
     * @generated from protobuf field: string title = 2
     */
    title: string;
    /**
     * @generated from protobuf field: string citaIdx = 3
     */
    citaIdx: string;
    /**
     * @generated from protobuf field: int32 citationCount = 4
     */
    citationCount: number;
    /**
     * @generated from protobuf field: uint64 publishDate = 5
     */
    publishDate: bigint;
    /**
     * @generated from protobuf field: pdf.PaperMetaExtend paperMetaExtend = 6
     */
    paperMetaExtend?: PaperMetaExtend;
}
/**
 * 响应
 *
 * @generated from protobuf message pdf.GetCitationResponse
 */
export interface GetCitationResponse {
    /**
     * @generated from protobuf field: common.PageResponse pageResp = 1
     */
    pageResp?: PageResponse;
    /**
     * @generated from protobuf field: repeated pdf.CitationInfo citationInfoList = 2
     */
    citationInfoList: CitationInfo[];
    /**
     * @generated from protobuf field: int32 referenceCount = 3
     */
    referenceCount: number;
    /**
     * @generated from protobuf field: int32 citationCount = 4
     */
    citationCount: number;
    /**
     * @generated from protobuf field: bool needFetch = 5
     */
    needFetch: boolean; // 提示重试
}
/**
 * *
 * 【PDF解析】提取参考标签
 * url: /pdfApi/parser/getReferenceMarkers
 * method: POST
 *
 * 请求
 *
 * @generated from protobuf message pdf.GetReferenceMarkersRequest
 */
export interface GetReferenceMarkersRequest {
    /**
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
}
/**
 * @generated from protobuf message pdf.ReferenceMarker
 */
export interface ReferenceMarker {
    /**
     * @generated from protobuf field: string refIdx = 1
     */
    refIdx: string;
    /**
     * @generated from protobuf field: pdf.PdfBBox bbox = 2
     */
    bbox?: PdfBBox;
    /**
     * @generated from protobuf field: string paperId = 3
     */
    paperId: string;
    /**
     * @generated from protobuf field: string refContent = 4
     */
    refContent: string;
    /**
     * @generated from protobuf field: int32 pageNum = 5
     */
    pageNum: number;
    /**
     * @generated from protobuf field: string refRaw = 6
     */
    refRaw: string;
}
/**
 * @generated from protobuf message pdf.FigureAndTableReferenceMarker
 */
export interface FigureAndTableReferenceMarker {
    /**
     * @generated from protobuf field: pdf.PdfBBox bbox = 1
     */
    bbox?: PdfBBox;
    /**
     * @generated from protobuf field: int32 pageNum = 2
     */
    pageNum: number;
    /**
     * @generated from protobuf field: string refContent = 3
     */
    refContent: string;
    /**
     * @generated from protobuf field: string refIdx = 4
     */
    refIdx: string;
}
/**
 * 响应
 *
 * @generated from protobuf message pdf.GetReferenceMarkersResponse
 */
export interface GetReferenceMarkersResponse {
    /**
     * @generated from protobuf field: repeated pdf.ReferenceMarker markers = 1
     */
    markers: ReferenceMarker[];
    /**
     * @generated from protobuf field: bool needFetch = 2
     */
    needFetch: boolean; // 提示重试
    /**
     * @generated from protobuf field: repeated pdf.FigureAndTableReferenceMarker figureAndTableMarkers = 3
     */
    figureAndTableMarkers: FigureAndTableReferenceMarker[];
}
/**
 * *
 * cv解析PDF
 *
 * 请求
 *
 * @generated from protobuf message pdf.AsyncPdfCvParseRequest
 */
export interface AsyncPdfCvParseRequest {
    /**
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * @generated from protobuf field: string fileSHA256 = 2
     */
    fileSHA256: string;
    /**
     * @generated from protobuf field: bool fulltext = 3
     */
    fulltext: boolean;
}
/**
 * 响应
 *
 * @generated from protobuf message pdf.AsyncPdfCvParseResponse
 */
export interface AsyncPdfCvParseResponse {
    /**
     * @generated from protobuf field: uint64 code = 1
     */
    code: bigint;
    /**
     * @generated from protobuf field: repeated pdf.PdfFigureAndTableInfo data = 2
     */
    data: PdfFigureAndTableInfo[];
    /**
     * @generated from protobuf field: pdf.ParseStatus procStatus = 3
     */
    procStatus: ParseStatus;
}
/**
 * *
 * 【PDF解析】提取参考信息
 * url: /pdfApi/parser/getCatalogue
 * method: POST
 *
 * @generated from protobuf message pdf.GetCatalogueRequest
 */
export interface GetCatalogueRequest {
    /**
     * @generated from protobuf field: string pdfId = 1
     */
    pdfId: string;
}
/**
 * @generated from protobuf message pdf.PdfCatalogueInfo
 */
export interface PdfCatalogueInfo {
    /**
     * @generated from protobuf field: string title = 1
     */
    title: string;
    /**
     * @generated from protobuf field: int32 pageNum = 2
     */
    pageNum: number;
    /**
     * @generated from protobuf field: repeated pdf.PdfCatalogueInfo child = 3
     */
    child: PdfCatalogueInfo[];
    /**
     * @generated from protobuf field: pdf.PdfBBox bbox = 4
     */
    bbox?: PdfBBox;
}
/**
 * @generated from protobuf message pdf.GetCatalogueResponse
 */
export interface GetCatalogueResponse {
    /**
     * @generated from protobuf field: bool needFetch = 1
     */
    needFetch: boolean;
    /**
     * @generated from protobuf field: pdf.PdfCatalogueInfo pdfCatalogue = 2
     */
    pdfCatalogue?: PdfCatalogueInfo;
}
/**
 * @generated from protobuf message pdf.PdfRefRematchReq
 */
export interface PdfRefRematchReq {
    /**
     * @generated from protobuf field: repeated string rawStrings = 1
     */
    rawStrings: string[];
}
/**
 * @generated from protobuf message pdf.PdfRefRematchResp
 */
export interface PdfRefRematchResp {
    /**
     * @generated from protobuf field: int32 statusCode = 1
     */
    statusCode: number;
    /**
     * @generated from protobuf field: string errMsg = 2
     */
    errMsg: string;
    /**
     * @generated from protobuf field: repeated string paperids = 3
     */
    paperids: string[];
}
/**
 * *
 * 【PDF解析】提取参考信息
 * url: /pdfApi/parser/getReference
 * method: POST
 *
 * @generated from protobuf enum pdf.ReferenceSortType
 */
export enum ReferenceSortType {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * @generated from protobuf enum value: CITATION = 1;
     */
    CITATION = 1,
    /**
     * @generated from protobuf enum value: PUBLISH_DATE = 2;
     */
    PUBLISH_DATE = 2
}
/**
 * @generated from protobuf enum pdf.ParseStatus
 */
export enum ParseStatus {
    /**
     * @generated from protobuf enum value: PARSE_UNKNOW = 0;
     */
    PARSE_UNKNOW = 0,
    /**
     * @generated from protobuf enum value: PARSE_RUNNING = 1;
     */
    PARSE_RUNNING = 1,
    /**
     * @generated from protobuf enum value: PARSE_FINISH = 2;
     */
    PARSE_FINISH = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class PdfBBox$Type extends MessageType<PdfBBox> {
    constructor() {
        super("pdf.PdfBBox", [
            { no: 1, name: "x0", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y0", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x1", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y1", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "originHeight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "originWidth", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PdfBBox>): PdfBBox {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x0 = 0;
        message.y0 = 0;
        message.x1 = 0;
        message.y1 = 0;
        message.originHeight = 0;
        message.originWidth = 0;
        if (value !== undefined)
            reflectionMergePartial<PdfBBox>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PdfBBox): PdfBBox {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x0 */ 1:
                    message.x0 = reader.float();
                    break;
                case /* float y0 */ 2:
                    message.y0 = reader.float();
                    break;
                case /* float x1 */ 3:
                    message.x1 = reader.float();
                    break;
                case /* float y1 */ 4:
                    message.y1 = reader.float();
                    break;
                case /* float originHeight */ 5:
                    message.originHeight = reader.float();
                    break;
                case /* float originWidth */ 6:
                    message.originWidth = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PdfBBox, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x0 = 1; */
        if (message.x0 !== 0)
            writer.tag(1, WireType.Bit32).float(message.x0);
        /* float y0 = 2; */
        if (message.y0 !== 0)
            writer.tag(2, WireType.Bit32).float(message.y0);
        /* float x1 = 3; */
        if (message.x1 !== 0)
            writer.tag(3, WireType.Bit32).float(message.x1);
        /* float y1 = 4; */
        if (message.y1 !== 0)
            writer.tag(4, WireType.Bit32).float(message.y1);
        /* float originHeight = 5; */
        if (message.originHeight !== 0)
            writer.tag(5, WireType.Bit32).float(message.originHeight);
        /* float originWidth = 6; */
        if (message.originWidth !== 0)
            writer.tag(6, WireType.Bit32).float(message.originWidth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.PdfBBox
 */
export const PdfBBox = new PdfBBox$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFiguresAndTablesListRequest$Type extends MessageType<GetFiguresAndTablesListRequest> {
    constructor() {
        super("pdf.GetFiguresAndTablesListRequest", [
            { no: 1, name: "pageReq", kind: "message", T: () => PageRequest },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetFiguresAndTablesListRequest>): GetFiguresAndTablesListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetFiguresAndTablesListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFiguresAndTablesListRequest): GetFiguresAndTablesListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.PageRequest pageReq */ 1:
                    message.pageReq = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pageReq);
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFiguresAndTablesListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.PageRequest pageReq = 1; */
        if (message.pageReq)
            PageRequest.internalBinaryWrite(message.pageReq, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetFiguresAndTablesListRequest
 */
export const GetFiguresAndTablesListRequest = new GetFiguresAndTablesListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFiguresAndTablesRequest$Type extends MessageType<GetFiguresAndTablesRequest> {
    constructor() {
        super("pdf.GetFiguresAndTablesRequest", [
            { no: 1, name: "pageReq", kind: "message", T: () => PageRequest },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetFiguresAndTablesRequest>): GetFiguresAndTablesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        message.paperId = "";
        if (value !== undefined)
            reflectionMergePartial<GetFiguresAndTablesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFiguresAndTablesRequest): GetFiguresAndTablesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.PageRequest pageReq */ 1:
                    message.pageReq = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pageReq);
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* string paperId */ 3:
                    message.paperId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFiguresAndTablesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.PageRequest pageReq = 1; */
        if (message.pageReq)
            PageRequest.internalBinaryWrite(message.pageReq, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* string paperId = 3; */
        if (message.paperId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.paperId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetFiguresAndTablesRequest
 */
export const GetFiguresAndTablesRequest = new GetFiguresAndTablesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PdfFigureAndTableInfo$Type extends MessageType<PdfFigureAndTableInfo> {
    constructor() {
        super("pdf.PdfFigureAndTableInfo", [
            { no: 1, name: "pageNum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "desc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "bbox", kind: "message", T: () => PdfBBox },
            { no: 5, name: "refIdx", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PdfFigureAndTableInfo>): PdfFigureAndTableInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pageNum = 0;
        message.desc = "";
        message.url = "";
        message.refIdx = "";
        if (value !== undefined)
            reflectionMergePartial<PdfFigureAndTableInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PdfFigureAndTableInfo): PdfFigureAndTableInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pageNum */ 1:
                    message.pageNum = reader.int32();
                    break;
                case /* string desc */ 2:
                    message.desc = reader.string();
                    break;
                case /* string url */ 3:
                    message.url = reader.string();
                    break;
                case /* pdf.PdfBBox bbox */ 4:
                    message.bbox = PdfBBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string refIdx */ 5:
                    message.refIdx = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PdfFigureAndTableInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pageNum = 1; */
        if (message.pageNum !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageNum);
        /* string desc = 2; */
        if (message.desc !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.desc);
        /* string url = 3; */
        if (message.url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* pdf.PdfBBox bbox = 4; */
        if (message.bbox)
            PdfBBox.internalBinaryWrite(message.bbox, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string refIdx = 5; */
        if (message.refIdx !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.refIdx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.PdfFigureAndTableInfo
 */
export const PdfFigureAndTableInfo = new PdfFigureAndTableInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFiguresAndTablesListResponse$Type extends MessageType<GetFiguresAndTablesListResponse> {
    constructor() {
        super("pdf.GetFiguresAndTablesListResponse", [
            { no: 1, name: "pageResp", kind: "message", T: () => PageResponse },
            { no: 2, name: "figureAndTableList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PdfFigureAndTableInfo },
            { no: 3, name: "needFetch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetFiguresAndTablesListResponse>): GetFiguresAndTablesListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.figureAndTableList = [];
        message.needFetch = false;
        if (value !== undefined)
            reflectionMergePartial<GetFiguresAndTablesListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFiguresAndTablesListResponse): GetFiguresAndTablesListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.PageResponse pageResp */ 1:
                    message.pageResp = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pageResp);
                    break;
                case /* repeated pdf.PdfFigureAndTableInfo figureAndTableList */ 2:
                    message.figureAndTableList.push(PdfFigureAndTableInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool needFetch */ 3:
                    message.needFetch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFiguresAndTablesListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.PageResponse pageResp = 1; */
        if (message.pageResp)
            PageResponse.internalBinaryWrite(message.pageResp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated pdf.PdfFigureAndTableInfo figureAndTableList = 2; */
        for (let i = 0; i < message.figureAndTableList.length; i++)
            PdfFigureAndTableInfo.internalBinaryWrite(message.figureAndTableList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool needFetch = 3; */
        if (message.needFetch !== false)
            writer.tag(3, WireType.Varint).bool(message.needFetch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetFiguresAndTablesListResponse
 */
export const GetFiguresAndTablesListResponse = new GetFiguresAndTablesListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReferenceRequest$Type extends MessageType<GetReferenceRequest> {
    constructor() {
        super("pdf.GetReferenceRequest", [
            { no: 1, name: "pageReq", kind: "message", T: () => PageRequest },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sortType", kind: "enum", T: () => ["pdf.ReferenceSortType", ReferenceSortType] },
            { no: 4, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "filterNoTitle", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetReferenceRequest>): GetReferenceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        message.sortType = 0;
        message.paperId = "";
        if (value !== undefined)
            reflectionMergePartial<GetReferenceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReferenceRequest): GetReferenceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.PageRequest pageReq */ 1:
                    message.pageReq = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pageReq);
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* pdf.ReferenceSortType sortType */ 3:
                    message.sortType = reader.int32();
                    break;
                case /* string paperId */ 4:
                    message.paperId = reader.string();
                    break;
                case /* optional bool filterNoTitle */ 5:
                    message.filterNoTitle = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReferenceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.PageRequest pageReq = 1; */
        if (message.pageReq)
            PageRequest.internalBinaryWrite(message.pageReq, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* pdf.ReferenceSortType sortType = 3; */
        if (message.sortType !== 0)
            writer.tag(3, WireType.Varint).int32(message.sortType);
        /* string paperId = 4; */
        if (message.paperId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.paperId);
        /* optional bool filterNoTitle = 5; */
        if (message.filterNoTitle !== undefined)
            writer.tag(5, WireType.Varint).bool(message.filterNoTitle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetReferenceRequest
 */
export const GetReferenceRequest = new GetReferenceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceInfo$Type extends MessageType<ReferenceInfo> {
    constructor() {
        super("pdf.ReferenceInfo", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pageNum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "bbox", kind: "message", T: () => PdfBBox },
            { no: 5, name: "refIdx", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "citationCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "publishDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "searchKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "paperMetaExtend", kind: "message", T: () => PaperMetaExtend }
        ]);
    }
    create(value?: PartialMessage<ReferenceInfo>): ReferenceInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        message.title = "";
        message.pageNum = 0;
        message.refIdx = "";
        message.citationCount = 0;
        message.publishDate = 0n;
        message.searchKey = "";
        if (value !== undefined)
            reflectionMergePartial<ReferenceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReferenceInfo): ReferenceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* int32 pageNum */ 3:
                    message.pageNum = reader.int32();
                    break;
                case /* pdf.PdfBBox bbox */ 4:
                    message.bbox = PdfBBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string refIdx */ 5:
                    message.refIdx = reader.string();
                    break;
                case /* int32 citationCount */ 6:
                    message.citationCount = reader.int32();
                    break;
                case /* uint64 publishDate */ 7:
                    message.publishDate = reader.uint64().toBigInt();
                    break;
                case /* string searchKey */ 8:
                    message.searchKey = reader.string();
                    break;
                case /* pdf.PaperMetaExtend paperMetaExtend */ 9:
                    message.paperMetaExtend = PaperMetaExtend.internalBinaryRead(reader, reader.uint32(), options, message.paperMetaExtend);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReferenceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* int32 pageNum = 3; */
        if (message.pageNum !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageNum);
        /* pdf.PdfBBox bbox = 4; */
        if (message.bbox)
            PdfBBox.internalBinaryWrite(message.bbox, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string refIdx = 5; */
        if (message.refIdx !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.refIdx);
        /* int32 citationCount = 6; */
        if (message.citationCount !== 0)
            writer.tag(6, WireType.Varint).int32(message.citationCount);
        /* uint64 publishDate = 7; */
        if (message.publishDate !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.publishDate);
        /* string searchKey = 8; */
        if (message.searchKey !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.searchKey);
        /* pdf.PaperMetaExtend paperMetaExtend = 9; */
        if (message.paperMetaExtend)
            PaperMetaExtend.internalBinaryWrite(message.paperMetaExtend, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.ReferenceInfo
 */
export const ReferenceInfo = new ReferenceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReferenceResponse$Type extends MessageType<GetReferenceResponse> {
    constructor() {
        super("pdf.GetReferenceResponse", [
            { no: 1, name: "pageResp", kind: "message", T: () => PageResponse },
            { no: 2, name: "referenceInfoList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ReferenceInfo },
            { no: 3, name: "referenceCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "citationCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "needFetch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetReferenceResponse>): GetReferenceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.referenceInfoList = [];
        message.referenceCount = 0;
        message.citationCount = 0;
        message.needFetch = false;
        if (value !== undefined)
            reflectionMergePartial<GetReferenceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReferenceResponse): GetReferenceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.PageResponse pageResp */ 1:
                    message.pageResp = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pageResp);
                    break;
                case /* repeated pdf.ReferenceInfo referenceInfoList */ 2:
                    message.referenceInfoList.push(ReferenceInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 referenceCount */ 3:
                    message.referenceCount = reader.int32();
                    break;
                case /* int32 citationCount */ 4:
                    message.citationCount = reader.int32();
                    break;
                case /* bool needFetch */ 5:
                    message.needFetch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReferenceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.PageResponse pageResp = 1; */
        if (message.pageResp)
            PageResponse.internalBinaryWrite(message.pageResp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated pdf.ReferenceInfo referenceInfoList = 2; */
        for (let i = 0; i < message.referenceInfoList.length; i++)
            ReferenceInfo.internalBinaryWrite(message.referenceInfoList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 referenceCount = 3; */
        if (message.referenceCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.referenceCount);
        /* int32 citationCount = 4; */
        if (message.citationCount !== 0)
            writer.tag(4, WireType.Varint).int32(message.citationCount);
        /* bool needFetch = 5; */
        if (message.needFetch !== false)
            writer.tag(5, WireType.Varint).bool(message.needFetch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetReferenceResponse
 */
export const GetReferenceResponse = new GetReferenceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaperMetaExtend$Type extends MessageType<PaperMetaExtend> {
    constructor() {
        super("pdf.PaperMetaExtend", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authorList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Author },
            { no: 3, name: "venueTags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "publishDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "venues", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "noteCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "citationCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PaperMetaExtend>): PaperMetaExtend {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        message.authorList = [];
        message.venueTags = [];
        message.publishDate = "";
        message.venues = [];
        message.noteCount = 0;
        message.citationCount = 0;
        message.summary = "";
        message.title = "";
        message.paperId = "";
        if (value !== undefined)
            reflectionMergePartial<PaperMetaExtend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PaperMetaExtend): PaperMetaExtend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                case /* repeated pdf.Author authorList */ 2:
                    message.authorList.push(Author.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string venueTags */ 3:
                    message.venueTags.push(reader.string());
                    break;
                case /* string publishDate */ 4:
                    message.publishDate = reader.string();
                    break;
                case /* repeated string venues */ 5:
                    message.venues.push(reader.string());
                    break;
                case /* uint32 noteCount */ 6:
                    message.noteCount = reader.uint32();
                    break;
                case /* uint32 citationCount */ 7:
                    message.citationCount = reader.uint32();
                    break;
                case /* string summary */ 8:
                    message.summary = reader.string();
                    break;
                case /* string title */ 9:
                    message.title = reader.string();
                    break;
                case /* string paperId */ 10:
                    message.paperId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PaperMetaExtend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        /* repeated pdf.Author authorList = 2; */
        for (let i = 0; i < message.authorList.length; i++)
            Author.internalBinaryWrite(message.authorList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string venueTags = 3; */
        for (let i = 0; i < message.venueTags.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.venueTags[i]);
        /* string publishDate = 4; */
        if (message.publishDate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.publishDate);
        /* repeated string venues = 5; */
        for (let i = 0; i < message.venues.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.venues[i]);
        /* uint32 noteCount = 6; */
        if (message.noteCount !== 0)
            writer.tag(6, WireType.Varint).uint32(message.noteCount);
        /* uint32 citationCount = 7; */
        if (message.citationCount !== 0)
            writer.tag(7, WireType.Varint).uint32(message.citationCount);
        /* string summary = 8; */
        if (message.summary !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.summary);
        /* string title = 9; */
        if (message.title !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.title);
        /* string paperId = 10; */
        if (message.paperId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.paperId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.PaperMetaExtend
 */
export const PaperMetaExtend = new PaperMetaExtend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Author$Type extends MessageType<Author> {
    constructor() {
        super("pdf.Author", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Author>): Author {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Author>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Author): Author {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Author, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.Author
 */
export const Author = new Author$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCitationRequest$Type extends MessageType<GetCitationRequest> {
    constructor() {
        super("pdf.GetCitationRequest", [
            { no: 1, name: "pageReq", kind: "message", T: () => PageRequest },
            { no: 2, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sortType", kind: "enum", T: () => ["pdf.ReferenceSortType", ReferenceSortType] }
        ]);
    }
    create(value?: PartialMessage<GetCitationRequest>): GetCitationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        message.sortType = 0;
        if (value !== undefined)
            reflectionMergePartial<GetCitationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCitationRequest): GetCitationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.PageRequest pageReq */ 1:
                    message.pageReq = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pageReq);
                    break;
                case /* string paperId */ 2:
                    message.paperId = reader.string();
                    break;
                case /* pdf.ReferenceSortType sortType */ 3:
                    message.sortType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCitationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.PageRequest pageReq = 1; */
        if (message.pageReq)
            PageRequest.internalBinaryWrite(message.pageReq, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string paperId = 2; */
        if (message.paperId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paperId);
        /* pdf.ReferenceSortType sortType = 3; */
        if (message.sortType !== 0)
            writer.tag(3, WireType.Varint).int32(message.sortType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetCitationRequest
 */
export const GetCitationRequest = new GetCitationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CitationInfo$Type extends MessageType<CitationInfo> {
    constructor() {
        super("pdf.CitationInfo", [
            { no: 1, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "citaIdx", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "citationCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "publishDate", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "paperMetaExtend", kind: "message", T: () => PaperMetaExtend }
        ]);
    }
    create(value?: PartialMessage<CitationInfo>): CitationInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.paperId = "";
        message.title = "";
        message.citaIdx = "";
        message.citationCount = 0;
        message.publishDate = 0n;
        if (value !== undefined)
            reflectionMergePartial<CitationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CitationInfo): CitationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string paperId */ 1:
                    message.paperId = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string citaIdx */ 3:
                    message.citaIdx = reader.string();
                    break;
                case /* int32 citationCount */ 4:
                    message.citationCount = reader.int32();
                    break;
                case /* uint64 publishDate */ 5:
                    message.publishDate = reader.uint64().toBigInt();
                    break;
                case /* pdf.PaperMetaExtend paperMetaExtend */ 6:
                    message.paperMetaExtend = PaperMetaExtend.internalBinaryRead(reader, reader.uint32(), options, message.paperMetaExtend);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CitationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string paperId = 1; */
        if (message.paperId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.paperId);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string citaIdx = 3; */
        if (message.citaIdx !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.citaIdx);
        /* int32 citationCount = 4; */
        if (message.citationCount !== 0)
            writer.tag(4, WireType.Varint).int32(message.citationCount);
        /* uint64 publishDate = 5; */
        if (message.publishDate !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.publishDate);
        /* pdf.PaperMetaExtend paperMetaExtend = 6; */
        if (message.paperMetaExtend)
            PaperMetaExtend.internalBinaryWrite(message.paperMetaExtend, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.CitationInfo
 */
export const CitationInfo = new CitationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCitationResponse$Type extends MessageType<GetCitationResponse> {
    constructor() {
        super("pdf.GetCitationResponse", [
            { no: 1, name: "pageResp", kind: "message", T: () => PageResponse },
            { no: 2, name: "citationInfoList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CitationInfo },
            { no: 3, name: "referenceCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "citationCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "needFetch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetCitationResponse>): GetCitationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.citationInfoList = [];
        message.referenceCount = 0;
        message.citationCount = 0;
        message.needFetch = false;
        if (value !== undefined)
            reflectionMergePartial<GetCitationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCitationResponse): GetCitationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.PageResponse pageResp */ 1:
                    message.pageResp = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pageResp);
                    break;
                case /* repeated pdf.CitationInfo citationInfoList */ 2:
                    message.citationInfoList.push(CitationInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 referenceCount */ 3:
                    message.referenceCount = reader.int32();
                    break;
                case /* int32 citationCount */ 4:
                    message.citationCount = reader.int32();
                    break;
                case /* bool needFetch */ 5:
                    message.needFetch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCitationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.PageResponse pageResp = 1; */
        if (message.pageResp)
            PageResponse.internalBinaryWrite(message.pageResp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated pdf.CitationInfo citationInfoList = 2; */
        for (let i = 0; i < message.citationInfoList.length; i++)
            CitationInfo.internalBinaryWrite(message.citationInfoList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 referenceCount = 3; */
        if (message.referenceCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.referenceCount);
        /* int32 citationCount = 4; */
        if (message.citationCount !== 0)
            writer.tag(4, WireType.Varint).int32(message.citationCount);
        /* bool needFetch = 5; */
        if (message.needFetch !== false)
            writer.tag(5, WireType.Varint).bool(message.needFetch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetCitationResponse
 */
export const GetCitationResponse = new GetCitationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReferenceMarkersRequest$Type extends MessageType<GetReferenceMarkersRequest> {
    constructor() {
        super("pdf.GetReferenceMarkersRequest", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetReferenceMarkersRequest>): GetReferenceMarkersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetReferenceMarkersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReferenceMarkersRequest): GetReferenceMarkersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReferenceMarkersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetReferenceMarkersRequest
 */
export const GetReferenceMarkersRequest = new GetReferenceMarkersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceMarker$Type extends MessageType<ReferenceMarker> {
    constructor() {
        super("pdf.ReferenceMarker", [
            { no: 1, name: "refIdx", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bbox", kind: "message", T: () => PdfBBox },
            { no: 3, name: "paperId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "refContent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "pageNum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "refRaw", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReferenceMarker>): ReferenceMarker {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.refIdx = "";
        message.paperId = "";
        message.refContent = "";
        message.pageNum = 0;
        message.refRaw = "";
        if (value !== undefined)
            reflectionMergePartial<ReferenceMarker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReferenceMarker): ReferenceMarker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string refIdx */ 1:
                    message.refIdx = reader.string();
                    break;
                case /* pdf.PdfBBox bbox */ 2:
                    message.bbox = PdfBBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* string paperId */ 3:
                    message.paperId = reader.string();
                    break;
                case /* string refContent */ 4:
                    message.refContent = reader.string();
                    break;
                case /* int32 pageNum */ 5:
                    message.pageNum = reader.int32();
                    break;
                case /* string refRaw */ 6:
                    message.refRaw = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReferenceMarker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string refIdx = 1; */
        if (message.refIdx !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.refIdx);
        /* pdf.PdfBBox bbox = 2; */
        if (message.bbox)
            PdfBBox.internalBinaryWrite(message.bbox, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string paperId = 3; */
        if (message.paperId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.paperId);
        /* string refContent = 4; */
        if (message.refContent !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.refContent);
        /* int32 pageNum = 5; */
        if (message.pageNum !== 0)
            writer.tag(5, WireType.Varint).int32(message.pageNum);
        /* string refRaw = 6; */
        if (message.refRaw !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.refRaw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.ReferenceMarker
 */
export const ReferenceMarker = new ReferenceMarker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FigureAndTableReferenceMarker$Type extends MessageType<FigureAndTableReferenceMarker> {
    constructor() {
        super("pdf.FigureAndTableReferenceMarker", [
            { no: 1, name: "bbox", kind: "message", T: () => PdfBBox },
            { no: 2, name: "pageNum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "refContent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "refIdx", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FigureAndTableReferenceMarker>): FigureAndTableReferenceMarker {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pageNum = 0;
        message.refContent = "";
        message.refIdx = "";
        if (value !== undefined)
            reflectionMergePartial<FigureAndTableReferenceMarker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FigureAndTableReferenceMarker): FigureAndTableReferenceMarker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* pdf.PdfBBox bbox */ 1:
                    message.bbox = PdfBBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* int32 pageNum */ 2:
                    message.pageNum = reader.int32();
                    break;
                case /* string refContent */ 3:
                    message.refContent = reader.string();
                    break;
                case /* string refIdx */ 4:
                    message.refIdx = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FigureAndTableReferenceMarker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* pdf.PdfBBox bbox = 1; */
        if (message.bbox)
            PdfBBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 pageNum = 2; */
        if (message.pageNum !== 0)
            writer.tag(2, WireType.Varint).int32(message.pageNum);
        /* string refContent = 3; */
        if (message.refContent !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refContent);
        /* string refIdx = 4; */
        if (message.refIdx !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.refIdx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.FigureAndTableReferenceMarker
 */
export const FigureAndTableReferenceMarker = new FigureAndTableReferenceMarker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReferenceMarkersResponse$Type extends MessageType<GetReferenceMarkersResponse> {
    constructor() {
        super("pdf.GetReferenceMarkersResponse", [
            { no: 1, name: "markers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ReferenceMarker },
            { no: 2, name: "needFetch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "figureAndTableMarkers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FigureAndTableReferenceMarker }
        ]);
    }
    create(value?: PartialMessage<GetReferenceMarkersResponse>): GetReferenceMarkersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.markers = [];
        message.needFetch = false;
        message.figureAndTableMarkers = [];
        if (value !== undefined)
            reflectionMergePartial<GetReferenceMarkersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReferenceMarkersResponse): GetReferenceMarkersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated pdf.ReferenceMarker markers */ 1:
                    message.markers.push(ReferenceMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool needFetch */ 2:
                    message.needFetch = reader.bool();
                    break;
                case /* repeated pdf.FigureAndTableReferenceMarker figureAndTableMarkers */ 3:
                    message.figureAndTableMarkers.push(FigureAndTableReferenceMarker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReferenceMarkersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated pdf.ReferenceMarker markers = 1; */
        for (let i = 0; i < message.markers.length; i++)
            ReferenceMarker.internalBinaryWrite(message.markers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool needFetch = 2; */
        if (message.needFetch !== false)
            writer.tag(2, WireType.Varint).bool(message.needFetch);
        /* repeated pdf.FigureAndTableReferenceMarker figureAndTableMarkers = 3; */
        for (let i = 0; i < message.figureAndTableMarkers.length; i++)
            FigureAndTableReferenceMarker.internalBinaryWrite(message.figureAndTableMarkers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetReferenceMarkersResponse
 */
export const GetReferenceMarkersResponse = new GetReferenceMarkersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncPdfCvParseRequest$Type extends MessageType<AsyncPdfCvParseRequest> {
    constructor() {
        super("pdf.AsyncPdfCvParseRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fileSHA256", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fulltext", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AsyncPdfCvParseRequest>): AsyncPdfCvParseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.fileSHA256 = "";
        message.fulltext = false;
        if (value !== undefined)
            reflectionMergePartial<AsyncPdfCvParseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncPdfCvParseRequest): AsyncPdfCvParseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string fileSHA256 */ 2:
                    message.fileSHA256 = reader.string();
                    break;
                case /* bool fulltext */ 3:
                    message.fulltext = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncPdfCvParseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string fileSHA256 = 2; */
        if (message.fileSHA256 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fileSHA256);
        /* bool fulltext = 3; */
        if (message.fulltext !== false)
            writer.tag(3, WireType.Varint).bool(message.fulltext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.AsyncPdfCvParseRequest
 */
export const AsyncPdfCvParseRequest = new AsyncPdfCvParseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncPdfCvParseResponse$Type extends MessageType<AsyncPdfCvParseResponse> {
    constructor() {
        super("pdf.AsyncPdfCvParseResponse", [
            { no: 1, name: "code", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PdfFigureAndTableInfo },
            { no: 3, name: "procStatus", kind: "enum", T: () => ["pdf.ParseStatus", ParseStatus] }
        ]);
    }
    create(value?: PartialMessage<AsyncPdfCvParseResponse>): AsyncPdfCvParseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0n;
        message.data = [];
        message.procStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<AsyncPdfCvParseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncPdfCvParseResponse): AsyncPdfCvParseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 code */ 1:
                    message.code = reader.uint64().toBigInt();
                    break;
                case /* repeated pdf.PdfFigureAndTableInfo data */ 2:
                    message.data.push(PdfFigureAndTableInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* pdf.ParseStatus procStatus */ 3:
                    message.procStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncPdfCvParseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 code = 1; */
        if (message.code !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.code);
        /* repeated pdf.PdfFigureAndTableInfo data = 2; */
        for (let i = 0; i < message.data.length; i++)
            PdfFigureAndTableInfo.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* pdf.ParseStatus procStatus = 3; */
        if (message.procStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.procStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.AsyncPdfCvParseResponse
 */
export const AsyncPdfCvParseResponse = new AsyncPdfCvParseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCatalogueRequest$Type extends MessageType<GetCatalogueRequest> {
    constructor() {
        super("pdf.GetCatalogueRequest", [
            { no: 1, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCatalogueRequest>): GetCatalogueRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetCatalogueRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCatalogueRequest): GetCatalogueRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pdfId */ 1:
                    message.pdfId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCatalogueRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pdfId = 1; */
        if (message.pdfId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pdfId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetCatalogueRequest
 */
export const GetCatalogueRequest = new GetCatalogueRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PdfCatalogueInfo$Type extends MessageType<PdfCatalogueInfo> {
    constructor() {
        super("pdf.PdfCatalogueInfo", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pageNum", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "child", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PdfCatalogueInfo },
            { no: 4, name: "bbox", kind: "message", T: () => PdfBBox }
        ]);
    }
    create(value?: PartialMessage<PdfCatalogueInfo>): PdfCatalogueInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        message.pageNum = 0;
        message.child = [];
        if (value !== undefined)
            reflectionMergePartial<PdfCatalogueInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PdfCatalogueInfo): PdfCatalogueInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* int32 pageNum */ 2:
                    message.pageNum = reader.int32();
                    break;
                case /* repeated pdf.PdfCatalogueInfo child */ 3:
                    message.child.push(PdfCatalogueInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* pdf.PdfBBox bbox */ 4:
                    message.bbox = PdfBBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PdfCatalogueInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* int32 pageNum = 2; */
        if (message.pageNum !== 0)
            writer.tag(2, WireType.Varint).int32(message.pageNum);
        /* repeated pdf.PdfCatalogueInfo child = 3; */
        for (let i = 0; i < message.child.length; i++)
            PdfCatalogueInfo.internalBinaryWrite(message.child[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* pdf.PdfBBox bbox = 4; */
        if (message.bbox)
            PdfBBox.internalBinaryWrite(message.bbox, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.PdfCatalogueInfo
 */
export const PdfCatalogueInfo = new PdfCatalogueInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCatalogueResponse$Type extends MessageType<GetCatalogueResponse> {
    constructor() {
        super("pdf.GetCatalogueResponse", [
            { no: 1, name: "needFetch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "pdfCatalogue", kind: "message", T: () => PdfCatalogueInfo }
        ]);
    }
    create(value?: PartialMessage<GetCatalogueResponse>): GetCatalogueResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needFetch = false;
        if (value !== undefined)
            reflectionMergePartial<GetCatalogueResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCatalogueResponse): GetCatalogueResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool needFetch */ 1:
                    message.needFetch = reader.bool();
                    break;
                case /* pdf.PdfCatalogueInfo pdfCatalogue */ 2:
                    message.pdfCatalogue = PdfCatalogueInfo.internalBinaryRead(reader, reader.uint32(), options, message.pdfCatalogue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCatalogueResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool needFetch = 1; */
        if (message.needFetch !== false)
            writer.tag(1, WireType.Varint).bool(message.needFetch);
        /* pdf.PdfCatalogueInfo pdfCatalogue = 2; */
        if (message.pdfCatalogue)
            PdfCatalogueInfo.internalBinaryWrite(message.pdfCatalogue, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.GetCatalogueResponse
 */
export const GetCatalogueResponse = new GetCatalogueResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PdfRefRematchReq$Type extends MessageType<PdfRefRematchReq> {
    constructor() {
        super("pdf.PdfRefRematchReq", [
            { no: 1, name: "rawStrings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PdfRefRematchReq>): PdfRefRematchReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rawStrings = [];
        if (value !== undefined)
            reflectionMergePartial<PdfRefRematchReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PdfRefRematchReq): PdfRefRematchReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string rawStrings */ 1:
                    message.rawStrings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PdfRefRematchReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string rawStrings = 1; */
        for (let i = 0; i < message.rawStrings.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.rawStrings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.PdfRefRematchReq
 */
export const PdfRefRematchReq = new PdfRefRematchReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PdfRefRematchResp$Type extends MessageType<PdfRefRematchResp> {
    constructor() {
        super("pdf.PdfRefRematchResp", [
            { no: 1, name: "statusCode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "errMsg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "paperids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PdfRefRematchResp>): PdfRefRematchResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusCode = 0;
        message.errMsg = "";
        message.paperids = [];
        if (value !== undefined)
            reflectionMergePartial<PdfRefRematchResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PdfRefRematchResp): PdfRefRematchResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 statusCode */ 1:
                    message.statusCode = reader.int32();
                    break;
                case /* string errMsg */ 2:
                    message.errMsg = reader.string();
                    break;
                case /* repeated string paperids */ 3:
                    message.paperids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PdfRefRematchResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 statusCode = 1; */
        if (message.statusCode !== 0)
            writer.tag(1, WireType.Varint).int32(message.statusCode);
        /* string errMsg = 2; */
        if (message.errMsg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errMsg);
        /* repeated string paperids = 3; */
        for (let i = 0; i < message.paperids.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.paperids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message pdf.PdfRefRematchResp
 */
export const PdfRefRematchResp = new PdfRefRematchResp$Type();
