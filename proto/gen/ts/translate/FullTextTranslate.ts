// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/translate/FullTextTranslate.proto" (package "translate", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @api_path: /fullTextTranslate/getHistoryList
 * @method: GET
 * @content-type: application/json
 * @summary: 获取全文翻译历史记录
 *
 * @generated from protobuf message translate.GetHistoryListReq
 */
export interface GetHistoryListReq {
}
/**
 * @generated from protobuf message translate.GetHistoryListResponse
 */
export interface GetHistoryListResponse {
    /**
     * @generated from protobuf field: repeated translate.HistoryInfo historyList = 1
     */
    historyList: HistoryInfo[];
}
/**
 * @generated from protobuf message translate.HistoryInfo
 */
export interface HistoryInfo {
    /**
     * 翻译结果状态码,0=翻译中,1=翻译完成,2=翻译失败
     *
     * @generated from protobuf field: translate.FullTranslateFlowStatus status = 1
     */
    status: FullTranslateFlowStatus;
    /**
     * 文件名
     *
     * @generated from protobuf field: string docName = 2
     */
    docName: string;
    /**
     * pdfId
     *
     * @generated from protobuf field: optional string pdfId = 3
     */
    pdfId?: string;
    /**
     * 翻译时间
     *
     * @generated from protobuf field: uint64 translateTime = 4
     */
    translateTime: bigint;
}
/**
 * @api_path: /fullTextTranslate/getRightInfo
 * @method: GET
 * @content-type: application/json
 * @summary: 获取用户剩余翻译次数以及是否解锁权限
 *
 * @generated from protobuf message translate.GetFullTextTranslateRightInfoReq
 */
export interface GetFullTextTranslateRightInfoReq {
}
/**
 * @generated from protobuf message translate.GetFullTextTranslateRightInfoResponse
 */
export interface GetFullTextTranslateRightInfoResponse {
    /**
     * 剩余次数
     *
     * @generated from protobuf field: optional int32 remainCount = 1
     */
    remainCount?: number;
    /**
     * 是否解锁权限
     *
     * @generated from protobuf field: bool unlockRight = 2
     */
    unlockRight: boolean;
    /**
     * 规则说明
     *
     * @generated from protobuf field: string ruleDesc = 3
     */
    ruleDesc: string;
}
/**
 * @api_path: /fullTextTranslate/translate
 * @method: POST
 * @content-type: application/json
 * @summary: 全文翻译
 *
 * @generated from protobuf message translate.FullTextTranslateRequest
 */
export interface FullTextTranslateRequest {
    /**
     * 需要翻译的文件url
     *
     * @generated from protobuf field: string needTranslateFileUrl = 1
     */
    needTranslateFileUrl: string;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * @generated from protobuf field: optional string userId = 3
     */
    userId?: string;
    /**
     * @generated from protobuf field: optional bool takeoutTicketFlag = 4
     */
    takeoutTicketFlag?: boolean;
}
/**
 * @generated from protobuf message translate.FullTextTranslateResponse
 */
export interface FullTextTranslateResponse {
    /**
     * 译文url
     *
     * @generated from protobuf field: optional string translationFileUrl = 1
     */
    translationFileUrl?: string;
    /**
     * 0=上传成功(等待翻译结果),非0=翻译失败
     *
     * @generated from protobuf field: string errorCode = 2
     */
    errorCode: string;
    /**
     * @generated from protobuf field: optional string message = 3
     */
    message?: string;
}
/**
 * @api_path: /fullTextTranslate/getTranslateStatus
 * @method: GET
 * @content-type: application/json
 * @summary: 查询翻译状态
 *
 * @generated from protobuf message translate.GetTranslateStatusReq
 */
export interface GetTranslateStatusReq {
    /**
     * 需要翻译的文件url
     *
     * @generated from protobuf field: string needTranslateFileUrl = 1
     */
    needTranslateFileUrl: string;
    /**
     * @generated from protobuf field: string pdfId = 2
     */
    pdfId: string;
    /**
     * @generated from protobuf field: optional string userId = 3
     */
    userId?: string;
}
/**
 * @generated from protobuf message translate.GetTranslateStatusResponse
 */
export interface GetTranslateStatusResponse {
    /**
     * 翻译结果状态码,0=翻译中,1=翻译完成,2=翻译失败,3=无翻译记录
     *
     * @generated from protobuf field: translate.FullTranslateFlowStatus status = 1
     */
    status: FullTranslateFlowStatus;
    /**
     * 译文url
     *
     * @generated from protobuf field: optional string translationFileUrl = 2
     */
    translationFileUrl?: string;
    /**
     * 翻译进度
     *
     * @generated from protobuf field: optional string progressPercent = 3
     */
    progressPercent?: string;
    /**
     * 原文/译文块对照信息
     *
     * @generated from protobuf field: optional string alignment = 4
     */
    alignment?: string;
}
/**
 * 全文翻译流程状态
 *
 * @generated from protobuf enum translate.FullTranslateFlowStatus
 */
export enum FullTranslateFlowStatus {
    /**
     * 翻译中
     *
     * @generated from protobuf enum value: TRANSLATING = 0;
     */
    TRANSLATING = 0,
    /**
     * 翻译完成
     *
     * @generated from protobuf enum value: TRANSLATE_FINISHED = 1;
     */
    TRANSLATE_FINISHED = 1,
    /**
     * 翻译失败
     *
     * @generated from protobuf enum value: TRANSLATE_FAIL = 2;
     */
    TRANSLATE_FAIL = 2,
    /**
     * 无翻译记录
     *
     * @generated from protobuf enum value: WITHOUT_TRANSLATE_HISTORY = 3;
     */
    WITHOUT_TRANSLATE_HISTORY = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryListReq$Type extends MessageType<GetHistoryListReq> {
    constructor() {
        super("translate.GetHistoryListReq", []);
    }
    create(value?: PartialMessage<GetHistoryListReq>): GetHistoryListReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetHistoryListReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryListReq): GetHistoryListReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryListReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetHistoryListReq
 */
export const GetHistoryListReq = new GetHistoryListReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryListResponse$Type extends MessageType<GetHistoryListResponse> {
    constructor() {
        super("translate.GetHistoryListResponse", [
            { no: 1, name: "historyList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HistoryInfo }
        ]);
    }
    create(value?: PartialMessage<GetHistoryListResponse>): GetHistoryListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.historyList = [];
        if (value !== undefined)
            reflectionMergePartial<GetHistoryListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHistoryListResponse): GetHistoryListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated translate.HistoryInfo historyList */ 1:
                    message.historyList.push(HistoryInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHistoryListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated translate.HistoryInfo historyList = 1; */
        for (let i = 0; i < message.historyList.length; i++)
            HistoryInfo.internalBinaryWrite(message.historyList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetHistoryListResponse
 */
export const GetHistoryListResponse = new GetHistoryListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoryInfo$Type extends MessageType<HistoryInfo> {
    constructor() {
        super("translate.HistoryInfo", [
            { no: 1, name: "status", kind: "enum", T: () => ["translate.FullTranslateFlowStatus", FullTranslateFlowStatus] },
            { no: 2, name: "docName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pdfId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "translateTime", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HistoryInfo>): HistoryInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.docName = "";
        message.translateTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<HistoryInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoryInfo): HistoryInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* translate.FullTranslateFlowStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string docName */ 2:
                    message.docName = reader.string();
                    break;
                case /* optional string pdfId */ 3:
                    message.pdfId = reader.string();
                    break;
                case /* uint64 translateTime */ 4:
                    message.translateTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoryInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* translate.FullTranslateFlowStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string docName = 2; */
        if (message.docName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.docName);
        /* optional string pdfId = 3; */
        if (message.pdfId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.pdfId);
        /* uint64 translateTime = 4; */
        if (message.translateTime !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.translateTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.HistoryInfo
 */
export const HistoryInfo = new HistoryInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFullTextTranslateRightInfoReq$Type extends MessageType<GetFullTextTranslateRightInfoReq> {
    constructor() {
        super("translate.GetFullTextTranslateRightInfoReq", []);
    }
    create(value?: PartialMessage<GetFullTextTranslateRightInfoReq>): GetFullTextTranslateRightInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFullTextTranslateRightInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFullTextTranslateRightInfoReq): GetFullTextTranslateRightInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFullTextTranslateRightInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetFullTextTranslateRightInfoReq
 */
export const GetFullTextTranslateRightInfoReq = new GetFullTextTranslateRightInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFullTextTranslateRightInfoResponse$Type extends MessageType<GetFullTextTranslateRightInfoResponse> {
    constructor() {
        super("translate.GetFullTextTranslateRightInfoResponse", [
            { no: 1, name: "remainCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "unlockRight", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "ruleDesc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetFullTextTranslateRightInfoResponse>): GetFullTextTranslateRightInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unlockRight = false;
        message.ruleDesc = "";
        if (value !== undefined)
            reflectionMergePartial<GetFullTextTranslateRightInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFullTextTranslateRightInfoResponse): GetFullTextTranslateRightInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 remainCount */ 1:
                    message.remainCount = reader.int32();
                    break;
                case /* bool unlockRight */ 2:
                    message.unlockRight = reader.bool();
                    break;
                case /* string ruleDesc */ 3:
                    message.ruleDesc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFullTextTranslateRightInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 remainCount = 1; */
        if (message.remainCount !== undefined)
            writer.tag(1, WireType.Varint).int32(message.remainCount);
        /* bool unlockRight = 2; */
        if (message.unlockRight !== false)
            writer.tag(2, WireType.Varint).bool(message.unlockRight);
        /* string ruleDesc = 3; */
        if (message.ruleDesc !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ruleDesc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetFullTextTranslateRightInfoResponse
 */
export const GetFullTextTranslateRightInfoResponse = new GetFullTextTranslateRightInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullTextTranslateRequest$Type extends MessageType<FullTextTranslateRequest> {
    constructor() {
        super("translate.FullTextTranslateRequest", [
            { no: 1, name: "needTranslateFileUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "takeoutTicketFlag", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FullTextTranslateRequest>): FullTextTranslateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needTranslateFileUrl = "";
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<FullTextTranslateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullTextTranslateRequest): FullTextTranslateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string needTranslateFileUrl */ 1:
                    message.needTranslateFileUrl = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* optional string userId */ 3:
                    message.userId = reader.string();
                    break;
                case /* optional bool takeoutTicketFlag */ 4:
                    message.takeoutTicketFlag = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullTextTranslateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string needTranslateFileUrl = 1; */
        if (message.needTranslateFileUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.needTranslateFileUrl);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* optional string userId = 3; */
        if (message.userId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* optional bool takeoutTicketFlag = 4; */
        if (message.takeoutTicketFlag !== undefined)
            writer.tag(4, WireType.Varint).bool(message.takeoutTicketFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.FullTextTranslateRequest
 */
export const FullTextTranslateRequest = new FullTextTranslateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullTextTranslateResponse$Type extends MessageType<FullTextTranslateResponse> {
    constructor() {
        super("translate.FullTextTranslateResponse", [
            { no: 1, name: "translationFileUrl", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errorCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FullTextTranslateResponse>): FullTextTranslateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorCode = "";
        if (value !== undefined)
            reflectionMergePartial<FullTextTranslateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullTextTranslateResponse): FullTextTranslateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string translationFileUrl */ 1:
                    message.translationFileUrl = reader.string();
                    break;
                case /* string errorCode */ 2:
                    message.errorCode = reader.string();
                    break;
                case /* optional string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullTextTranslateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string translationFileUrl = 1; */
        if (message.translationFileUrl !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.translationFileUrl);
        /* string errorCode = 2; */
        if (message.errorCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorCode);
        /* optional string message = 3; */
        if (message.message !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.FullTextTranslateResponse
 */
export const FullTextTranslateResponse = new FullTextTranslateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTranslateStatusReq$Type extends MessageType<GetTranslateStatusReq> {
    constructor() {
        super("translate.GetTranslateStatusReq", [
            { no: 1, name: "needTranslateFileUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "pdfId", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "userId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTranslateStatusReq>): GetTranslateStatusReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needTranslateFileUrl = "";
        message.pdfId = "";
        if (value !== undefined)
            reflectionMergePartial<GetTranslateStatusReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTranslateStatusReq): GetTranslateStatusReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string needTranslateFileUrl */ 1:
                    message.needTranslateFileUrl = reader.string();
                    break;
                case /* string pdfId */ 2:
                    message.pdfId = reader.string();
                    break;
                case /* optional string userId */ 3:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTranslateStatusReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string needTranslateFileUrl = 1; */
        if (message.needTranslateFileUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.needTranslateFileUrl);
        /* string pdfId = 2; */
        if (message.pdfId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pdfId);
        /* optional string userId = 3; */
        if (message.userId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetTranslateStatusReq
 */
export const GetTranslateStatusReq = new GetTranslateStatusReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTranslateStatusResponse$Type extends MessageType<GetTranslateStatusResponse> {
    constructor() {
        super("translate.GetTranslateStatusResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["translate.FullTranslateFlowStatus", FullTranslateFlowStatus] },
            { no: 2, name: "translationFileUrl", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "progressPercent", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "alignment", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTranslateStatusResponse>): GetTranslateStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<GetTranslateStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTranslateStatusResponse): GetTranslateStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* translate.FullTranslateFlowStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* optional string translationFileUrl */ 2:
                    message.translationFileUrl = reader.string();
                    break;
                case /* optional string progressPercent */ 3:
                    message.progressPercent = reader.string();
                    break;
                case /* optional string alignment */ 4:
                    message.alignment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTranslateStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* translate.FullTranslateFlowStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* optional string translationFileUrl = 2; */
        if (message.translationFileUrl !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.translationFileUrl);
        /* optional string progressPercent = 3; */
        if (message.progressPercent !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.progressPercent);
        /* optional string alignment = 4; */
        if (message.alignment !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.alignment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message translate.GetTranslateStatusResponse
 */
export const GetTranslateStatusResponse = new GetTranslateStatusResponse$Type();
