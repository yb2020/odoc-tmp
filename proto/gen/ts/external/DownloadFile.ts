// @generated by protobuf-ts 2.11.1 with parameter use_proto_field_name
// @generated from protobuf file "definitions/external/DownloadFile.proto" (package "external", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * *
 * 	接口描述: 通过url下载文件
 * 	接口url: /services/external/downloadFileByUrl
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message external.DownloadFileByUrlReq
 */
export interface DownloadFileByUrlReq {
    /**
     * @generated from protobuf field: string serviceName = 1
     */
    serviceName: string;
    /**
     * @generated from protobuf field: string downloadToken = 2
     */
    downloadToken: string;
    /**
     * @generated from protobuf field: string downloadUrl = 3
     */
    downloadUrl: string;
}
/**
 * @generated from protobuf message external.DownloadFileByUrlResp
 */
export interface DownloadFileByUrlResp {
}
/**
 * *
 * 	接口描述: 通过下载token获取文件下载状态
 * 	接口url: /services/external/getDownloadStatus
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message external.GetDownloadProgressReq
 */
export interface GetDownloadProgressReq {
    /**
     * @generated from protobuf field: string downloadToken = 1
     */
    downloadToken: string;
}
/**
 * @generated from protobuf message external.GetDownloadProgressResp
 */
export interface GetDownloadProgressResp {
    /**
     * @generated from protobuf field: string downloadToken = 1
     */
    downloadToken: string;
    /**
     * @generated from protobuf field: external.FileStatus downloadStatus = 2
     */
    downloadStatus: FileStatus;
    /**
     * @generated from protobuf field: string fileMd5 = 3
     */
    fileMd5: string;
}
/**
 * *
 * 	接口描述: 接收七牛云的上传信息接口
 * 	接口url: /services/external/receiveQiniuUploadInfo
 * 	接口请求方式: POST
 * 	参数格式:application/json
 *
 * @generated from protobuf message external.ReceiveQiniuUploadInfoReq
 */
export interface ReceiveQiniuUploadInfoReq {
    /**
     * @generated from protobuf field: string downloadToken = 1
     */
    downloadToken: string;
    /**
     * @generated from protobuf field: external.FileStatus downloadStatus = 2
     */
    downloadStatus: FileStatus;
    /**
     * @generated from protobuf field: string fileMd5 = 3
     */
    fileMd5: string;
    /**
     * @generated from protobuf field: external.QiniuUploadInfo uploadTokenInfo = 4
     */
    uploadTokenInfo?: QiniuUploadInfo;
}
/**
 * @generated from protobuf message external.ReceiveQiniuUploadInfoResp
 */
export interface ReceiveQiniuUploadInfoResp {
    /**
     * @generated from protobuf field: string downloadToken = 1
     */
    downloadToken: string;
    /**
     * @generated from protobuf field: string fileMd5 = 2
     */
    fileMd5: string;
}
/**
 * @generated from protobuf message external.QiniuUploadInfo
 */
export interface QiniuUploadInfo {
    /**
     * @generated from protobuf field: bool needUpload = 1
     */
    needUpload: boolean;
    /**
     * 用来解除冲突的token
     *
     * @generated from protobuf field: string conflictToken = 2
     */
    conflictToken: string;
    /**
     * 用来上传文件的token
     *
     * @generated from protobuf field: string uploadToken = 3
     */
    uploadToken: string;
    /**
     * 用来查询文件创建状态的token
     *
     * @generated from protobuf field: string queryStatusToken = 4
     */
    queryStatusToken: string;
}
/**
 * 文件状态
 *
 * @generated from protobuf enum external.FileStatus
 */
export enum FileStatus {
    /**
     * 准备
     *
     * @generated from protobuf enum value: READ = 0;
     */
    READ = 0,
    /**
     * 下载中
     *
     * @generated from protobuf enum value: DOWNLOADING = 1;
     */
    DOWNLOADING = 1,
    /**
     * 下载完成
     *
     * @generated from protobuf enum value: DOWNLOAD_COMPLETED = 2;
     */
    DOWNLOAD_COMPLETED = 2,
    /**
     * 下载失败
     *
     * @generated from protobuf enum value: DOWNLOAD_FAIL = 3;
     */
    DOWNLOAD_FAIL = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class DownloadFileByUrlReq$Type extends MessageType<DownloadFileByUrlReq> {
    constructor() {
        super("external.DownloadFileByUrlReq", [
            { no: 1, name: "serviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "downloadToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "downloadUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DownloadFileByUrlReq>): DownloadFileByUrlReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceName = "";
        message.downloadToken = "";
        message.downloadUrl = "";
        if (value !== undefined)
            reflectionMergePartial<DownloadFileByUrlReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadFileByUrlReq): DownloadFileByUrlReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string serviceName */ 1:
                    message.serviceName = reader.string();
                    break;
                case /* string downloadToken */ 2:
                    message.downloadToken = reader.string();
                    break;
                case /* string downloadUrl */ 3:
                    message.downloadUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadFileByUrlReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string serviceName = 1; */
        if (message.serviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceName);
        /* string downloadToken = 2; */
        if (message.downloadToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.downloadToken);
        /* string downloadUrl = 3; */
        if (message.downloadUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.downloadUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message external.DownloadFileByUrlReq
 */
export const DownloadFileByUrlReq = new DownloadFileByUrlReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadFileByUrlResp$Type extends MessageType<DownloadFileByUrlResp> {
    constructor() {
        super("external.DownloadFileByUrlResp", []);
    }
    create(value?: PartialMessage<DownloadFileByUrlResp>): DownloadFileByUrlResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DownloadFileByUrlResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadFileByUrlResp): DownloadFileByUrlResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadFileByUrlResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message external.DownloadFileByUrlResp
 */
export const DownloadFileByUrlResp = new DownloadFileByUrlResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDownloadProgressReq$Type extends MessageType<GetDownloadProgressReq> {
    constructor() {
        super("external.GetDownloadProgressReq", [
            { no: 1, name: "downloadToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDownloadProgressReq>): GetDownloadProgressReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.downloadToken = "";
        if (value !== undefined)
            reflectionMergePartial<GetDownloadProgressReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDownloadProgressReq): GetDownloadProgressReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string downloadToken */ 1:
                    message.downloadToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDownloadProgressReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string downloadToken = 1; */
        if (message.downloadToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.downloadToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message external.GetDownloadProgressReq
 */
export const GetDownloadProgressReq = new GetDownloadProgressReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDownloadProgressResp$Type extends MessageType<GetDownloadProgressResp> {
    constructor() {
        super("external.GetDownloadProgressResp", [
            { no: 1, name: "downloadToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "downloadStatus", kind: "enum", T: () => ["external.FileStatus", FileStatus] },
            { no: 3, name: "fileMd5", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDownloadProgressResp>): GetDownloadProgressResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.downloadToken = "";
        message.downloadStatus = 0;
        message.fileMd5 = "";
        if (value !== undefined)
            reflectionMergePartial<GetDownloadProgressResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDownloadProgressResp): GetDownloadProgressResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string downloadToken */ 1:
                    message.downloadToken = reader.string();
                    break;
                case /* external.FileStatus downloadStatus */ 2:
                    message.downloadStatus = reader.int32();
                    break;
                case /* string fileMd5 */ 3:
                    message.fileMd5 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDownloadProgressResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string downloadToken = 1; */
        if (message.downloadToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.downloadToken);
        /* external.FileStatus downloadStatus = 2; */
        if (message.downloadStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.downloadStatus);
        /* string fileMd5 = 3; */
        if (message.fileMd5 !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileMd5);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message external.GetDownloadProgressResp
 */
export const GetDownloadProgressResp = new GetDownloadProgressResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReceiveQiniuUploadInfoReq$Type extends MessageType<ReceiveQiniuUploadInfoReq> {
    constructor() {
        super("external.ReceiveQiniuUploadInfoReq", [
            { no: 1, name: "downloadToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "downloadStatus", kind: "enum", T: () => ["external.FileStatus", FileStatus] },
            { no: 3, name: "fileMd5", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "uploadTokenInfo", kind: "message", T: () => QiniuUploadInfo }
        ]);
    }
    create(value?: PartialMessage<ReceiveQiniuUploadInfoReq>): ReceiveQiniuUploadInfoReq {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.downloadToken = "";
        message.downloadStatus = 0;
        message.fileMd5 = "";
        if (value !== undefined)
            reflectionMergePartial<ReceiveQiniuUploadInfoReq>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReceiveQiniuUploadInfoReq): ReceiveQiniuUploadInfoReq {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string downloadToken */ 1:
                    message.downloadToken = reader.string();
                    break;
                case /* external.FileStatus downloadStatus */ 2:
                    message.downloadStatus = reader.int32();
                    break;
                case /* string fileMd5 */ 3:
                    message.fileMd5 = reader.string();
                    break;
                case /* external.QiniuUploadInfo uploadTokenInfo */ 4:
                    message.uploadTokenInfo = QiniuUploadInfo.internalBinaryRead(reader, reader.uint32(), options, message.uploadTokenInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReceiveQiniuUploadInfoReq, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string downloadToken = 1; */
        if (message.downloadToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.downloadToken);
        /* external.FileStatus downloadStatus = 2; */
        if (message.downloadStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.downloadStatus);
        /* string fileMd5 = 3; */
        if (message.fileMd5 !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileMd5);
        /* external.QiniuUploadInfo uploadTokenInfo = 4; */
        if (message.uploadTokenInfo)
            QiniuUploadInfo.internalBinaryWrite(message.uploadTokenInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message external.ReceiveQiniuUploadInfoReq
 */
export const ReceiveQiniuUploadInfoReq = new ReceiveQiniuUploadInfoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReceiveQiniuUploadInfoResp$Type extends MessageType<ReceiveQiniuUploadInfoResp> {
    constructor() {
        super("external.ReceiveQiniuUploadInfoResp", [
            { no: 1, name: "downloadToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fileMd5", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReceiveQiniuUploadInfoResp>): ReceiveQiniuUploadInfoResp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.downloadToken = "";
        message.fileMd5 = "";
        if (value !== undefined)
            reflectionMergePartial<ReceiveQiniuUploadInfoResp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReceiveQiniuUploadInfoResp): ReceiveQiniuUploadInfoResp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string downloadToken */ 1:
                    message.downloadToken = reader.string();
                    break;
                case /* string fileMd5 */ 2:
                    message.fileMd5 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReceiveQiniuUploadInfoResp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string downloadToken = 1; */
        if (message.downloadToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.downloadToken);
        /* string fileMd5 = 2; */
        if (message.fileMd5 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fileMd5);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message external.ReceiveQiniuUploadInfoResp
 */
export const ReceiveQiniuUploadInfoResp = new ReceiveQiniuUploadInfoResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QiniuUploadInfo$Type extends MessageType<QiniuUploadInfo> {
    constructor() {
        super("external.QiniuUploadInfo", [
            { no: 1, name: "needUpload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "conflictToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uploadToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "queryStatusToken", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QiniuUploadInfo>): QiniuUploadInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needUpload = false;
        message.conflictToken = "";
        message.uploadToken = "";
        message.queryStatusToken = "";
        if (value !== undefined)
            reflectionMergePartial<QiniuUploadInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QiniuUploadInfo): QiniuUploadInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool needUpload */ 1:
                    message.needUpload = reader.bool();
                    break;
                case /* string conflictToken */ 2:
                    message.conflictToken = reader.string();
                    break;
                case /* string uploadToken */ 3:
                    message.uploadToken = reader.string();
                    break;
                case /* string queryStatusToken */ 4:
                    message.queryStatusToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QiniuUploadInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool needUpload = 1; */
        if (message.needUpload !== false)
            writer.tag(1, WireType.Varint).bool(message.needUpload);
        /* string conflictToken = 2; */
        if (message.conflictToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.conflictToken);
        /* string uploadToken = 3; */
        if (message.uploadToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uploadToken);
        /* string queryStatusToken = 4; */
        if (message.queryStatusToken !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.queryStatusToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message external.QiniuUploadInfo
 */
export const QiniuUploadInfo = new QiniuUploadInfo$Type();
